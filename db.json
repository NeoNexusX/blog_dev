{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/claudia/source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/claudia/source/js/common.js","path":"js/common.js","modified":0,"renderable":1},{"_id":"themes/claudia/source/js/highlight.pack.js","path":"js/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/claudia/source/js/img_zoom.js","path":"js/img_zoom.js","modified":0,"renderable":1},{"_id":"themes/claudia/source/js/jquery-3.6.1.min.js","path":"js/jquery-3.6.1.min.js","modified":0,"renderable":1},{"_id":"themes/claudia/source/js/jquery-fancybox.min.js","path":"js/jquery-fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/claudia/source/js/post.js","path":"js/post.js","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/about.scss","path":"style/about.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/archive.scss","path":"style/archive.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/base.scss","path":"style/base.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/post.scss","path":"style/post.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/widget-header.scss","path":"style/widget-header.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/widget-post-list.scss","path":"style/widget-post-list.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/common/bulma.css","path":"style/common/bulma.css","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/common/helper.scss","path":"style/common/helper.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/common/jquery.fancybox.min.css","path":"style/common/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/common/variable.scss","path":"style/common/variable.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/themes/default-dark.scss","path":"style/themes/default-dark.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/themes/default-light.scss","path":"style/themes/default-light.scss","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/themes/highlight-theme-light.css","path":"style/themes/highlight-theme-light.css","modified":0,"renderable":1},{"_id":"themes/claudia/source/style/themes/theme.scss","path":"style/themes/theme.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Android.md","hash":"01b81c0c012a309539cb705039fc3efeaafac03e","modified":1732679757798},{"_id":"source/_posts/Android开发笔记——快速入门 (Kotlin与 lamda).md","hash":"3499fbe31242434eaa3734fd4f98cd26c4933b71","modified":1732679757798},{"_id":"source/_posts/Android开发笔记——快速入门 (Kotlin入门).md","hash":"cd5e0ee661bf6e329da88057721fb818f59094f3","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门 (Kotlin的NULL) .md","hash":"84c5699307999c25b39a8f5057f7d8a7ca848bf5","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门 (Kotlin的对象扩展语法) .md","hash":"b3b743d1d5d364c37faae5d598584664fe941fa3","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门 (Kotlin的延迟初始与密封类) .md","hash":"2666a8b43b94a9923709440c6c56e202aefe93bb","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门 (Kotlin的标准函数和静态方法).md","hash":"be76420d16bdc4db1a5dfee1d2e3ecc383d1122a","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门 (Kotlin的面对对象) .md","hash":"e468f7dfbaa7c1676b215b810b125f7962297441","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门（Activity2） .md","hash":"6cde17d7adbf289de47bf6ce82da9f41f74de4fc","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门（Fragment中使用Viewbinding）.md","hash":"2572c3011f6c8947a99de9777d3da53c63ab617a","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门（Service）.md","hash":"d19c720f9a67a16aa5cc84909a238937e1304217","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门（从入门ACT到Fragment放肆）.md","hash":"9384ed2d9245e2561cb3b0740986791a92760f3c","modified":1732679757799},{"_id":"source/_posts/Android开发笔记——快速入门（从入门SQLlite到Room放肆）.md","hash":"8847707ec27cc2d0c169fb9f4be1d92e7a64fa91","modified":1732679757800},{"_id":"source/_posts/Android开发笔记——快速入门（从入门SQLlite到Room放肆）2 .md","hash":"cf41a0174cb458c0a6e6f3b21bbb49f9da826465","modified":1732679757800},{"_id":"source/_posts/Android开发笔记——快速入门（优雅的使用ViewBinding开发）.md","hash":"30f5341a49207589bba0fdbcf9dfeb9230c5f66d","modified":1732679757800},{"_id":"source/_posts/Android开发笔记——快速入门（常用组件）.md","hash":"51688abd259205cc0d86528e142ac929a1e5323d","modified":1732679757800},{"_id":"source/_posts/Android开发笔记——快速入门（广播机制）.md","hash":"0b564afafd099d2e30759ebecdad5e972f4cd2ab","modified":1732679757800},{"_id":"source/_posts/Android开发笔记——快速入门（系统架构和环境搭建）.md","hash":"17224c262b84e7e591e751d0046efdecd2eb3e7f","modified":1732679757800},{"_id":"source/_posts/Bionet-Server01使用说明 ——Docker篇.md","hash":"94eedc97adc1c3cc6080288d5aa89de99e68edd3","modified":1760174925074},{"_id":"source/_posts/Bionet-Server01使用说明.md","hash":"8be42b680120287ee7c3376b04505dfba18b9fd7","modified":1732679757800},{"_id":"source/_posts/Bionet_WiFi.md","hash":"27958caf9e94af392fbedb97fd3bca6cf56264f2","modified":1732679757801},{"_id":"source/_posts/Git__Base(1).md","hash":"ec941c5f274100b14ddfaf21256dbe3bad1c25fc","modified":1729529443862},{"_id":"source/_posts/Git__Base(2).md","hash":"9c8318035cba5d8adb38444137bc199a9a7187e4","modified":1729529448784},{"_id":"source/_posts/Hexo+github+Markdown博客搭建.md","hash":"b28dac6c8ee989a9aa8c7d6aceae252d732e1cec","modified":1732679757801},{"_id":"source/_posts/JaP_Photo_Album(1).md","hash":"4d055c72c3196a3556a9aa6cabc0a97f3092869e","modified":1732679757801},{"_id":"source/_posts/JaP_Photo_Album(2) .md","hash":"87c7282e92707d2334b8a2e034b9916416dfbee3","modified":1732679757801},{"_id":"source/_posts/MOS管 —— 快速复苏应用笔记[原理篇].md","hash":"3f55772988d018e0065a1d165d56d603c5b38dd9","modified":1732679757801},{"_id":"source/_posts/MOS管 —— 快速复苏应用笔记[参数与应用篇].md","hash":"d6a34e2583a71333cfd9822333d9dc3e00b244dc","modified":1732679757801},{"_id":"source/_posts/NAS服务器使用说明.md","hash":"fd8a468a09e9eb8659491ef97684845b7801cc23","modified":1732679757801},{"_id":"source/_posts/PyCharm使用技巧（1）——编辑基础部分.md","hash":"4f55afc1d74d7f6fe9b159ba6023f09f6feac354","modified":1730868689572},{"_id":"source/_posts/PyCharm使用技巧（2）——代码补全.md","hash":"3384da98b44dc1112a4efd957497856c35252ffc","modified":1730868706743},{"_id":"source/_posts/Python筑基(1)——面对对象.md","hash":"527217394e08c37ca625f26c1a62a89380e3e5e8","modified":1730868925805},{"_id":"source/_posts/Scala应用笔记.md","hash":"ea97dc8ef1cad551b3ded0ed0778f6d2796e932c","modified":1732679757802},{"_id":"source/_posts/Spark(1).md","hash":"00099019f791df0cdd73637dc8fd67e53e313a1d","modified":1732679757802},{"_id":"source/_posts/Spark(2).md","hash":"919191d0d756836711f2fb268d96a398c0e2d849","modified":1732679757802},{"_id":"source/_posts/Spark(3).md","hash":"1586a96c36d6c51ef0f81e3c91b7c6250ba8107d","modified":1732679757802},{"_id":"source/_posts/Spark(4).md","hash":"3d403af466dc37746cfd8eddd0f0075748ceec5e","modified":1732679757802},{"_id":"source/_posts/Spark(5).md","hash":"4cea1ce4dc64a5c30a1df0ddc3de6eb17a2ad6e8","modified":1732679757802},{"_id":"source/_posts/Spark(5_1).md","hash":"216da90752ccba6769b22ce3deceee30ecda3d7e","modified":1732679757802},{"_id":"source/_posts/Spark(6).md","hash":"1632ff87ebe4bcd2d4b418aaef3c99f65ff95256","modified":1732679757802},{"_id":"source/_posts/Spark(7).md","hash":"6852383815a5f285edb758543708045815578d17","modified":1732679757802},{"_id":"source/_posts/pytorch_1.md","hash":"bde3505ab8d42a73e99311009505b89aa721c67a","modified":1732679757802},{"_id":"source/_posts/pytorch_2.md","hash":"dc7802b24686d806371cef197467aff8738dcde1","modified":1732679757802},{"_id":"source/_posts/pytorch_3.md","hash":"4d8e6e587bf154040307bff3f87a51f1b33843af","modified":1732679757803},{"_id":"source/_posts/pytorch_4.md","hash":"0e4fe5f8f2a7de97815b4b2d71b7812ec87ee55e","modified":1732679757803},{"_id":"source/_posts/pytorch_5.md","hash":"e02c3ad1330a1b71558f277f8e5f6984cdc8b065","modified":1732679757803},{"_id":"source/_posts/pytorch_6.md","hash":"af5a974e3c419ece1662de8e2ea5d44093c65d6e","modified":1732679757803},{"_id":"source/_posts/pytorch_7.md","hash":"3905529e1645fb29ca081b59a61798ead73605bf","modified":1732679757803},{"_id":"source/_posts/从C过渡到C++(1)--GNU&Linux.md","hash":"c74d1028d5c302c0fe6b945eeeb644bfdad140a2","modified":1732679757803},{"_id":"source/_posts/运算放大器  ——  快速复苏笔记[贰]（应用篇）.md","hash":"bf4e9bdbe48057c8aecc04a14dec589d675475df","modified":1732679757804},{"_id":"source/_posts/运算放大器  ——  快速复苏笔记（参数篇）.md","hash":"e66a9c8ab91b82506a851f80d513813a77d56857","modified":1732679757804},{"_id":"source/_posts/构建一台先进的深度学习服务器.md","hash":"b8fc048335cd5dd157d035ecd39e441f9f614202","modified":1732679757803},{"_id":"themes/claudia/.gitignore","hash":"bd20d54c57507594cd16a21021c3600f9311a1f5","modified":1727528793859},{"_id":"themes/claudia/CHANGELOG.md","hash":"59b1995c016ad26343409f7ddff9f5feb75038e2","modified":1727528793859},{"_id":"themes/claudia/CODE_OF_CONDUCT.md","hash":"787b987cd6079f93c7846b69c3b4dfa41cb3ac03","modified":1727528793859},{"_id":"themes/claudia/CONTRIBUTING.md","hash":"618215987cc9a774c37cc70efa1cb8545457a49c","modified":1727528793859},{"_id":"themes/claudia/LICENSE","hash":"9812afb9d0aa8596067b6fd30cf6089345b7b678","modified":1727528793859},{"_id":"themes/claudia/README-CN.md","hash":"4688e3f1046585e3d7ae79f63104ed301864a240","modified":1727528793859},{"_id":"themes/claudia/README.md","hash":"c6f8d7e06f79a64d18aeee6592dd44abe097cf77","modified":1727528793859},{"_id":"themes/claudia/_config.yml","hash":"5baeeeb211e03e5e7ec4e2594e285465b35c151e","modified":1732679757804},{"_id":"themes/claudia/package.json","hash":"c59cb2089c51ed56deb2df69171d7adc63c1148f","modified":1727528793861},{"_id":"themes/claudia/.github/FUNDING.yml","hash":"dd672081ec4678929f6c1ac3ebbef4d990291ecd","modified":1727528793859},{"_id":"themes/claudia/.github/PULL_REQUEST_TEMPLATE.md","hash":"35751990a36fffe5a5f6fd682452fe5594cadde9","modified":1727528793859},{"_id":"themes/claudia/languages/en.yml","hash":"66d680dcaaa2374c8a400c7266e48a4f662a9035","modified":1727528793860},{"_id":"themes/claudia/languages/zh-CN.yml","hash":"dfaa6ca86d6dc041616f09e5e0b16221bdf7e122","modified":1727528793860},{"_id":"themes/claudia/layout/about.pug","hash":"98dea176f76053d5deaf35ed25518d218d70be7d","modified":1727528793860},{"_id":"themes/claudia/layout/archive.pug","hash":"68c709495bc39a659d9c4b19216714a5ac2b5579","modified":1727528793860},{"_id":"themes/claudia/layout/category.pug","hash":"2147f3d66640bc6604c9b15325a480d196a4df3d","modified":1727528793860},{"_id":"themes/claudia/layout/index.pug","hash":"96b3b857b19b62823f84a164d20293cc16d891aa","modified":1727786008377},{"_id":"themes/claudia/layout/page.pug","hash":"8c1d4e86e8a701928aa19c1ed02913baff8c6afc","modified":1732679757804},{"_id":"themes/claudia/layout/post.pug","hash":"e45a6bc0fbbc98b8d5055bdf2198d50a04e78667","modified":1732679757804},{"_id":"themes/claudia/layout/tag.pug","hash":"16dac6e0a6ef939ceb6adb21dfbe0276538ff269","modified":1727528793860},{"_id":"themes/claudia/.github/ISSUE_TEMPLATE/bug_report.md","hash":"b38365fec9b6cac6bbb75441082f041c4efd35bf","modified":1727528793859},{"_id":"themes/claudia/.github/ISSUE_TEMPLATE/feature_request.md","hash":"9d8447814c3ac93d7fbd336015e7ef80c4a32831","modified":1727528793859},{"_id":"themes/claudia/layout/widget/base.pug","hash":"21a5eab68859adedc9997581fc54e848693c17d4","modified":1727528793860},{"_id":"themes/claudia/layout/widget/methods.pug","hash":"fa62f6ad95d1a4cda5038595d19d4d11b4b39e17","modified":1727528793860},{"_id":"themes/claudia/layout/widget/widget-archives.pug","hash":"e6bcf8b09a5e06119baf3f97f7798ef7600ab65c","modified":1727528793860},{"_id":"themes/claudia/layout/widget/widget-categories.pug","hash":"ea3bcd5f5fb06e26d8b67f30f224e7c129672980","modified":1727528793860},{"_id":"themes/claudia/layout/widget/widget-header.pug","hash":"5e9b2035b31372c2bb11db6efe0e36b7df64d884","modified":1727528793860},{"_id":"themes/claudia/layout/widget/widget-post-list.pug","hash":"f034a4b8231f7933d06e364671b11847c74b9a5c","modified":1727528793860},{"_id":"themes/claudia/layout/widget/widget-profile.pug","hash":"fbe18f3dd5e8d2850f8e6510da4fbd499d5096f0","modified":1727528793861},{"_id":"themes/claudia/layout/widget/widget-recent.pug","hash":"7512dceae690ea219d562a6e450d633e29916072","modified":1727528793861},{"_id":"themes/claudia/layout/widget/widget-search.pug","hash":"c17612dd4ae2d439d757818ec0e4215d71dd9ad5","modified":1727528793861},{"_id":"themes/claudia/layout/widget/widget-sns.pug","hash":"8ec154d321b36a5f3bf5974c75668b45ec660c1d","modified":1727528793861},{"_id":"themes/claudia/layout/widget/widget-tag.pug","hash":"714a05148758e1e3cc12635c875cb6ef1753c6ab","modified":1727528793861},{"_id":"themes/claudia/source/images/favicon.ico","hash":"da1f8b579bd0650ba462c8b5ef0b6c04f95153a5","modified":1729521429607},{"_id":"themes/claudia/source/js/common.js","hash":"43814cd8cfb66783dbb0ec2164f03c8d17d63ff2","modified":1727528793863},{"_id":"themes/claudia/source/js/img_zoom.js","hash":"a384c3a60fcbdad813cb8340200dfb07ebbcc48c","modified":1727528793863},{"_id":"themes/claudia/source/js/post.js","hash":"32470c879db40741f39a3ed1c24a1a83eb40f819","modified":1732679757809},{"_id":"themes/claudia/source/style/about.scss","hash":"4a1beebb317c598b11fc4815e70b07bbb6d2aed7","modified":1727528793863},{"_id":"themes/claudia/source/style/archive.scss","hash":"cd1dc16dfa7c482cc88ddabaf8c9a459299a98cf","modified":1727528793863},{"_id":"themes/claudia/source/style/base.scss","hash":"90084489704037c7c5695d5fcafa015e6ef7d2f6","modified":1727546271102},{"_id":"themes/claudia/source/style/post.scss","hash":"8a3520a0ceb22a2fde35b09485e2df6dd5a23b6f","modified":1727528793864},{"_id":"themes/claudia/source/style/widget-header.scss","hash":"18782c2ab206abbeb0ee59632864251acfd20d85","modified":1727528793864},{"_id":"themes/claudia/source/style/widget-post-list.scss","hash":"53ea5dc4fb868f3553a5c117e528082ba3c7961c","modified":1727528793864},{"_id":"themes/claudia/source/style/common/helper.scss","hash":"7cd0982fe839e760523f8f85ea6f06f2b5d2111a","modified":1727528793864},{"_id":"themes/claudia/source/style/common/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1727528793864},{"_id":"themes/claudia/source/style/common/variable.scss","hash":"fffe6eacfa4d814626a1e1d84dc651233eded060","modified":1727528793864},{"_id":"themes/claudia/source/style/themes/default-dark.scss","hash":"0cbdc5738503f55e5b84e1bd00e445c98c7d56d2","modified":1727528793864},{"_id":"themes/claudia/source/style/themes/default-light.scss","hash":"23e7c1f87e252db80d34d36a2129e98dde7b1b55","modified":1727528793864},{"_id":"themes/claudia/source/style/themes/highlight-theme-light.css","hash":"f7b19080f00e10723bc86e6819fc25143a0137c5","modified":1727528793864},{"_id":"themes/claudia/source/style/themes/theme.scss","hash":"caf7517c9200bbf7152a7f5edba4298fbf9ae629","modified":1727528793864},{"_id":"themes/claudia/img.png","hash":"2239d04aa7d31850b024d3ccac609fbf9dcb98d2","modified":1727528793860},{"_id":"themes/claudia/source/js/jquery-3.6.1.min.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1727528793863},{"_id":"themes/claudia/source/js/jquery-fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1727528793863},{"_id":"themes/claudia/source/style/common/bulma.css","hash":"7ede761951c6f274850a1038416559a8f648c493","modified":1727528793864},{"_id":"themes/claudia/source/js/highlight.pack.js","hash":"c5ec20ff9af8a1918d70aaab31d3eac7ac0b4687","modified":1732679757808},{"_id":"public/atom.xml","hash":"4a5840887cc896053ff9fafcf943cbb8b481bcba","modified":1760257865903},{"_id":"public/search.xml","hash":"a9bbda8efbae13665e3959ecd5a2185e8b2c86a4","modified":1760257865903},{"_id":"public/2024/11/27/JaP_Photo_Album(1)/index.html","hash":"a48a62f812740b4be06d14228eb55a75e07e19f6","modified":1760174410400},{"_id":"public/2024/11/27/JaP_Photo_Album(2) /index.html","hash":"b8967e70010703c582ca200925218319d11a57b5","modified":1760174410400},{"_id":"public/2024/10/22/Git__Base(1)/index.html","hash":"875d88d4b76a27ffeeb1e6533bf6af3cca579877","modified":1760257865903},{"_id":"public/2024/10/22/Git__Base(2)/index.html","hash":"2532a0fc2de4cacbcf27e446e5fd37e64820feaf","modified":1760257865903},{"_id":"public/2024/10/22/Android/index.html","hash":"cf858b80a909a7896e6acd0a7cbd2389e3ec62a9","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门 (Kotlin与 lamda)/index.html","hash":"47b56b1a10953812f523814f6fb3d0e102ecba3d","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门 (Kotlin入门)/index.html","hash":"427938940d0724f3f1d68d4d6add31b39dbfdf1a","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门 (Kotlin的NULL) /index.html","hash":"56a7ce7b9fb764d302bca607514b4a0813891d83","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门 (Kotlin的对象扩展语法) /index.html","hash":"a6d19ba6be5d4f41d70d0f0c835f96cd8e627fff","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门 (Kotlin的延迟初始与密封类) /index.html","hash":"f6e2c23785687537849aae13e9503202482d8c8f","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门 (Kotlin的标准函数和静态方法)/index.html","hash":"554c9d4fca712ca67a60ba0b12844270e944208e","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门 (Kotlin的面对对象) /index.html","hash":"ac8d01e78b41b1c839c2ed73801d09e7a3b36092","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（Activity2） /index.html","hash":"a71d3f726a4fd97288b74af846aade3ac0edde89","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（Fragment中使用Viewbinding）/index.html","hash":"c2fdcdd2538d051787fb7484e3f9c9ab8ad27b8e","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（Service）/index.html","hash":"33b92da73b1afb9d6589db7b93da95580b648cea","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（从入门ACT到Fragment放肆）/index.html","hash":"6567e6e33d0e2af85787e295ecbb59456ff0eea0","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（从入门SQLlite到Room放肆）/index.html","hash":"d76d1a0372d7ed4b55a2d5093fe6b207dd353006","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（从入门SQLlite到Room放肆）2 /index.html","hash":"4d76e5734dce9779aaff29ccbad30aa531f25a2e","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（优雅的使用ViewBinding开发）/index.html","hash":"adf5941c7da7696de56f81a5a1281528869d35fe","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（常用组件）/index.html","hash":"a825bd5916ce2d2eda4c156849deb49458c9dc27","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（广播机制）/index.html","hash":"cbdcef5c83bf00b0d6d4fe7e46fe5b5dbe4af83b","modified":1760174410400},{"_id":"public/2024/10/22/Android开发笔记——快速入门（系统架构和环境搭建）/index.html","hash":"7996b89e9d1db4d4a2f7f295ea7a70814a1f1e2b","modified":1760174410400},{"_id":"public/2024/10/22/Spark(2)/index.html","hash":"d5ce3db58db858dfe4fe6a3e58bd9e5d0437965f","modified":1760174410400},{"_id":"public/2024/10/22/Scala应用笔记/index.html","hash":"85e2485b9ef5b9f50e8802721b8dec32cbcf3023","modified":1760174410400},{"_id":"public/2024/10/22/Spark(3)/index.html","hash":"6c2aa6ca5b482bbba1991196a9ad86cc23b36235","modified":1760174410400},{"_id":"public/2024/10/22/Spark(4)/index.html","hash":"1af840b2a0b2d2b65b2d628e12b5ac3551dbf37f","modified":1760174410400},{"_id":"public/2024/10/22/Spark(5)/index.html","hash":"6f0a2cbc5b08c13072b355af238bcd652f228346","modified":1760174410400},{"_id":"public/2024/10/22/Spark(5_1)/index.html","hash":"3f767234aeeceaece76ca276c88022179c9fa39d","modified":1760174410400},{"_id":"public/2024/10/22/Spark(7)/index.html","hash":"fc6c84d980c259f72571357e0414ba58bd1acbf5","modified":1760174410400},{"_id":"public/2024/10/22/Spark(6)/index.html","hash":"ab50348ac50a2235c8465db61c257c7fb9b274e4","modified":1760174410400},{"_id":"public/2024/10/21/MOS管 —— 快速复苏应用笔记[原理篇]/index.html","hash":"17496574312801e321440c49e8ef1ef01770eb49","modified":1760174410400},{"_id":"public/2024/10/21/MOS管 —— 快速复苏应用笔记[参数与应用篇]/index.html","hash":"6d5602df76ed33161e91a6af9b2cf62e2414df0a","modified":1760174410400},{"_id":"public/2024/10/21/Spark(1)/index.html","hash":"eed01ac20814e9bb28707c489ee19f06e6b7a5eb","modified":1760174410400},{"_id":"public/2024/09/29/Bionet_WiFi/index.html","hash":"0b182f5690343e6f446cb2df7420dd763d9e1d3a","modified":1760257865903},{"_id":"public/2024/09/29/NAS服务器使用说明/index.html","hash":"a5128a3372464f248fb02149c4af0a6fd50c073d","modified":1760257865903},{"_id":"public/2024/09/28/运算放大器  ——  快速复苏笔记[贰]（应用篇）/index.html","hash":"9bb6c9bd3e0d15d5a732e5c9feb887be400ccf79","modified":1760174410400},{"_id":"public/2024/09/28/运算放大器  ——  快速复苏笔记（参数篇）/index.html","hash":"fa8dedd2f3301dc17bee398031092c9450f30d2f","modified":1760174410400},{"_id":"public/2024/09/28/Python筑基(1)——面对对象/index.html","hash":"7527f79751a7505e7514ec6f66f24691289330af","modified":1760257865903},{"_id":"public/2024/09/28/pytorch_1/index.html","hash":"fc18712406ac55cd17a7cced0697c270a0d1992b","modified":1760174410400},{"_id":"public/2024/09/28/pytorch_2/index.html","hash":"115a3a46750569229fd8674077d31f69ece395c5","modified":1760174410400},{"_id":"public/2024/09/28/pytorch_3/index.html","hash":"a86d6a08a4239b4694ec40a017814b63e42d43eb","modified":1760174410400},{"_id":"public/2024/09/28/pytorch_4/index.html","hash":"55c4ca42bd8f333bdb7fb4c82f1a192316a4fe1f","modified":1760174410400},{"_id":"public/2024/09/28/pytorch_5/index.html","hash":"dab1048fdf43af921f02e481666c6b3c408def22","modified":1760174410400},{"_id":"public/2024/09/28/pytorch_6/index.html","hash":"84a179d6a6e5784b3856883c0d9337e99974c872","modified":1760174410400},{"_id":"public/2024/09/28/pytorch_7/index.html","hash":"4ee6fb9fcd331e951c1306a99e3dacef8c8dabe5","modified":1760174410400},{"_id":"public/2024/09/28/从C过渡到C++(1)--GNU&Linux/index.html","hash":"c3ecdf690cea0f33c2ee9608e3db18c6ae7b70e7","modified":1760174410400},{"_id":"public/2024/09/21/Bionet-Server01使用说明/index.html","hash":"f1dbccf6829e241c07c17745422169bbb6ba5b9e","modified":1760257865903},{"_id":"public/2024/09/21/Bionet-Server01使用说明 ——Docker篇/index.html","hash":"efbdd4705cf1d6d2a696c7157dfa910cf64e1a78","modified":1760257865903},{"_id":"public/2024/09/21/Hexo+github+Markdown博客搭建/index.html","hash":"956edb21f13303aca5445fefb90bab44530e3730","modified":1760257865903},{"_id":"public/2024/09/21/构建一台先进的深度学习服务器/index.html","hash":"c9a0376c574a25f1a49fcbb45844334ab1d62a85","modified":1760174410400},{"_id":"public/2023/10/21/PyCharm使用技巧（1）——编辑基础部分/index.html","hash":"2a6769acfd72d39aa88e0b70b3cdaa60107bb889","modified":1760257865903},{"_id":"public/2023/10/21/PyCharm使用技巧（2）——代码补全/index.html","hash":"a9e085adedddf438a980958ee182c97f96ccd70f","modified":1760257865903},{"_id":"public/archives/index.html","hash":"dcea8c1b3b7861d0a7997ec0f1b1a1b4ad6c13ef","modified":1760257865903},{"_id":"public/archives/page/2/index.html","hash":"4c660c412bf36c0a73f204dd8fecf750a764be52","modified":1760257865903},{"_id":"public/archives/page/3/index.html","hash":"3161a5e2963cc6b596403a95c8981083646fe8ec","modified":1760174410400},{"_id":"public/archives/page/4/index.html","hash":"57b005ad919713c45c4f240b88b55411fe690e14","modified":1760174410400},{"_id":"public/archives/page/5/index.html","hash":"f0c922fc5cc80a793b36f5bc3a4d6778502273e1","modified":1760174410400},{"_id":"public/archives/page/6/index.html","hash":"04de4db7b72f3ba416752b5ace6cbdf5519e473d","modified":1760174410400},{"_id":"public/archives/2023/index.html","hash":"0913f61d297fc91e5add036581d120ada603c659","modified":1760257865903},{"_id":"public/archives/2023/10/index.html","hash":"0913f61d297fc91e5add036581d120ada603c659","modified":1760257865903},{"_id":"public/archives/2024/index.html","hash":"cb885e736dcd02e2c44f4748a113bbbf341ab367","modified":1760257865903},{"_id":"public/archives/2024/page/2/index.html","hash":"373f034c08a632213f74fe5a3ad2d677fdc4f3d3","modified":1760174410400},{"_id":"public/archives/2024/page/3/index.html","hash":"927349567c103644a23acbe3268f0b0dcdf3dd64","modified":1760174410400},{"_id":"public/archives/2024/page/4/index.html","hash":"7f6a53b38ee6fbf8295a5900e8463cbd384aed78","modified":1760174410400},{"_id":"public/archives/2024/page/5/index.html","hash":"240c9a2b6d6fb79c2438c04a1a61fd1645df0468","modified":1760174410400},{"_id":"public/archives/2024/09/index.html","hash":"f8a50187435fe28e7a839c569984903f36c2a16d","modified":1760257865903},{"_id":"public/archives/2024/09/page/2/index.html","hash":"17ccb0d28f659c3bfddf6a6fef4ec3f65999b082","modified":1760174410400},{"_id":"public/archives/2024/10/index.html","hash":"7f8a8901732d7f6a780572b0af70d63e77b39176","modified":1760257865903},{"_id":"public/archives/2024/10/page/2/index.html","hash":"1c6c2fa60fa86b91db29d4e997ae8fd120df8254","modified":1760174410400},{"_id":"public/archives/2024/10/page/3/index.html","hash":"2750278f176f3ddd42768c6eaa1b4002ab4361bd","modified":1760174410400},{"_id":"public/archives/2024/10/page/4/index.html","hash":"eeca8a2c186748d84d0561c73441e7f6b026970f","modified":1760174410400},{"_id":"public/archives/2024/11/index.html","hash":"a78f826efd1ad94e1113fdcce70a98228a7f1141","modified":1760174410400},{"_id":"public/categories/Android/index.html","hash":"d71d8bd8e42f89457e92b312987b0167eb2d69e8","modified":1760174410400},{"_id":"public/categories/Android/page/2/index.html","hash":"4b207ff1cf48cde29b3113b9eca2292a24415716","modified":1760174410400},{"_id":"public/categories/Android/Kotlin/index.html","hash":"e39ecbd52b8cc430ef687ba9123704fcdf26f985","modified":1760174410400},{"_id":"public/categories/Android/Activity/index.html","hash":"e9d643f4e719e262d1fa6151e3f6de72461eaa48","modified":1760174410400},{"_id":"public/categories/Bionet/index.html","hash":"b69c06ecb5c874cb96a622ddf3e459ede8c341d9","modified":1760257865903},{"_id":"public/categories/git/index.html","hash":"6db692122748f652675716579e01e37611160388","modified":1760257865903},{"_id":"public/categories/JAP/index.html","hash":"5d526fe570f45404c11fc9e33e1430bed0079228","modified":1760174410400},{"_id":"public/categories/MOSFET/index.html","hash":"3eba846b7d47471cce1d6cfed98e5023469f66e6","modified":1760174410400},{"_id":"public/categories/Pycharm/index.html","hash":"3d77dbddaf56155c62505ac1f258f733d87697a1","modified":1760257865903},{"_id":"public/categories/Pytorch/index.html","hash":"311873e2a80a6758fd582945a11270913ae0bc8b","modified":1760257865903},{"_id":"public/categories/Spark/index.html","hash":"2d7d223edb8cff22da8482f4809c79b3f32f2240","modified":1760174410400},{"_id":"public/categories/Scala/index.html","hash":"8630c4ef764075a41151b2d00a188dc754951a8f","modified":1760174410400},{"_id":"public/categories/Spark/Hadoop/index.html","hash":"54d9b8aae85198d5c68bcdb02efcc588d1cae11f","modified":1760174410400},{"_id":"public/categories/C-C/index.html","hash":"2f387c393575c184df057bbdcdca26252ddeee9c","modified":1760174410400},{"_id":"public/categories/Operational-Amplifier/index.html","hash":"01f174a570ea2bc1a17d75550264a6cfb5a5dac8","modified":1760174410400},{"_id":"public/categories/Spark/Hadoop/Scala/index.html","hash":"5cf3465ed65bd1d4049b6a4b8bd8eb4615cd7d2b","modified":1760174410400},{"_id":"public/categories/Spark/Hadoop/Scala/Hive/index.html","hash":"b70692c4d454d80678c030c730e92b0f778eb5b8","modified":1760174410400},{"_id":"public/index.html","hash":"5327f2dc57221b1837e733625548c0dc5896a792","modified":1760257865903},{"_id":"public/page/2/index.html","hash":"85c88851e5dbb0542a3abc27f9b176e7e5ac1112","modified":1760257865903},{"_id":"public/page/3/index.html","hash":"6c4f1a751d4daa3c5343169b9dae9aff7bc209c0","modified":1760257865903},{"_id":"public/page/4/index.html","hash":"1a16f136680b49320efe2e6b94d8d35854225770","modified":1760174410400},{"_id":"public/page/5/index.html","hash":"60187de610e364bc2456c00b0d027fd199908d50","modified":1760174410400},{"_id":"public/page/6/index.html","hash":"7af8f82e2d95485ed7f6a0f8f42ab4f3fd7ad0dc","modified":1760174410400},{"_id":"public/page/7/index.html","hash":"0be1c667b25ddcd52c46b8be20031622b38073ca","modified":1760174410400},{"_id":"public/page/8/index.html","hash":"df76dc4cbf8679830f1701dfb3b8742596ef39db","modified":1760174410400},{"_id":"public/page/9/index.html","hash":"4375556664fd7ae3b63c4eb8dcbb543bf73fed68","modified":1760174410400},{"_id":"public/page/10/index.html","hash":"f4047a74788d2b0ab27e68c22cdcbbe773d5b465","modified":1760174410400},{"_id":"public/page/11/index.html","hash":"2111405b03545f86187311456979c9166c9f7d10","modified":1760174410400},{"_id":"public/tags/Android/index.html","hash":"1781547253650980af9f973aaa6b9f71efd87b36","modified":1760174410400},{"_id":"public/tags/Android/page/2/index.html","hash":"9736e301be99824f0ee26ca906f745af55425c03","modified":1760174410400},{"_id":"public/tags/Kotlin/index.html","hash":"7c9716bb06301a84c058f7ba4c5d2f6f8408449f","modified":1760174410400},{"_id":"public/tags/Viewbinding/index.html","hash":"3a3efc00b30c61372870619aaae7259d9f8fcd30","modified":1760174410400},{"_id":"public/tags/Activity/index.html","hash":"0bc07e8e43d2e44f301786f27fe124cb2d6aaf80","modified":1760174410400},{"_id":"public/tags/Fragment/index.html","hash":"7f6f540433a9b45290608888b26c78cb5b7e0fe4","modified":1760174410400},{"_id":"public/tags/Android-Service/index.html","hash":"faf4c286962481156b3dd998d09ada2260f3e905","modified":1760174410400},{"_id":"public/tags/SQLlite/index.html","hash":"070a1b43ae749f82329459d211cb5ff20bc6cfe3","modified":1760174410400},{"_id":"public/tags/Room/index.html","hash":"3813502abf2a13a7c612b6bfabf2745b5e37a588","modified":1760174410400},{"_id":"public/tags/RecycleView/index.html","hash":"0261bd366c136bb17c7f954ec83414b13ab41dfa","modified":1760174410400},{"_id":"public/tags/BroadcastReceiver/index.html","hash":"2e516f03663e14e2142a3e22e286f8299e9894bf","modified":1760174410400},{"_id":"public/tags/Bionet/index.html","hash":"8ddfe37aebc7c0afe7305e3c6dceaab0238c7597","modified":1760257865903},{"_id":"public/tags/ops/index.html","hash":"104b178319df661282ca46ebdca559fa8023fd60","modified":1760257865903},{"_id":"public/tags/A406/index.html","hash":"40d7a074abb7fe69854859d62f3028f4187bc743","modified":1760257865903},{"_id":"public/tags/WIFI/index.html","hash":"cf47c8a6b86bf195f6f8aa756996cccab6d7ed43","modified":1760257865903},{"_id":"public/tags/branch/index.html","hash":"3f954eab0ecb9136010d88ff89565abc9c5a5aaf","modified":1760257865903},{"_id":"public/tags/base/index.html","hash":"14828a1ed8aaf5641ffa653ad5d8509bbbbd2e56","modified":1760257865903},{"_id":"public/tags/blog/index.html","hash":"8feded43b0af6963102c37b1cb7ddfd86f6ad3ca","modified":1760257865903},{"_id":"public/tags/hexo/index.html","hash":"163313a8108c69becaf3a3a95977cc16dbab02be","modified":1760257865903},{"_id":"public/tags/JAP/index.html","hash":"aa7cb013d46d8032253f09311545ed5c6dc7f859","modified":1760174410400},{"_id":"public/tags/MOSFET/index.html","hash":"b683cdd86a35dff92cc13b75ce3d0ceaf666d224","modified":1760174410400},{"_id":"public/tags/NAS/index.html","hash":"6fa93bf2ac33137311f52af5cc7db7dfe2604db1","modified":1760257865903},{"_id":"public/tags/Pycharm/index.html","hash":"2d2fdb899179a936d658583540e7689028ca8687","modified":1760257865903},{"_id":"public/tags/Pytorch/index.html","hash":"59f051d7c8ef0e8f231fe6b1525369fce3d72485","modified":1760257865903},{"_id":"public/tags/Spark/index.html","hash":"31b6c1abaa2689e724957245c9504899c1c51655","modified":1760174410400},{"_id":"public/tags/Hadoop/index.html","hash":"e06f5938b6c88c3b3790be11c5961f5e3463ee5a","modified":1760174410400},{"_id":"public/tags/Scala/index.html","hash":"5aff70c79a6cdd18b88681c3b913712f4289177f","modified":1760174410400},{"_id":"public/tags/WSL/index.html","hash":"e6c22c941cea1b017a668fc1670f9da94ab0d38e","modified":1760174410400},{"_id":"public/tags/Hive/index.html","hash":"ceb843ff944b586d84c25e94cc1509faab6877d6","modified":1760174410400},{"_id":"public/tags/GNU/index.html","hash":"0dff583589c91902021c87467bc66692e95b660f","modified":1760174410400},{"_id":"public/tags/C-C/index.html","hash":"b7a5c7dfee9bc704c96f36f2cfb229ed5846bdaf","modified":1760174410400},{"_id":"public/tags/Linux/index.html","hash":"f278cca54e749330f3e04c27fbb60be91604e0b9","modified":1760174410400},{"_id":"public/tags/Operational-Amplifier/index.html","hash":"d33cdaad282f47901fcb2a8071abc402b394eff7","modified":1760174410400},{"_id":"public/images/favicon.ico","hash":"da1f8b579bd0650ba462c8b5ef0b6c04f95153a5","modified":1760174410400},{"_id":"public/js/common.js","hash":"43814cd8cfb66783dbb0ec2164f03c8d17d63ff2","modified":1760174410400},{"_id":"public/js/img_zoom.js","hash":"a384c3a60fcbdad813cb8340200dfb07ebbcc48c","modified":1760174410400},{"_id":"public/js/post.js","hash":"32470c879db40741f39a3ed1c24a1a83eb40f819","modified":1760174410400},{"_id":"public/js/jquery-fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1760174410400},{"_id":"public/style/base.css","hash":"7f034ed5713ad2e95b1f2f62e1873a33bf56d2d4","modified":1760174410400},{"_id":"public/style/about.css","hash":"54acbee918d1f3fb104e91ca074d397ccd38f5ed","modified":1760174410400},{"_id":"public/style/archive.css","hash":"fc79cddde5b0ee019889337bb3098d73bb6824cb","modified":1760174410400},{"_id":"public/js/jquery-3.6.1.min.js","hash":"0fa72756e48c33a6feeace1ffa5d790d58b53729","modified":1760174410400},{"_id":"public/style/post.css","hash":"9e42bd627735bf438d97c1709f76b853f2989a25","modified":1760174410400},{"_id":"public/style/widget-header.css","hash":"80113d3a162a87b0574b478700242e8bb8cc9cf0","modified":1760174410400},{"_id":"public/style/widget-post-list.css","hash":"f2b934eb3827d33353661f6480e2c320c0527bd4","modified":1760174410400},{"_id":"public/style/common/helper.css","hash":"0b7612eebf65156aceec2f91b229ddeb38092456","modified":1760174410400},{"_id":"public/style/common/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1760174410400},{"_id":"public/style/common/variable.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1760174410400},{"_id":"public/style/themes/default-dark.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1760174410400},{"_id":"public/style/themes/default-light.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1760174410400},{"_id":"public/style/common/bulma.css","hash":"7ede761951c6f274850a1038416559a8f648c493","modified":1760174410400},{"_id":"public/style/themes/highlight-theme-light.css","hash":"f7b19080f00e10723bc86e6819fc25143a0137c5","modified":1760174410400},{"_id":"public/style/themes/theme.css","hash":"a334f9eaa157eda2bce485b22237a5d24cdf7d70","modified":1760174410400},{"_id":"public/js/highlight.pack.js","hash":"c5ec20ff9af8a1918d70aaab31d3eac7ac0b4687","modified":1760174410400},{"_id":"source/_posts/Linux Bash Shell 脚本入门 2.md","hash":"fac4b4d09317ad5e203fc96ee10cc6bafcf533c5","modified":1760172404864},{"_id":"source/_posts/Linux Bash Shell 脚本入门 3.md","hash":"ccb2435988febfe7dca53412ccb5b204eb092274","modified":1760172404864},{"_id":"source/_posts/Linux Bash Shell 脚本入门.md","hash":"3fc75d708209ea575b7759135a435d7576cb3e2a","modified":1760172404864},{"_id":"public/2025/10/11/Linux Bash Shell 脚本入门 2/index.html","hash":"e3cfcb8b8c7c83b43ca7dd9a7ff59fb8ace36c06","modified":1760175200722},{"_id":"public/2025/10/11/Linux Bash Shell 脚本入门/index.html","hash":"6609799d6c662b9861ccd4f06fe8025d1dcf751b","modified":1760175200722},{"_id":"public/2025/10/11/Linux Bash Shell 脚本入门 3/index.html","hash":"dda2c654af48d50c9e5dc2905c617ead8edb8dfc","modified":1760175200722},{"_id":"public/archives/2025/index.html","hash":"93f7d17aa1e0b7ddf4bfbc0f2aaacc79a0ac2a7d","modified":1760175200722},{"_id":"public/archives/2025/10/index.html","hash":"93f7d17aa1e0b7ddf4bfbc0f2aaacc79a0ac2a7d","modified":1760175200722},{"_id":"source/_posts/.DS_Store","hash":"ffe8d7d8b2278722fa967177a5c1f2a0ec17b58c","modified":1760176535824},{"_id":"source/.DS_Store","hash":"359d192b72d8be74d2458fe88cca7776117f76ed","modified":1760176535823},{"_id":"source/_posts/Bionet-Server01 Q&A——Docker篇.md","hash":"b3b6be2d636aba9251b2341209c083896eb2f3a8","modified":1760174925073},{"_id":"public/2024/09/21/Bionet-Server01 Q&A——Docker篇/index.html","hash":"d2607889539b4e12f9cb278ae088eef5cd5cb1d7","modified":1760257865903},{"_id":"public/tags/Q-A/index.html","hash":"2d9385b3b477f9e6ef06f51129974c46bb918dcd","modified":1760257865903}],"Category":[{"name":"Android","_id":"cm3zcthzx0002yjin5g9u4ep9"},{"name":"Kotlin","parent":"cm3zcthzx0002yjin5g9u4ep9","_id":"cm3zcti01000iyjin73akckes"},{"name":"Activity","parent":"cm3zcthzx0002yjin5g9u4ep9","_id":"cm3zcti05001dyjin1lligea4"},{"name":"Bionet","_id":"cm3zcti06001pyjinbfxmdwfl"},{"name":"git","_id":"cm3zcti08002eyjind9fhekli"},{"name":"JAP","_id":"cm3zcti0a002wyjin7e4lbezj"},{"name":"MOSFET","_id":"cm3zcti0b0039yjinhdece8zk"},{"name":"Pycharm","_id":"cm3zcti0d003pyjincecf466e"},{"name":"Pytorch","_id":"cm3zcti0e0044yjin6fee4i3f"},{"name":"Spark","_id":"cm3zcti0f004cyjinhjoeaa7d"},{"name":"Scala","_id":"cm3zcti0g004ryjingbuye9n8"},{"name":"Hadoop","parent":"cm3zcti0f004cyjinhjoeaa7d","_id":"cm3zcti0j005syjin29zz803t"},{"name":"C/C++","_id":"cm3zcti0j005zyjinh5mohitl"},{"name":"Operational Amplifier","_id":"cm3zcti0j0062yjinhrx167ln"},{"name":"Scala","parent":"cm3zcti0j005syjin29zz803t","_id":"cm3zcti0l006vyjin88v81jkk"},{"name":"Hive","parent":"cm3zcti0l006vyjin88v81jkk","_id":"cm3zcti0n007syjin6r484xwu"}],"Data":[],"Page":[],"Post":[{"title":"BionetServer-No1使用说明-基础篇","date":"2024-09-21T12:46:25.000Z","_content":"\n# BionetServer-No1使用说明-基础篇\n\n\n\n<img src=\"https://s2.loli.net/2024/09/29/vNKRfOVDTng7wdL.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547378732\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.0\n\n基础篇更新记录：\n\n- V1.0 简化了文档的内容，拆分了文档分为入门和进阶使用。添加了Anaconda的使用介绍，方便入门。\n\n过往更新记录：\n\n- V1.9 简化了文档的内容，拆分了文档分为入门和进阶使用，删除了容器Matlab的内容。\n- V1.8 新增了R使用说明，划分了端口和详细的版本，简单撰写了使用注意事项。\n- V1.7 新增了UI使用说明，同时请注意显卡使用。\n- V1.6 新增了Tensorflow专用的镜像，使用Tensorflow的可以使用新的镜像，运行速度提升两倍。\n- V1.5版本更新，修复Pytorch shm报错的问题，添加了新的镜像，新的镜像自带pytorch等常用python包，添加了Shared memory size的设置\n- V1.4版本更新，修复了桌面版的MATLAB的快捷方式，新增了防止桌面版使用休眠的设置指导，有长时间用桌面版跑代码的同学可以看看，容器不受影响。\n- V1.3更新了Matlab使用说明\n- V1.2更新了免密码登录，添加了用户修改密码的环节\n- V1.1更新代码补全、修正了conda的问题\n\n\nDate: 2024.06.07\n\nAuthors：NeoNeuxs\n\n<!-- toc -->\n\n[TOC]\n\n# 系统信息篇\n\n## 系统硬盘分区\n\n目前系统是由这样的硬盘空间组成的,分为高速、中速、低速区：\n\n顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：\n\n`Data_NAS(Datasets) > Samsung 860evo 512G  > GLOWAY YCQ4TNVMe-M.2` \n\n其中每一条格式如下：[分区名、挂载路径、分区大小]\n\n```mermaid\ngraph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --> nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --> nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --> nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --> nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --> nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --> nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --> MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --> sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --> sda2[\"sda2,[/boot],1GB\"]\n  sda --> empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --> LowSpeed\n  subgraph LowSpeed\n  NAS --> NFS1(NFS,/home/Data_NAS,16T)\n  NAS --> NFS2(NFS,/home/Datasets,16T)\n  end\n```\n\n## 公用文件夹指南\n\n`/home`文件夹：\n\n<img src=\"https://s2.loli.net/2024/04/01/fm4gUGQCToIbkv8.png\" alt=\"image-20240401202923240\" style=\"zoom:80%;\" />\n\n这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件\n\n![image-20240513230049068](https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png)\n\n一共包含六个文件夹：\n\n- Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：`上传者_数据集名称_上传日期`。\n  - 此文件夹使用详见：[NAS服务器使用说明](http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/)\n\n- Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。\n- PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】\n- NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改）\n- Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。\n- SoftWares文件夹比较特殊：\n\n![image-20240401205431946](https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png)\n\n​\t里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候在部分情况下只可读，无法写入，需要通过桌面用户来写入文件（出于安全和权限管理的考虑，如果报错可以单独找我了解）。\n\nP代指python容器，R代指R语言容器的存储空间。二者都被容器挂载。\n\n## 网络端口信息\n\n**端口的使用主要集中在容器。可以通过portainer来查看，portainer如何使用详见docker篇。**\n\n## 软件安装信息\n\nAnaconda：/home/anaconda\n\nMatlab：/home/SoftWares/Matlab\n\nDcoker：/默认路径\n\nJetbrains IDEs：/home/SoftWares/Jetbrain\n\n## 基于UI的方式远程连接服务器\n\n首先我们要确认是否连接到了校园网，在系统命令行上使用命令：\n\n```bash\nping 10.26.58.61\n```\n\n结果如下则证明你在校园网内。\n\n<img src=\"https://s2.loli.net/2024/05/13/Yts7QOiU1ymlfrS.png\" alt=\"image-20240513224911484\" style=\"zoom:67%;\" />\n\n打开windos远程连接，在状态栏中搜索远程连接，对于Windows系统，家庭版往往没有此功能，需要升级至专业版，具体升级方法可以去某宝买一个激活码，价格在10元左右。询问店家如何激活升级。\n\n<img src=\"https://s2.loli.net/2024/05/13/yiS3oGNWZaUFMbz.png\" alt=\"image-20240513224939223\" style=\"zoom:80%;\" />\n\n打开远程桌面输入远程地址，打开选项：\n\n<img src=\"https://s2.loli.net/2024/05/13/igJMIEtfhBOQC4Y.png\" alt=\"image-20240513225154369\" style=\"zoom:67%;\" />\n\n打开选项之后，输入链接地址：10.26.58.61\n\n然后点击显示选项，参照我这里修改：\n\n<img src=\"https://s2.loli.net/2024/05/13/sFaqp1WPLRJNeOx.png\" alt=\"image-20240513225353292\" style=\"zoom:67%;\" />\n\n然后点击编辑，修改成你的用户名和密码，连接即可。\n\n<img src=\"https://s2.loli.net/2024/05/13/NhkFSiZEv8rxVgX.png\" alt=\"image-20240513225650039\" style=\"zoom:67%;\" />\n\n输入你的用户名和密码：\n\n<img src=\"https://s2.loli.net/2024/05/13/AwEjJ9RDTV1qifg.png\" alt=\"image-20240513225551955\" style=\"zoom:67%;\" />\n\n连接后进入桌面，即可开始使用，如遇到剪贴板不能互相传输、小文件不能传输，请关闭连接重开即可，文件传输依赖于NAS可以参考一下NAS篇介绍。\n\n# 用户篇\n\n## 选择自己喜欢的桌面服务\n\n服务器升级之后存在两个桌面服务二者依托于XRDP实现\n\n### GNOME\n\nGNOME是Ubuntu原生的桌面，其优点是：\n\n界面简洁优雅，是默认的桌面。\n\n<img src=\"https://s2.loli.net/2024/03/24/irtsMxvByUK31lm.png\" alt=\"image-20240324173036063\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/03/24/w4lICZTjE6FmzcR.png\" alt=\"image-20240324173049733\" style=\"zoom:80%;\" />\n\n可个性化定制的比较多，简单来说就是好看~\n\n### Xfce桌面\n\n<img src=\"https://s2.loli.net/2024/03/24/DGACKf3BFswoix1.png\" alt=\"image-20240324173242318\" style=\"zoom:80%;\" />\n\n相对轻量化一点，性能消耗少一点，二者差不多，关键点还是个人喜好问题。\n\n二者如何切换？\n\n在命令行中执行如下命令：\n\n```bash\necho xfce4-session >~/.xsession\n```\n\n此时Xdrp默认启动的桌面就改成 Xcfe4 如果你喜欢你的GNOME桌面可以再切换回去：\n\n使用命令：\n\n```bash\nrm ~/.xsession\n```\n\n**退出登录之后，注意要退出登录**不是关闭远程连接，重新登陆即可登录到新的桌面。不懂如何退出请看下一小节。\n\n同时开多个个cpu消耗也比较少：\n\n<img src=\"https://s2.loli.net/2024/03/24/KIGeZmDfNarEt9U.png\" alt=\"image-20240324173454858\" style=\"zoom:67%;\" />\n\n## 如何正确退出远程连接？\n\n开启远程链接之后如果按照以下操作，会话将会保持运行，占用资源，正确退出方法如下：\n\n<img src=\"https://s2.loli.net/2024/03/25/mPSAMvcUsreYgQ7.png\" alt=\"image-20240325115418950\" style=\"zoom: 80%;\" />\n\n## 如何关闭锁屏功能\n\n在这里找到设置：\n\n<img src=\"https://s2.loli.net/2024/04/20/Vv6n4ItDzgpUXsr.png\" alt=\"image-20240420190046154\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/20/LP43Aq8mX1I2ecb.png\" alt=\"image-20240420190108244\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/20/uIiRbpaY6Z2OBhx.png\" alt=\"image-20240420190123305\" style=\"zoom:67%;\" />\n\n关闭即可。\n\n\n\n## 如何配置中文输入法\n\n打开fctix 5：\n\n![image-20240326205930890](https://s2.loli.net/2024/03/26/HzeqfrZxGpQOcmj.png)\n\n这里会提示运行fctix 5：\n\n![image-20240326210030357](https://s2.loli.net/2024/03/26/Eeza317wogSMcli.png)\n\n在这里找到拼音：\n\n<img src=\"https://s2.loli.net/2024/03/26/PX9Gdk5ElF8VI4C.png\" alt=\"image-20240326210056577\" style=\"zoom: 80%;\" />\n\n点击添加并应用：\n\n<img src=\"https://s2.loli.net/2024/03/26/8vgad9fEVwjA5yW.png\" alt=\"image-20240326210139494\" style=\"zoom:80%;\" />\n\n找到语言设置：\n\n![image-20240326210306567](https://s2.loli.net/2024/03/26/cDq7MzyRkbVBadi.png)\n\n更改设置如下，并登出，重新启动之后\n\n![image-20240326210336015](https://s2.loli.net/2024/03/26/bCHiPtZSow3vcmu.png)\n\n<img src=\"https://s2.loli.net/2024/03/26/tIrZ4owaCkPXvQc.png\" alt=\"image-20240326210413055\" style=\"zoom:80%;\" />\n\n可以愉快使用：\n\n**注意输入法切换要使用ctrl+空格键**\n\n![image-20240326210456544](https://s2.loli.net/2024/03/26/nIgFTsCrmcxbMzt.png)\n\n## 基本的开发工具\n\n使用UI开发的基本工具都在：\n\n<img src=\"https://s2.loli.net/2024/05/13/bRqM8GFJT9Hjs3C.png\" alt=\"image-20240513230203466\" style=\"zoom:67%;\" />\n\nPyCharm使用的介绍这里不赘述，网上有很多，需要提醒的是选择Python Inter（python解释器）的时候\n\n## Anaconda使用说明\n\n**禁止事项：严禁在用户个人目录下私自安装Anaconda**\n\n### Anaconda，conda，pip\n\n#### Anaconda\n\nThe world’s most trusted open ecosystem for sourcing, building, and deploying data science and AI initiatives\n\n和过去大家理解的Python和R语言的发行版，旨在简化包管理和部署的软件，不太相同了，全面拥抱AI，不仅仅是一个Python的发行版本了，提供了AI从数据到部署全部解决方案，不这里不会涉及到太多这些，毕竟这些方式在近些年还并不是最主流的，我们还有docker来部署，但是其作为Python的管理工具还是十分强大的。\n\n#### conda\n\nconda是Anaconda的核心组件，是其包管理器，Conda和pip都是Python的包管理工具，但是conda不仅仅能管理Python也能管理R语言，但是R语言自带了包管理器，Python也自带了包管理器，也就是Pip，那么为什么还需要conda呢?\n\nConda对比语言自己带的管理器有以下优势：\n\n- Conda支持创建、保存、加载和更新隔离的环境，每个环境可以有不同的包和版本，非常适合多项目开发，换句话话说，conda可以创建虚拟环境，可以切换Python版本。\n- Conda支持pip安装的包的管理，pip往往和对应的python版本相绑定，而conda可以管理Python（不仅仅是Python的包，而是某个版本的Python），也就是说conda也能管理Pip及其安装的包，当你使用pip安装对应的包的时候conda也是能察觉到，并更新对应的信息，一同管理。\n- Conda有更强的包依赖处理能力，自动删除冲突的包版本并升级，且不会破坏已经存在的包环境，pip直到23.10版本才有此功能，在以前升级包会直接删除包，破环原来的以来环境。\n\n## 服务器端的Anaconda如何使用？\n\nAnaconda提供了UI版本和命令行版本，命令行版本较长使用，UI版本对于不熟悉命令行的用户来说非常好用，在服务器上，打开路径如下：\n\n<img src=\"https://s2.loli.net/2024/05/13/vtx3a7MOKqSThCI.png\" alt=\"image-20240513230253640\" style=\"zoom:67%;\" />\n\nUI的简单介绍：\n\n![image-20240607214758652](https://s2.loli.net/2024/06/07/wnUkSLc8Gf2JDO7.png)\n\n下图按钮来打开对应的环境的命令行：\n\n<img src=\"https://s2.loli.net/2024/06/07/Mz7qGjvorfnBcNX.png\" alt=\"image-20240607215445757\" style=\"zoom:80%;\" />\n\n可以看到我们打开了对应的base环境的命令行，同时使用命令安装了numpy：\n\n<img src=\"https://s2.loli.net/2024/06/07/6IgulrWp2JxM3mP.png\" alt=\"image-20240607215534456\" style=\"zoom:67%;\" />\n\n但是安装失败了：\n\n<img src=\"https://s2.loli.net/2024/06/07/lqnh3zaIOZVmKPA.png\" alt=\"image-20240607215626411\" style=\"zoom:67%;\" />\n\n安装失败的原因很简单，base环境是每个用户都可以看到的，也就是说base环境是公用的，如果放开权限，base环境就会被不同的人使用，这样就有可能造成环境冲突，为了避免这个问题，我们首先要创建自己的环境：\n\n![image-20240607221044637](https://s2.loli.net/2024/06/07/T8hWORk4oVuUCZi.png)\n\n<img src=\"https://s2.loli.net/2024/06/07/z9cNV35Bkmbgxit.png\" alt=\"image-20240607221425884\" style=\"zoom:80%;\" />\n\n打开命令行，安装numpy，注意这里使用的是pip来安装，目的是为验证conda是否能检测到当前环境安装了numpy：\n\n<img src=\"https://s2.loli.net/2024/06/07/1FUbQVSlwzh9aiX.png\" alt=\"image-20240607221552326\" style=\"zoom:67%;\" />\n\n更新一下索引内容：\n\n<img src=\"https://s2.loli.net/2024/06/07/dPEouyVXQMnWgD2.png\" alt=\"image-20240607221707744\" style=\"zoom:80%;\" />\n\n可以看到对应的numpy被检测到了：\n\n![image-20240607221800965](https://s2.loli.net/2024/06/07/U27RlTkrAwsF6SQ.png)\n\n上文是Anaconda的图形化界面，当然你也可以使用shell当中的：\n\n在命令行中使用命令：\n\n```bash\n conda activate base\n```\n\n![image-20240513230400329](https://s2.loli.net/2024/05/13/INaD3GAgvVC8TPy.png)\n\n注意base环境不可以使用，请自己建立环境：\n\n```bash\nconda create -n env_name python=3.10\n```\n\n其中env_name为你想创建的环境的名字，python后边为创建的版本。\n\n下载地址：\n\nhttps://www.anaconda.com/download\n\n## Matlab使用说明\n\n**禁止事项：严禁在用户个人目录下私自安装Matlab**\n\nmatlab在路径：\n\n```bash\n/home/SoftWares/MATLAB/bin\n```\n\n再次目录下右键打开命令行，运行matlab即可\n\n```\n./matlab\n```\n\n或者快捷方式在：\n\n<img src=\"https://s2.loli.net/2024/06/07/TKCeJRObo98VyXQ.png\" alt=\"image-20240607222500101\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/06/07/vlaz2VtP8ZRCWsw.png\" alt=\"image-20240607222559328\" style=\"zoom:67%;\" />\n\n**此命令行为matlab运行所使用，不要关闭。**开启后登陆个人matlab账号即可使用，安装的matlab皆为正版，需要根据学校引导来注册正版账号，引导内容在：https://zhengban.xmu.edu.cn/matlab.html，查看个人用户部分介绍，遵循指南。\n\n#### 报错处理\n\n![image-20240902193011563](https://s2.loli.net/2024/09/02/a2XJilmTOsoyQdU.png)\n\n根据matlab官方指南，kill掉对应的进程即可，使用命令：\n\n```\nps -fU 用户名 | grep MathWorksServiceHost\n```\n\n![image-20240902193935209](https://s2.loli.net/2024/09/02/7Wz195ZHTEn3hwD.png)\n\n使用`kill -9  1220267`对应的进程号码即可。\n\n\n\n## R语言使用指南\n\n为了方便R语言版本的切换，R语言通过Docker部署，详见Docker篇。\n","source":"_posts/Bionet-Server01使用说明.md","raw":"---\ntitle: BionetServer-No1使用说明-基础篇\ncategories:\n  - Bionet\ntags:\n  - Bionet\n  - ops\ndate: \"2024/09/21 20:46:25\"\n---\n\n# BionetServer-No1使用说明-基础篇\n\n\n\n<img src=\"https://s2.loli.net/2024/09/29/vNKRfOVDTng7wdL.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547378732\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.0\n\n基础篇更新记录：\n\n- V1.0 简化了文档的内容，拆分了文档分为入门和进阶使用。添加了Anaconda的使用介绍，方便入门。\n\n过往更新记录：\n\n- V1.9 简化了文档的内容，拆分了文档分为入门和进阶使用，删除了容器Matlab的内容。\n- V1.8 新增了R使用说明，划分了端口和详细的版本，简单撰写了使用注意事项。\n- V1.7 新增了UI使用说明，同时请注意显卡使用。\n- V1.6 新增了Tensorflow专用的镜像，使用Tensorflow的可以使用新的镜像，运行速度提升两倍。\n- V1.5版本更新，修复Pytorch shm报错的问题，添加了新的镜像，新的镜像自带pytorch等常用python包，添加了Shared memory size的设置\n- V1.4版本更新，修复了桌面版的MATLAB的快捷方式，新增了防止桌面版使用休眠的设置指导，有长时间用桌面版跑代码的同学可以看看，容器不受影响。\n- V1.3更新了Matlab使用说明\n- V1.2更新了免密码登录，添加了用户修改密码的环节\n- V1.1更新代码补全、修正了conda的问题\n\n\nDate: 2024.06.07\n\nAuthors：NeoNeuxs\n\n<!-- toc -->\n\n[TOC]\n\n# 系统信息篇\n\n## 系统硬盘分区\n\n目前系统是由这样的硬盘空间组成的,分为高速、中速、低速区：\n\n顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：\n\n`Data_NAS(Datasets) > Samsung 860evo 512G  > GLOWAY YCQ4TNVMe-M.2` \n\n其中每一条格式如下：[分区名、挂载路径、分区大小]\n\n```mermaid\ngraph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --> nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --> nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --> nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --> nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --> nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --> nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --> MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --> sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --> sda2[\"sda2,[/boot],1GB\"]\n  sda --> empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --> LowSpeed\n  subgraph LowSpeed\n  NAS --> NFS1(NFS,/home/Data_NAS,16T)\n  NAS --> NFS2(NFS,/home/Datasets,16T)\n  end\n```\n\n## 公用文件夹指南\n\n`/home`文件夹：\n\n<img src=\"https://s2.loli.net/2024/04/01/fm4gUGQCToIbkv8.png\" alt=\"image-20240401202923240\" style=\"zoom:80%;\" />\n\n这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件\n\n![image-20240513230049068](https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png)\n\n一共包含六个文件夹：\n\n- Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：`上传者_数据集名称_上传日期`。\n  - 此文件夹使用详见：[NAS服务器使用说明](http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/)\n\n- Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。\n- PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】\n- NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改）\n- Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。\n- SoftWares文件夹比较特殊：\n\n![image-20240401205431946](https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png)\n\n​\t里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候在部分情况下只可读，无法写入，需要通过桌面用户来写入文件（出于安全和权限管理的考虑，如果报错可以单独找我了解）。\n\nP代指python容器，R代指R语言容器的存储空间。二者都被容器挂载。\n\n## 网络端口信息\n\n**端口的使用主要集中在容器。可以通过portainer来查看，portainer如何使用详见docker篇。**\n\n## 软件安装信息\n\nAnaconda：/home/anaconda\n\nMatlab：/home/SoftWares/Matlab\n\nDcoker：/默认路径\n\nJetbrains IDEs：/home/SoftWares/Jetbrain\n\n## 基于UI的方式远程连接服务器\n\n首先我们要确认是否连接到了校园网，在系统命令行上使用命令：\n\n```bash\nping 10.26.58.61\n```\n\n结果如下则证明你在校园网内。\n\n<img src=\"https://s2.loli.net/2024/05/13/Yts7QOiU1ymlfrS.png\" alt=\"image-20240513224911484\" style=\"zoom:67%;\" />\n\n打开windos远程连接，在状态栏中搜索远程连接，对于Windows系统，家庭版往往没有此功能，需要升级至专业版，具体升级方法可以去某宝买一个激活码，价格在10元左右。询问店家如何激活升级。\n\n<img src=\"https://s2.loli.net/2024/05/13/yiS3oGNWZaUFMbz.png\" alt=\"image-20240513224939223\" style=\"zoom:80%;\" />\n\n打开远程桌面输入远程地址，打开选项：\n\n<img src=\"https://s2.loli.net/2024/05/13/igJMIEtfhBOQC4Y.png\" alt=\"image-20240513225154369\" style=\"zoom:67%;\" />\n\n打开选项之后，输入链接地址：10.26.58.61\n\n然后点击显示选项，参照我这里修改：\n\n<img src=\"https://s2.loli.net/2024/05/13/sFaqp1WPLRJNeOx.png\" alt=\"image-20240513225353292\" style=\"zoom:67%;\" />\n\n然后点击编辑，修改成你的用户名和密码，连接即可。\n\n<img src=\"https://s2.loli.net/2024/05/13/NhkFSiZEv8rxVgX.png\" alt=\"image-20240513225650039\" style=\"zoom:67%;\" />\n\n输入你的用户名和密码：\n\n<img src=\"https://s2.loli.net/2024/05/13/AwEjJ9RDTV1qifg.png\" alt=\"image-20240513225551955\" style=\"zoom:67%;\" />\n\n连接后进入桌面，即可开始使用，如遇到剪贴板不能互相传输、小文件不能传输，请关闭连接重开即可，文件传输依赖于NAS可以参考一下NAS篇介绍。\n\n# 用户篇\n\n## 选择自己喜欢的桌面服务\n\n服务器升级之后存在两个桌面服务二者依托于XRDP实现\n\n### GNOME\n\nGNOME是Ubuntu原生的桌面，其优点是：\n\n界面简洁优雅，是默认的桌面。\n\n<img src=\"https://s2.loli.net/2024/03/24/irtsMxvByUK31lm.png\" alt=\"image-20240324173036063\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/03/24/w4lICZTjE6FmzcR.png\" alt=\"image-20240324173049733\" style=\"zoom:80%;\" />\n\n可个性化定制的比较多，简单来说就是好看~\n\n### Xfce桌面\n\n<img src=\"https://s2.loli.net/2024/03/24/DGACKf3BFswoix1.png\" alt=\"image-20240324173242318\" style=\"zoom:80%;\" />\n\n相对轻量化一点，性能消耗少一点，二者差不多，关键点还是个人喜好问题。\n\n二者如何切换？\n\n在命令行中执行如下命令：\n\n```bash\necho xfce4-session >~/.xsession\n```\n\n此时Xdrp默认启动的桌面就改成 Xcfe4 如果你喜欢你的GNOME桌面可以再切换回去：\n\n使用命令：\n\n```bash\nrm ~/.xsession\n```\n\n**退出登录之后，注意要退出登录**不是关闭远程连接，重新登陆即可登录到新的桌面。不懂如何退出请看下一小节。\n\n同时开多个个cpu消耗也比较少：\n\n<img src=\"https://s2.loli.net/2024/03/24/KIGeZmDfNarEt9U.png\" alt=\"image-20240324173454858\" style=\"zoom:67%;\" />\n\n## 如何正确退出远程连接？\n\n开启远程链接之后如果按照以下操作，会话将会保持运行，占用资源，正确退出方法如下：\n\n<img src=\"https://s2.loli.net/2024/03/25/mPSAMvcUsreYgQ7.png\" alt=\"image-20240325115418950\" style=\"zoom: 80%;\" />\n\n## 如何关闭锁屏功能\n\n在这里找到设置：\n\n<img src=\"https://s2.loli.net/2024/04/20/Vv6n4ItDzgpUXsr.png\" alt=\"image-20240420190046154\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/20/LP43Aq8mX1I2ecb.png\" alt=\"image-20240420190108244\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/20/uIiRbpaY6Z2OBhx.png\" alt=\"image-20240420190123305\" style=\"zoom:67%;\" />\n\n关闭即可。\n\n\n\n## 如何配置中文输入法\n\n打开fctix 5：\n\n![image-20240326205930890](https://s2.loli.net/2024/03/26/HzeqfrZxGpQOcmj.png)\n\n这里会提示运行fctix 5：\n\n![image-20240326210030357](https://s2.loli.net/2024/03/26/Eeza317wogSMcli.png)\n\n在这里找到拼音：\n\n<img src=\"https://s2.loli.net/2024/03/26/PX9Gdk5ElF8VI4C.png\" alt=\"image-20240326210056577\" style=\"zoom: 80%;\" />\n\n点击添加并应用：\n\n<img src=\"https://s2.loli.net/2024/03/26/8vgad9fEVwjA5yW.png\" alt=\"image-20240326210139494\" style=\"zoom:80%;\" />\n\n找到语言设置：\n\n![image-20240326210306567](https://s2.loli.net/2024/03/26/cDq7MzyRkbVBadi.png)\n\n更改设置如下，并登出，重新启动之后\n\n![image-20240326210336015](https://s2.loli.net/2024/03/26/bCHiPtZSow3vcmu.png)\n\n<img src=\"https://s2.loli.net/2024/03/26/tIrZ4owaCkPXvQc.png\" alt=\"image-20240326210413055\" style=\"zoom:80%;\" />\n\n可以愉快使用：\n\n**注意输入法切换要使用ctrl+空格键**\n\n![image-20240326210456544](https://s2.loli.net/2024/03/26/nIgFTsCrmcxbMzt.png)\n\n## 基本的开发工具\n\n使用UI开发的基本工具都在：\n\n<img src=\"https://s2.loli.net/2024/05/13/bRqM8GFJT9Hjs3C.png\" alt=\"image-20240513230203466\" style=\"zoom:67%;\" />\n\nPyCharm使用的介绍这里不赘述，网上有很多，需要提醒的是选择Python Inter（python解释器）的时候\n\n## Anaconda使用说明\n\n**禁止事项：严禁在用户个人目录下私自安装Anaconda**\n\n### Anaconda，conda，pip\n\n#### Anaconda\n\nThe world’s most trusted open ecosystem for sourcing, building, and deploying data science and AI initiatives\n\n和过去大家理解的Python和R语言的发行版，旨在简化包管理和部署的软件，不太相同了，全面拥抱AI，不仅仅是一个Python的发行版本了，提供了AI从数据到部署全部解决方案，不这里不会涉及到太多这些，毕竟这些方式在近些年还并不是最主流的，我们还有docker来部署，但是其作为Python的管理工具还是十分强大的。\n\n#### conda\n\nconda是Anaconda的核心组件，是其包管理器，Conda和pip都是Python的包管理工具，但是conda不仅仅能管理Python也能管理R语言，但是R语言自带了包管理器，Python也自带了包管理器，也就是Pip，那么为什么还需要conda呢?\n\nConda对比语言自己带的管理器有以下优势：\n\n- Conda支持创建、保存、加载和更新隔离的环境，每个环境可以有不同的包和版本，非常适合多项目开发，换句话话说，conda可以创建虚拟环境，可以切换Python版本。\n- Conda支持pip安装的包的管理，pip往往和对应的python版本相绑定，而conda可以管理Python（不仅仅是Python的包，而是某个版本的Python），也就是说conda也能管理Pip及其安装的包，当你使用pip安装对应的包的时候conda也是能察觉到，并更新对应的信息，一同管理。\n- Conda有更强的包依赖处理能力，自动删除冲突的包版本并升级，且不会破坏已经存在的包环境，pip直到23.10版本才有此功能，在以前升级包会直接删除包，破环原来的以来环境。\n\n## 服务器端的Anaconda如何使用？\n\nAnaconda提供了UI版本和命令行版本，命令行版本较长使用，UI版本对于不熟悉命令行的用户来说非常好用，在服务器上，打开路径如下：\n\n<img src=\"https://s2.loli.net/2024/05/13/vtx3a7MOKqSThCI.png\" alt=\"image-20240513230253640\" style=\"zoom:67%;\" />\n\nUI的简单介绍：\n\n![image-20240607214758652](https://s2.loli.net/2024/06/07/wnUkSLc8Gf2JDO7.png)\n\n下图按钮来打开对应的环境的命令行：\n\n<img src=\"https://s2.loli.net/2024/06/07/Mz7qGjvorfnBcNX.png\" alt=\"image-20240607215445757\" style=\"zoom:80%;\" />\n\n可以看到我们打开了对应的base环境的命令行，同时使用命令安装了numpy：\n\n<img src=\"https://s2.loli.net/2024/06/07/6IgulrWp2JxM3mP.png\" alt=\"image-20240607215534456\" style=\"zoom:67%;\" />\n\n但是安装失败了：\n\n<img src=\"https://s2.loli.net/2024/06/07/lqnh3zaIOZVmKPA.png\" alt=\"image-20240607215626411\" style=\"zoom:67%;\" />\n\n安装失败的原因很简单，base环境是每个用户都可以看到的，也就是说base环境是公用的，如果放开权限，base环境就会被不同的人使用，这样就有可能造成环境冲突，为了避免这个问题，我们首先要创建自己的环境：\n\n![image-20240607221044637](https://s2.loli.net/2024/06/07/T8hWORk4oVuUCZi.png)\n\n<img src=\"https://s2.loli.net/2024/06/07/z9cNV35Bkmbgxit.png\" alt=\"image-20240607221425884\" style=\"zoom:80%;\" />\n\n打开命令行，安装numpy，注意这里使用的是pip来安装，目的是为验证conda是否能检测到当前环境安装了numpy：\n\n<img src=\"https://s2.loli.net/2024/06/07/1FUbQVSlwzh9aiX.png\" alt=\"image-20240607221552326\" style=\"zoom:67%;\" />\n\n更新一下索引内容：\n\n<img src=\"https://s2.loli.net/2024/06/07/dPEouyVXQMnWgD2.png\" alt=\"image-20240607221707744\" style=\"zoom:80%;\" />\n\n可以看到对应的numpy被检测到了：\n\n![image-20240607221800965](https://s2.loli.net/2024/06/07/U27RlTkrAwsF6SQ.png)\n\n上文是Anaconda的图形化界面，当然你也可以使用shell当中的：\n\n在命令行中使用命令：\n\n```bash\n conda activate base\n```\n\n![image-20240513230400329](https://s2.loli.net/2024/05/13/INaD3GAgvVC8TPy.png)\n\n注意base环境不可以使用，请自己建立环境：\n\n```bash\nconda create -n env_name python=3.10\n```\n\n其中env_name为你想创建的环境的名字，python后边为创建的版本。\n\n下载地址：\n\nhttps://www.anaconda.com/download\n\n## Matlab使用说明\n\n**禁止事项：严禁在用户个人目录下私自安装Matlab**\n\nmatlab在路径：\n\n```bash\n/home/SoftWares/MATLAB/bin\n```\n\n再次目录下右键打开命令行，运行matlab即可\n\n```\n./matlab\n```\n\n或者快捷方式在：\n\n<img src=\"https://s2.loli.net/2024/06/07/TKCeJRObo98VyXQ.png\" alt=\"image-20240607222500101\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/06/07/vlaz2VtP8ZRCWsw.png\" alt=\"image-20240607222559328\" style=\"zoom:67%;\" />\n\n**此命令行为matlab运行所使用，不要关闭。**开启后登陆个人matlab账号即可使用，安装的matlab皆为正版，需要根据学校引导来注册正版账号，引导内容在：https://zhengban.xmu.edu.cn/matlab.html，查看个人用户部分介绍，遵循指南。\n\n#### 报错处理\n\n![image-20240902193011563](https://s2.loli.net/2024/09/02/a2XJilmTOsoyQdU.png)\n\n根据matlab官方指南，kill掉对应的进程即可，使用命令：\n\n```\nps -fU 用户名 | grep MathWorksServiceHost\n```\n\n![image-20240902193935209](https://s2.loli.net/2024/09/02/7Wz195ZHTEn3hwD.png)\n\n使用`kill -9  1220267`对应的进程号码即可。\n\n\n\n## R语言使用指南\n\n为了方便R语言版本的切换，R语言通过Docker部署，详见Docker篇。\n","slug":"Bionet-Server01使用说明","published":1,"updated":"2024-11-27T03:55:57.800Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti05001iyjin3iobg5m7","content":"<h1><span id=\"bionetserver-no1使用说明-基础篇\">BionetServer-No1使用说明-基础篇</span></h1>\n<img src=\"https://s2.loli.net/2024/09/29/vNKRfOVDTng7wdL.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547378732\" style=\"zoom:50%;\">\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\">\n<p>Version:1.0</p>\n<p>基础篇更新记录：</p>\n<ul>\n<li>V1.0 简化了文档的内容，拆分了文档分为入门和进阶使用。添加了Anaconda的使用介绍，方便入门。</li>\n</ul>\n<p>过往更新记录：</p>\n<ul>\n<li>V1.9 简化了文档的内容，拆分了文档分为入门和进阶使用，删除了容器Matlab的内容。</li>\n<li>V1.8 新增了R使用说明，划分了端口和详细的版本，简单撰写了使用注意事项。</li>\n<li>V1.7 新增了UI使用说明，同时请注意显卡使用。</li>\n<li>V1.6 新增了Tensorflow专用的镜像，使用Tensorflow的可以使用新的镜像，运行速度提升两倍。</li>\n<li>V1.5版本更新，修复Pytorch shm报错的问题，添加了新的镜像，新的镜像自带pytorch等常用python包，添加了Shared memory size的设置</li>\n<li>V1.4版本更新，修复了桌面版的MATLAB的快捷方式，新增了防止桌面版使用休眠的设置指导，有长时间用桌面版跑代码的同学可以看看，容器不受影响。</li>\n<li>V1.3更新了Matlab使用说明</li>\n<li>V1.2更新了免密码登录，添加了用户修改密码的环节</li>\n<li>V1.1更新代码补全、修正了conda的问题</li>\n</ul>\n<p>Date: 2024.06.07</p>\n<p>Authors：NeoNeuxs</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%AF%87\">系统信息篇</a>\n<ul>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA\">系统硬盘分区</a></li>\n<li><a href=\"#%E5%85%AC%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%87%E5%8D%97\">公用文件夹指南</a></li>\n<li><a href=\"#%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E4%BF%A1%E6%81%AF\">网络端口信息</a></li>\n<li><a href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BF%A1%E6%81%AF\">软件安装信息</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8Eui%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8\">基于UI的方式远程连接服务器</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%94%A8%E6%88%B7%E7%AF%87\">用户篇</a>\n<ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E6%A1%8C%E9%9D%A2%E6%9C%8D%E5%8A%A1\">选择自己喜欢的桌面服务</a>\n<ul>\n<li><a href=\"#gnome\">GNOME</a></li>\n<li><a href=\"#xfce%E6%A1%8C%E9%9D%A2\">Xfce桌面</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%80%80%E5%87%BA%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5\">如何正确退出远程连接？</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E9%94%81%E5%B1%8F%E5%8A%9F%E8%83%BD\">如何关闭锁屏功能</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95\">如何配置中文输入法</a></li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7\">基本的开发工具</a></li>\n<li><a href=\"#anaconda%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\">Anaconda使用说明</a>\n<ul>\n<li><a href=\"#anacondacondapip\">Anaconda，conda，pip</a>\n<ul>\n<li><a href=\"#anaconda\">Anaconda</a></li>\n<li><a href=\"#conda\">conda</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84anaconda%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\">服务器端的Anaconda如何使用？</a></li>\n<li><a href=\"#matlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\">Matlab使用说明</a>\n<ul>\n<li><a href=\"#%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86\">报错处理</a></li>\n</ul>\n</li>\n<li><a href=\"#r%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97\">R语言使用指南</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h1><span id=\"系统信息篇\">系统信息篇</span></h1>\n<h2><span id=\"系统硬盘分区\">系统硬盘分区</span></h2>\n<p>目前系统是由这样的硬盘空间组成的,分为高速、中速、低速区：</p>\n<p>顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：</p>\n<p><code>Data_NAS(Datasets) &gt; Samsung 860evo 512G  &gt; GLOWAY YCQ4TNVMe-M.2</code></p>\n<p>其中每一条格式如下：[分区名、挂载路径、分区大小]</p>\n<pre class=\"mermaid\">graph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --&gt; nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --&gt; nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --&gt; nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --&gt; nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --&gt; nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --&gt; nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --&gt; MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --&gt; sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --&gt; sda2[\"sda2,[/boot],1GB\"]\n  sda --&gt; empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --&gt; LowSpeed\n  subgraph LowSpeed\n  NAS --&gt; NFS1(NFS,/home/Data_NAS,16T)\n  NAS --&gt; NFS2(NFS,/home/Datasets,16T)\n  end</pre>\n<h2><span id=\"公用文件夹指南\">公用文件夹指南</span></h2>\n<p><code>/home</code>文件夹：</p>\n<img src=\"https://s2.loli.net/2024/04/01/fm4gUGQCToIbkv8.png\" alt=\"image-20240401202923240\" style=\"zoom:80%;\">\n<p>这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png\" alt=\"image-20240513230049068\"></p>\n<p>一共包含六个文件夹：</p>\n<ul>\n<li>\n<p>Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：<code>上传者_数据集名称_上传日期</code>。</p>\n<ul>\n<li>此文件夹使用详见：<a href=\"http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/\">NAS服务器使用说明</a></li>\n</ul>\n</li>\n<li>\n<p>Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。</p>\n</li>\n<li>\n<p>PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】</p>\n</li>\n<li>\n<p>NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改）</p>\n</li>\n<li>\n<p>Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。</p>\n</li>\n<li>\n<p>SoftWares文件夹比较特殊：</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png\" alt=\"image-20240401205431946\"></p>\n<p>​\t里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候在部分情况下只可读，无法写入，需要通过桌面用户来写入文件（出于安全和权限管理的考虑，如果报错可以单独找我了解）。</p>\n<p>P代指python容器，R代指R语言容器的存储空间。二者都被容器挂载。</p>\n<h2><span id=\"网络端口信息\">网络端口信息</span></h2>\n<p><strong>端口的使用主要集中在容器。可以通过portainer来查看，portainer如何使用详见docker篇。</strong></p>\n<h2><span id=\"软件安装信息\">软件安装信息</span></h2>\n<p>Anaconda：/home/anaconda</p>\n<p>Matlab：/home/SoftWares/Matlab</p>\n<p>Dcoker：/默认路径</p>\n<p>Jetbrains IDEs：/home/SoftWares/Jetbrain</p>\n<h2><span id=\"基于ui的方式远程连接服务器\">基于UI的方式远程连接服务器</span></h2>\n<p>首先我们要确认是否连接到了校园网，在系统命令行上使用命令：</p>\n<pre><code class=\"language-bash\">ping 10.26.58.61\n</code></pre>\n<p>结果如下则证明你在校园网内。</p>\n<img src=\"https://s2.loli.net/2024/05/13/Yts7QOiU1ymlfrS.png\" alt=\"image-20240513224911484\" style=\"zoom:67%;\">\n<p>打开windos远程连接，在状态栏中搜索远程连接，对于Windows系统，家庭版往往没有此功能，需要升级至专业版，具体升级方法可以去某宝买一个激活码，价格在10元左右。询问店家如何激活升级。</p>\n<img src=\"https://s2.loli.net/2024/05/13/yiS3oGNWZaUFMbz.png\" alt=\"image-20240513224939223\" style=\"zoom:80%;\">\n<p>打开远程桌面输入远程地址，打开选项：</p>\n<img src=\"https://s2.loli.net/2024/05/13/igJMIEtfhBOQC4Y.png\" alt=\"image-20240513225154369\" style=\"zoom:67%;\">\n<p>打开选项之后，输入链接地址：10.26.58.61</p>\n<p>然后点击显示选项，参照我这里修改：</p>\n<img src=\"https://s2.loli.net/2024/05/13/sFaqp1WPLRJNeOx.png\" alt=\"image-20240513225353292\" style=\"zoom:67%;\">\n<p>然后点击编辑，修改成你的用户名和密码，连接即可。</p>\n<img src=\"https://s2.loli.net/2024/05/13/NhkFSiZEv8rxVgX.png\" alt=\"image-20240513225650039\" style=\"zoom:67%;\">\n<p>输入你的用户名和密码：</p>\n<img src=\"https://s2.loli.net/2024/05/13/AwEjJ9RDTV1qifg.png\" alt=\"image-20240513225551955\" style=\"zoom:67%;\">\n<p>连接后进入桌面，即可开始使用，如遇到剪贴板不能互相传输、小文件不能传输，请关闭连接重开即可，文件传输依赖于NAS可以参考一下NAS篇介绍。</p>\n<h1><span id=\"用户篇\">用户篇</span></h1>\n<h2><span id=\"选择自己喜欢的桌面服务\">选择自己喜欢的桌面服务</span></h2>\n<p>服务器升级之后存在两个桌面服务二者依托于XRDP实现</p>\n<h3><span id=\"gnome\">GNOME</span></h3>\n<p>GNOME是Ubuntu原生的桌面，其优点是：</p>\n<p>界面简洁优雅，是默认的桌面。</p>\n<img src=\"https://s2.loli.net/2024/03/24/irtsMxvByUK31lm.png\" alt=\"image-20240324173036063\" style=\"zoom:80%;\">\n<img src=\"https://s2.loli.net/2024/03/24/w4lICZTjE6FmzcR.png\" alt=\"image-20240324173049733\" style=\"zoom:80%;\">\n<p>可个性化定制的比较多，简单来说就是好看~</p>\n<h3><span id=\"xfce桌面\">Xfce桌面</span></h3>\n<img src=\"https://s2.loli.net/2024/03/24/DGACKf3BFswoix1.png\" alt=\"image-20240324173242318\" style=\"zoom:80%;\">\n<p>相对轻量化一点，性能消耗少一点，二者差不多，关键点还是个人喜好问题。</p>\n<p>二者如何切换？</p>\n<p>在命令行中执行如下命令：</p>\n<pre><code class=\"language-bash\">echo xfce4-session &gt;~/.xsession\n</code></pre>\n<p>此时Xdrp默认启动的桌面就改成 Xcfe4 如果你喜欢你的GNOME桌面可以再切换回去：</p>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">rm ~/.xsession\n</code></pre>\n<p><strong>退出登录之后，注意要退出登录</strong>不是关闭远程连接，重新登陆即可登录到新的桌面。不懂如何退出请看下一小节。</p>\n<p>同时开多个个cpu消耗也比较少：</p>\n<img src=\"https://s2.loli.net/2024/03/24/KIGeZmDfNarEt9U.png\" alt=\"image-20240324173454858\" style=\"zoom:67%;\">\n<h2><span id=\"如何正确退出远程连接\">如何正确退出远程连接？</span></h2>\n<p>开启远程链接之后如果按照以下操作，会话将会保持运行，占用资源，正确退出方法如下：</p>\n<img src=\"https://s2.loli.net/2024/03/25/mPSAMvcUsreYgQ7.png\" alt=\"image-20240325115418950\" style=\"zoom: 80%;\">\n<h2><span id=\"如何关闭锁屏功能\">如何关闭锁屏功能</span></h2>\n<p>在这里找到设置：</p>\n<img src=\"https://s2.loli.net/2024/04/20/Vv6n4ItDzgpUXsr.png\" alt=\"image-20240420190046154\" style=\"zoom:80%;\">\n<img src=\"https://s2.loli.net/2024/04/20/LP43Aq8mX1I2ecb.png\" alt=\"image-20240420190108244\" style=\"zoom:67%;\">\n<img src=\"https://s2.loli.net/2024/04/20/uIiRbpaY6Z2OBhx.png\" alt=\"image-20240420190123305\" style=\"zoom:67%;\">\n<p>关闭即可。</p>\n<h2><span id=\"如何配置中文输入法\">如何配置中文输入法</span></h2>\n<p>打开fctix 5：</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/HzeqfrZxGpQOcmj.png\" alt=\"image-20240326205930890\"></p>\n<p>这里会提示运行fctix 5：</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/Eeza317wogSMcli.png\" alt=\"image-20240326210030357\"></p>\n<p>在这里找到拼音：</p>\n<img src=\"https://s2.loli.net/2024/03/26/PX9Gdk5ElF8VI4C.png\" alt=\"image-20240326210056577\" style=\"zoom: 80%;\">\n<p>点击添加并应用：</p>\n<img src=\"https://s2.loli.net/2024/03/26/8vgad9fEVwjA5yW.png\" alt=\"image-20240326210139494\" style=\"zoom:80%;\">\n<p>找到语言设置：</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/cDq7MzyRkbVBadi.png\" alt=\"image-20240326210306567\"></p>\n<p>更改设置如下，并登出，重新启动之后</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/bCHiPtZSow3vcmu.png\" alt=\"image-20240326210336015\"></p>\n<img src=\"https://s2.loli.net/2024/03/26/tIrZ4owaCkPXvQc.png\" alt=\"image-20240326210413055\" style=\"zoom:80%;\">\n<p>可以愉快使用：</p>\n<p><strong>注意输入法切换要使用ctrl+空格键</strong></p>\n<p><img src=\"https://s2.loli.net/2024/03/26/nIgFTsCrmcxbMzt.png\" alt=\"image-20240326210456544\"></p>\n<h2><span id=\"基本的开发工具\">基本的开发工具</span></h2>\n<p>使用UI开发的基本工具都在：</p>\n<img src=\"https://s2.loli.net/2024/05/13/bRqM8GFJT9Hjs3C.png\" alt=\"image-20240513230203466\" style=\"zoom:67%;\">\n<p>PyCharm使用的介绍这里不赘述，网上有很多，需要提醒的是选择Python Inter（python解释器）的时候</p>\n<h2><span id=\"anaconda使用说明\">Anaconda使用说明</span></h2>\n<p><strong>禁止事项：严禁在用户个人目录下私自安装Anaconda</strong></p>\n<h3><span id=\"anacondacondapip\">Anaconda，conda，pip</span></h3>\n<h4><span id=\"anaconda\">Anaconda</span></h4>\n<p>The world’s most trusted open ecosystem for sourcing, building, and deploying data science and AI initiatives</p>\n<p>和过去大家理解的Python和R语言的发行版，旨在简化包管理和部署的软件，不太相同了，全面拥抱AI，不仅仅是一个Python的发行版本了，提供了AI从数据到部署全部解决方案，不这里不会涉及到太多这些，毕竟这些方式在近些年还并不是最主流的，我们还有docker来部署，但是其作为Python的管理工具还是十分强大的。</p>\n<h4><span id=\"conda\">conda</span></h4>\n<p>conda是Anaconda的核心组件，是其包管理器，Conda和pip都是Python的包管理工具，但是conda不仅仅能管理Python也能管理R语言，但是R语言自带了包管理器，Python也自带了包管理器，也就是Pip，那么为什么还需要conda呢?</p>\n<p>Conda对比语言自己带的管理器有以下优势：</p>\n<ul>\n<li>Conda支持创建、保存、加载和更新隔离的环境，每个环境可以有不同的包和版本，非常适合多项目开发，换句话话说，conda可以创建虚拟环境，可以切换Python版本。</li>\n<li>Conda支持pip安装的包的管理，pip往往和对应的python版本相绑定，而conda可以管理Python（不仅仅是Python的包，而是某个版本的Python），也就是说conda也能管理Pip及其安装的包，当你使用pip安装对应的包的时候conda也是能察觉到，并更新对应的信息，一同管理。</li>\n<li>Conda有更强的包依赖处理能力，自动删除冲突的包版本并升级，且不会破坏已经存在的包环境，pip直到23.10版本才有此功能，在以前升级包会直接删除包，破环原来的以来环境。</li>\n</ul>\n<h2><span id=\"服务器端的anaconda如何使用\">服务器端的Anaconda如何使用？</span></h2>\n<p>Anaconda提供了UI版本和命令行版本，命令行版本较长使用，UI版本对于不熟悉命令行的用户来说非常好用，在服务器上，打开路径如下：</p>\n<img src=\"https://s2.loli.net/2024/05/13/vtx3a7MOKqSThCI.png\" alt=\"image-20240513230253640\" style=\"zoom:67%;\">\n<p>UI的简单介绍：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/wnUkSLc8Gf2JDO7.png\" alt=\"image-20240607214758652\"></p>\n<p>下图按钮来打开对应的环境的命令行：</p>\n<img src=\"https://s2.loli.net/2024/06/07/Mz7qGjvorfnBcNX.png\" alt=\"image-20240607215445757\" style=\"zoom:80%;\">\n<p>可以看到我们打开了对应的base环境的命令行，同时使用命令安装了numpy：</p>\n<img src=\"https://s2.loli.net/2024/06/07/6IgulrWp2JxM3mP.png\" alt=\"image-20240607215534456\" style=\"zoom:67%;\">\n<p>但是安装失败了：</p>\n<img src=\"https://s2.loli.net/2024/06/07/lqnh3zaIOZVmKPA.png\" alt=\"image-20240607215626411\" style=\"zoom:67%;\">\n<p>安装失败的原因很简单，base环境是每个用户都可以看到的，也就是说base环境是公用的，如果放开权限，base环境就会被不同的人使用，这样就有可能造成环境冲突，为了避免这个问题，我们首先要创建自己的环境：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/T8hWORk4oVuUCZi.png\" alt=\"image-20240607221044637\"></p>\n<img src=\"https://s2.loli.net/2024/06/07/z9cNV35Bkmbgxit.png\" alt=\"image-20240607221425884\" style=\"zoom:80%;\">\n<p>打开命令行，安装numpy，注意这里使用的是pip来安装，目的是为验证conda是否能检测到当前环境安装了numpy：</p>\n<img src=\"https://s2.loli.net/2024/06/07/1FUbQVSlwzh9aiX.png\" alt=\"image-20240607221552326\" style=\"zoom:67%;\">\n<p>更新一下索引内容：</p>\n<img src=\"https://s2.loli.net/2024/06/07/dPEouyVXQMnWgD2.png\" alt=\"image-20240607221707744\" style=\"zoom:80%;\">\n<p>可以看到对应的numpy被检测到了：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/U27RlTkrAwsF6SQ.png\" alt=\"image-20240607221800965\"></p>\n<p>上文是Anaconda的图形化界面，当然你也可以使用shell当中的：</p>\n<p>在命令行中使用命令：</p>\n<pre><code class=\"language-bash\"> conda activate base\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/05/13/INaD3GAgvVC8TPy.png\" alt=\"image-20240513230400329\"></p>\n<p>注意base环境不可以使用，请自己建立环境：</p>\n<pre><code class=\"language-bash\">conda create -n env_name python=3.10\n</code></pre>\n<p>其中env_name为你想创建的环境的名字，python后边为创建的版本。</p>\n<p>下载地址：</p>\n<p><a href=\"https://www.anaconda.com/download\">https://www.anaconda.com/download</a></p>\n<h2><span id=\"matlab使用说明\">Matlab使用说明</span></h2>\n<p><strong>禁止事项：严禁在用户个人目录下私自安装Matlab</strong></p>\n<p>matlab在路径：</p>\n<pre><code class=\"language-bash\">/home/SoftWares/MATLAB/bin\n</code></pre>\n<p>再次目录下右键打开命令行，运行matlab即可</p>\n<pre><code>./matlab\n</code></pre>\n<p>或者快捷方式在：</p>\n<img src=\"https://s2.loli.net/2024/06/07/TKCeJRObo98VyXQ.png\" alt=\"image-20240607222500101\" style=\"zoom:80%;\">\n<img src=\"https://s2.loli.net/2024/06/07/vlaz2VtP8ZRCWsw.png\" alt=\"image-20240607222559328\" style=\"zoom:67%;\">\n<p>**此命令行为matlab运行所使用，不要关闭。**开启后登陆个人matlab账号即可使用，安装的matlab皆为正版，需要根据学校引导来注册正版账号，引导内容在：<a href=\"https://zhengban.xmu.edu.cn/matlab.html%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E9%83%A8%E5%88%86%E4%BB%8B%E7%BB%8D%EF%BC%8C%E9%81%B5%E5%BE%AA%E6%8C%87%E5%8D%97%E3%80%82\">https://zhengban.xmu.edu.cn/matlab.html，查看个人用户部分介绍，遵循指南。</a></p>\n<h4><span id=\"报错处理\">报错处理</span></h4>\n<p><img src=\"https://s2.loli.net/2024/09/02/a2XJilmTOsoyQdU.png\" alt=\"image-20240902193011563\"></p>\n<p>根据matlab官方指南，kill掉对应的进程即可，使用命令：</p>\n<pre><code>ps -fU 用户名 | grep MathWorksServiceHost\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/09/02/7Wz195ZHTEn3hwD.png\" alt=\"image-20240902193935209\"></p>\n<p>使用<code>kill -9  1220267</code>对应的进程号码即可。</p>\n<h2><span id=\"r语言使用指南\">R语言使用指南</span></h2>\n<p>为了方便R语言版本的切换，R语言通过Docker部署，详见Docker篇。</p>\n","excerpt":"","more":"<h1>BionetServer-No1使用说明-基础篇</h1>\n<img src=\"https://s2.loli.net/2024/09/29/vNKRfOVDTng7wdL.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547378732\" style=\"zoom:50%;\" />\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n<p>Version:1.0</p>\n<p>基础篇更新记录：</p>\n<ul>\n<li>V1.0 简化了文档的内容，拆分了文档分为入门和进阶使用。添加了Anaconda的使用介绍，方便入门。</li>\n</ul>\n<p>过往更新记录：</p>\n<ul>\n<li>V1.9 简化了文档的内容，拆分了文档分为入门和进阶使用，删除了容器Matlab的内容。</li>\n<li>V1.8 新增了R使用说明，划分了端口和详细的版本，简单撰写了使用注意事项。</li>\n<li>V1.7 新增了UI使用说明，同时请注意显卡使用。</li>\n<li>V1.6 新增了Tensorflow专用的镜像，使用Tensorflow的可以使用新的镜像，运行速度提升两倍。</li>\n<li>V1.5版本更新，修复Pytorch shm报错的问题，添加了新的镜像，新的镜像自带pytorch等常用python包，添加了Shared memory size的设置</li>\n<li>V1.4版本更新，修复了桌面版的MATLAB的快捷方式，新增了防止桌面版使用休眠的设置指导，有长时间用桌面版跑代码的同学可以看看，容器不受影响。</li>\n<li>V1.3更新了Matlab使用说明</li>\n<li>V1.2更新了免密码登录，添加了用户修改密码的环节</li>\n<li>V1.1更新代码补全、修正了conda的问题</li>\n</ul>\n<p>Date: 2024.06.07</p>\n<p>Authors：NeoNeuxs</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%AF%87\">系统信息篇</a>\n<ul>\n<li><a href=\"#%E7%B3%BB%E7%BB%9F%E7%A1%AC%E7%9B%98%E5%88%86%E5%8C%BA\">系统硬盘分区</a></li>\n<li><a href=\"#%E5%85%AC%E7%94%A8%E6%96%87%E4%BB%B6%E5%A4%B9%E6%8C%87%E5%8D%97\">公用文件夹指南</a></li>\n<li><a href=\"#%E7%BD%91%E7%BB%9C%E7%AB%AF%E5%8F%A3%E4%BF%A1%E6%81%AF\">网络端口信息</a></li>\n<li><a href=\"#%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E4%BF%A1%E6%81%AF\">软件安装信息</a></li>\n<li><a href=\"#%E5%9F%BA%E4%BA%8Eui%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8\">基于UI的方式远程连接服务器</a></li>\n</ul>\n</li>\n<li><a href=\"#%E7%94%A8%E6%88%B7%E7%AF%87\">用户篇</a>\n<ul>\n<li><a href=\"#%E9%80%89%E6%8B%A9%E8%87%AA%E5%B7%B1%E5%96%9C%E6%AC%A2%E7%9A%84%E6%A1%8C%E9%9D%A2%E6%9C%8D%E5%8A%A1\">选择自己喜欢的桌面服务</a>\n<ul>\n<li><a href=\"#gnome\">GNOME</a></li>\n<li><a href=\"#xfce%E6%A1%8C%E9%9D%A2\">Xfce桌面</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E9%80%80%E5%87%BA%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5\">如何正确退出远程连接？</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%85%B3%E9%97%AD%E9%94%81%E5%B1%8F%E5%8A%9F%E8%83%BD\">如何关闭锁屏功能</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E6%B3%95\">如何配置中文输入法</a></li>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E7%9A%84%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7\">基本的开发工具</a></li>\n<li><a href=\"#anaconda%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\">Anaconda使用说明</a>\n<ul>\n<li><a href=\"#anacondacondapip\">Anaconda，conda，pip</a>\n<ul>\n<li><a href=\"#anaconda\">Anaconda</a></li>\n<li><a href=\"#conda\">conda</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E7%9A%84anaconda%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\">服务器端的Anaconda如何使用？</a></li>\n<li><a href=\"#matlab%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E\">Matlab使用说明</a>\n<ul>\n<li><a href=\"#%E6%8A%A5%E9%94%99%E5%A4%84%E7%90%86\">报错处理</a></li>\n</ul>\n</li>\n<li><a href=\"#r%E8%AF%AD%E8%A8%80%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97\">R语言使用指南</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h1>系统信息篇</h1>\n<h2 id=\"系统硬盘分区\">系统硬盘分区</h2>\n<p>目前系统是由这样的硬盘空间组成的,分为高速、中速、低速区：</p>\n<p>顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：</p>\n<p><code>Data_NAS(Datasets) &gt; Samsung 860evo 512G  &gt; GLOWAY YCQ4TNVMe-M.2</code></p>\n<p>其中每一条格式如下：[分区名、挂载路径、分区大小]</p>\n<pre class=\"mermaid\">graph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --> nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --> nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --> nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --> nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --> nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --> nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --> MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --> sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --> sda2[\"sda2,[/boot],1GB\"]\n  sda --> empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --> LowSpeed\n  subgraph LowSpeed\n  NAS --> NFS1(NFS,/home/Data_NAS,16T)\n  NAS --> NFS2(NFS,/home/Datasets,16T)\n  end</pre>\n<h2 id=\"公用文件夹指南\">公用文件夹指南</h2>\n<p><code>/home</code>文件夹：</p>\n<img src=\"https://s2.loli.net/2024/04/01/fm4gUGQCToIbkv8.png\" alt=\"image-20240401202923240\" style=\"zoom:80%;\" />\n<p>这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png\" alt=\"image-20240513230049068\"></p>\n<p>一共包含六个文件夹：</p>\n<ul>\n<li>\n<p>Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：<code>上传者_数据集名称_上传日期</code>。</p>\n<ul>\n<li>此文件夹使用详见：<a href=\"http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/\">NAS服务器使用说明</a></li>\n</ul>\n</li>\n<li>\n<p>Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。</p>\n</li>\n<li>\n<p>PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】</p>\n</li>\n<li>\n<p>NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改）</p>\n</li>\n<li>\n<p>Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。</p>\n</li>\n<li>\n<p>SoftWares文件夹比较特殊：</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png\" alt=\"image-20240401205431946\"></p>\n<p>​\t里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候在部分情况下只可读，无法写入，需要通过桌面用户来写入文件（出于安全和权限管理的考虑，如果报错可以单独找我了解）。</p>\n<p>P代指python容器，R代指R语言容器的存储空间。二者都被容器挂载。</p>\n<h2 id=\"网络端口信息\">网络端口信息</h2>\n<p><strong>端口的使用主要集中在容器。可以通过portainer来查看，portainer如何使用详见docker篇。</strong></p>\n<h2 id=\"软件安装信息\">软件安装信息</h2>\n<p>Anaconda：/home/anaconda</p>\n<p>Matlab：/home/SoftWares/Matlab</p>\n<p>Dcoker：/默认路径</p>\n<p>Jetbrains IDEs：/home/SoftWares/Jetbrain</p>\n<h2 id=\"基于UI的方式远程连接服务器\">基于UI的方式远程连接服务器</h2>\n<p>首先我们要确认是否连接到了校园网，在系统命令行上使用命令：</p>\n<pre><code class=\"language-bash\">ping 10.26.58.61\n</code></pre>\n<p>结果如下则证明你在校园网内。</p>\n<img src=\"https://s2.loli.net/2024/05/13/Yts7QOiU1ymlfrS.png\" alt=\"image-20240513224911484\" style=\"zoom:67%;\" />\n<p>打开windos远程连接，在状态栏中搜索远程连接，对于Windows系统，家庭版往往没有此功能，需要升级至专业版，具体升级方法可以去某宝买一个激活码，价格在10元左右。询问店家如何激活升级。</p>\n<img src=\"https://s2.loli.net/2024/05/13/yiS3oGNWZaUFMbz.png\" alt=\"image-20240513224939223\" style=\"zoom:80%;\" />\n<p>打开远程桌面输入远程地址，打开选项：</p>\n<img src=\"https://s2.loli.net/2024/05/13/igJMIEtfhBOQC4Y.png\" alt=\"image-20240513225154369\" style=\"zoom:67%;\" />\n<p>打开选项之后，输入链接地址：10.26.58.61</p>\n<p>然后点击显示选项，参照我这里修改：</p>\n<img src=\"https://s2.loli.net/2024/05/13/sFaqp1WPLRJNeOx.png\" alt=\"image-20240513225353292\" style=\"zoom:67%;\" />\n<p>然后点击编辑，修改成你的用户名和密码，连接即可。</p>\n<img src=\"https://s2.loli.net/2024/05/13/NhkFSiZEv8rxVgX.png\" alt=\"image-20240513225650039\" style=\"zoom:67%;\" />\n<p>输入你的用户名和密码：</p>\n<img src=\"https://s2.loli.net/2024/05/13/AwEjJ9RDTV1qifg.png\" alt=\"image-20240513225551955\" style=\"zoom:67%;\" />\n<p>连接后进入桌面，即可开始使用，如遇到剪贴板不能互相传输、小文件不能传输，请关闭连接重开即可，文件传输依赖于NAS可以参考一下NAS篇介绍。</p>\n<h1>用户篇</h1>\n<h2 id=\"选择自己喜欢的桌面服务\">选择自己喜欢的桌面服务</h2>\n<p>服务器升级之后存在两个桌面服务二者依托于XRDP实现</p>\n<h3 id=\"GNOME\">GNOME</h3>\n<p>GNOME是Ubuntu原生的桌面，其优点是：</p>\n<p>界面简洁优雅，是默认的桌面。</p>\n<img src=\"https://s2.loli.net/2024/03/24/irtsMxvByUK31lm.png\" alt=\"image-20240324173036063\" style=\"zoom:80%;\" />\n<img src=\"https://s2.loli.net/2024/03/24/w4lICZTjE6FmzcR.png\" alt=\"image-20240324173049733\" style=\"zoom:80%;\" />\n<p>可个性化定制的比较多，简单来说就是好看~</p>\n<h3 id=\"Xfce桌面\">Xfce桌面</h3>\n<img src=\"https://s2.loli.net/2024/03/24/DGACKf3BFswoix1.png\" alt=\"image-20240324173242318\" style=\"zoom:80%;\" />\n<p>相对轻量化一点，性能消耗少一点，二者差不多，关键点还是个人喜好问题。</p>\n<p>二者如何切换？</p>\n<p>在命令行中执行如下命令：</p>\n<pre><code class=\"language-bash\">echo xfce4-session &gt;~/.xsession\n</code></pre>\n<p>此时Xdrp默认启动的桌面就改成 Xcfe4 如果你喜欢你的GNOME桌面可以再切换回去：</p>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">rm ~/.xsession\n</code></pre>\n<p><strong>退出登录之后，注意要退出登录</strong>不是关闭远程连接，重新登陆即可登录到新的桌面。不懂如何退出请看下一小节。</p>\n<p>同时开多个个cpu消耗也比较少：</p>\n<img src=\"https://s2.loli.net/2024/03/24/KIGeZmDfNarEt9U.png\" alt=\"image-20240324173454858\" style=\"zoom:67%;\" />\n<h2 id=\"如何正确退出远程连接？\">如何正确退出远程连接？</h2>\n<p>开启远程链接之后如果按照以下操作，会话将会保持运行，占用资源，正确退出方法如下：</p>\n<img src=\"https://s2.loli.net/2024/03/25/mPSAMvcUsreYgQ7.png\" alt=\"image-20240325115418950\" style=\"zoom: 80%;\" />\n<h2 id=\"如何关闭锁屏功能\">如何关闭锁屏功能</h2>\n<p>在这里找到设置：</p>\n<img src=\"https://s2.loli.net/2024/04/20/Vv6n4ItDzgpUXsr.png\" alt=\"image-20240420190046154\" style=\"zoom:80%;\" />\n<img src=\"https://s2.loli.net/2024/04/20/LP43Aq8mX1I2ecb.png\" alt=\"image-20240420190108244\" style=\"zoom:67%;\" />\n<img src=\"https://s2.loli.net/2024/04/20/uIiRbpaY6Z2OBhx.png\" alt=\"image-20240420190123305\" style=\"zoom:67%;\" />\n<p>关闭即可。</p>\n<h2 id=\"如何配置中文输入法\">如何配置中文输入法</h2>\n<p>打开fctix 5：</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/HzeqfrZxGpQOcmj.png\" alt=\"image-20240326205930890\"></p>\n<p>这里会提示运行fctix 5：</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/Eeza317wogSMcli.png\" alt=\"image-20240326210030357\"></p>\n<p>在这里找到拼音：</p>\n<img src=\"https://s2.loli.net/2024/03/26/PX9Gdk5ElF8VI4C.png\" alt=\"image-20240326210056577\" style=\"zoom: 80%;\" />\n<p>点击添加并应用：</p>\n<img src=\"https://s2.loli.net/2024/03/26/8vgad9fEVwjA5yW.png\" alt=\"image-20240326210139494\" style=\"zoom:80%;\" />\n<p>找到语言设置：</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/cDq7MzyRkbVBadi.png\" alt=\"image-20240326210306567\"></p>\n<p>更改设置如下，并登出，重新启动之后</p>\n<p><img src=\"https://s2.loli.net/2024/03/26/bCHiPtZSow3vcmu.png\" alt=\"image-20240326210336015\"></p>\n<img src=\"https://s2.loli.net/2024/03/26/tIrZ4owaCkPXvQc.png\" alt=\"image-20240326210413055\" style=\"zoom:80%;\" />\n<p>可以愉快使用：</p>\n<p><strong>注意输入法切换要使用ctrl+空格键</strong></p>\n<p><img src=\"https://s2.loli.net/2024/03/26/nIgFTsCrmcxbMzt.png\" alt=\"image-20240326210456544\"></p>\n<h2 id=\"基本的开发工具\">基本的开发工具</h2>\n<p>使用UI开发的基本工具都在：</p>\n<img src=\"https://s2.loli.net/2024/05/13/bRqM8GFJT9Hjs3C.png\" alt=\"image-20240513230203466\" style=\"zoom:67%;\" />\n<p>PyCharm使用的介绍这里不赘述，网上有很多，需要提醒的是选择Python Inter（python解释器）的时候</p>\n<h2 id=\"Anaconda使用说明\">Anaconda使用说明</h2>\n<p><strong>禁止事项：严禁在用户个人目录下私自安装Anaconda</strong></p>\n<h3 id=\"Anaconda，conda，pip\">Anaconda，conda，pip</h3>\n<h4 id=\"Anaconda\">Anaconda</h4>\n<p>The world’s most trusted open ecosystem for sourcing, building, and deploying data science and AI initiatives</p>\n<p>和过去大家理解的Python和R语言的发行版，旨在简化包管理和部署的软件，不太相同了，全面拥抱AI，不仅仅是一个Python的发行版本了，提供了AI从数据到部署全部解决方案，不这里不会涉及到太多这些，毕竟这些方式在近些年还并不是最主流的，我们还有docker来部署，但是其作为Python的管理工具还是十分强大的。</p>\n<h4 id=\"conda\">conda</h4>\n<p>conda是Anaconda的核心组件，是其包管理器，Conda和pip都是Python的包管理工具，但是conda不仅仅能管理Python也能管理R语言，但是R语言自带了包管理器，Python也自带了包管理器，也就是Pip，那么为什么还需要conda呢?</p>\n<p>Conda对比语言自己带的管理器有以下优势：</p>\n<ul>\n<li>Conda支持创建、保存、加载和更新隔离的环境，每个环境可以有不同的包和版本，非常适合多项目开发，换句话话说，conda可以创建虚拟环境，可以切换Python版本。</li>\n<li>Conda支持pip安装的包的管理，pip往往和对应的python版本相绑定，而conda可以管理Python（不仅仅是Python的包，而是某个版本的Python），也就是说conda也能管理Pip及其安装的包，当你使用pip安装对应的包的时候conda也是能察觉到，并更新对应的信息，一同管理。</li>\n<li>Conda有更强的包依赖处理能力，自动删除冲突的包版本并升级，且不会破坏已经存在的包环境，pip直到23.10版本才有此功能，在以前升级包会直接删除包，破环原来的以来环境。</li>\n</ul>\n<h2 id=\"服务器端的Anaconda如何使用？\">服务器端的Anaconda如何使用？</h2>\n<p>Anaconda提供了UI版本和命令行版本，命令行版本较长使用，UI版本对于不熟悉命令行的用户来说非常好用，在服务器上，打开路径如下：</p>\n<img src=\"https://s2.loli.net/2024/05/13/vtx3a7MOKqSThCI.png\" alt=\"image-20240513230253640\" style=\"zoom:67%;\" />\n<p>UI的简单介绍：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/wnUkSLc8Gf2JDO7.png\" alt=\"image-20240607214758652\"></p>\n<p>下图按钮来打开对应的环境的命令行：</p>\n<img src=\"https://s2.loli.net/2024/06/07/Mz7qGjvorfnBcNX.png\" alt=\"image-20240607215445757\" style=\"zoom:80%;\" />\n<p>可以看到我们打开了对应的base环境的命令行，同时使用命令安装了numpy：</p>\n<img src=\"https://s2.loli.net/2024/06/07/6IgulrWp2JxM3mP.png\" alt=\"image-20240607215534456\" style=\"zoom:67%;\" />\n<p>但是安装失败了：</p>\n<img src=\"https://s2.loli.net/2024/06/07/lqnh3zaIOZVmKPA.png\" alt=\"image-20240607215626411\" style=\"zoom:67%;\" />\n<p>安装失败的原因很简单，base环境是每个用户都可以看到的，也就是说base环境是公用的，如果放开权限，base环境就会被不同的人使用，这样就有可能造成环境冲突，为了避免这个问题，我们首先要创建自己的环境：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/T8hWORk4oVuUCZi.png\" alt=\"image-20240607221044637\"></p>\n<img src=\"https://s2.loli.net/2024/06/07/z9cNV35Bkmbgxit.png\" alt=\"image-20240607221425884\" style=\"zoom:80%;\" />\n<p>打开命令行，安装numpy，注意这里使用的是pip来安装，目的是为验证conda是否能检测到当前环境安装了numpy：</p>\n<img src=\"https://s2.loli.net/2024/06/07/1FUbQVSlwzh9aiX.png\" alt=\"image-20240607221552326\" style=\"zoom:67%;\" />\n<p>更新一下索引内容：</p>\n<img src=\"https://s2.loli.net/2024/06/07/dPEouyVXQMnWgD2.png\" alt=\"image-20240607221707744\" style=\"zoom:80%;\" />\n<p>可以看到对应的numpy被检测到了：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/U27RlTkrAwsF6SQ.png\" alt=\"image-20240607221800965\"></p>\n<p>上文是Anaconda的图形化界面，当然你也可以使用shell当中的：</p>\n<p>在命令行中使用命令：</p>\n<pre><code class=\"language-bash\"> conda activate base\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/05/13/INaD3GAgvVC8TPy.png\" alt=\"image-20240513230400329\"></p>\n<p>注意base环境不可以使用，请自己建立环境：</p>\n<pre><code class=\"language-bash\">conda create -n env_name python=3.10\n</code></pre>\n<p>其中env_name为你想创建的环境的名字，python后边为创建的版本。</p>\n<p>下载地址：</p>\n<p><a href=\"https://www.anaconda.com/download\">https://www.anaconda.com/download</a></p>\n<h2 id=\"Matlab使用说明\">Matlab使用说明</h2>\n<p><strong>禁止事项：严禁在用户个人目录下私自安装Matlab</strong></p>\n<p>matlab在路径：</p>\n<pre><code class=\"language-bash\">/home/SoftWares/MATLAB/bin\n</code></pre>\n<p>再次目录下右键打开命令行，运行matlab即可</p>\n<pre><code>./matlab\n</code></pre>\n<p>或者快捷方式在：</p>\n<img src=\"https://s2.loli.net/2024/06/07/TKCeJRObo98VyXQ.png\" alt=\"image-20240607222500101\" style=\"zoom:80%;\" />\n<img src=\"https://s2.loli.net/2024/06/07/vlaz2VtP8ZRCWsw.png\" alt=\"image-20240607222559328\" style=\"zoom:67%;\" />\n<p>**此命令行为matlab运行所使用，不要关闭。**开启后登陆个人matlab账号即可使用，安装的matlab皆为正版，需要根据学校引导来注册正版账号，引导内容在：<a href=\"https://zhengban.xmu.edu.cn/matlab.html%EF%BC%8C%E6%9F%A5%E7%9C%8B%E4%B8%AA%E4%BA%BA%E7%94%A8%E6%88%B7%E9%83%A8%E5%88%86%E4%BB%8B%E7%BB%8D%EF%BC%8C%E9%81%B5%E5%BE%AA%E6%8C%87%E5%8D%97%E3%80%82\">https://zhengban.xmu.edu.cn/matlab.html，查看个人用户部分介绍，遵循指南。</a></p>\n<h4 id=\"报错处理\">报错处理</h4>\n<p><img src=\"https://s2.loli.net/2024/09/02/a2XJilmTOsoyQdU.png\" alt=\"image-20240902193011563\"></p>\n<p>根据matlab官方指南，kill掉对应的进程即可，使用命令：</p>\n<pre><code>ps -fU 用户名 | grep MathWorksServiceHost\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/09/02/7Wz195ZHTEn3hwD.png\" alt=\"image-20240902193935209\"></p>\n<p>使用<code>kill -9  1220267</code>对应的进程号码即可。</p>\n<h2 id=\"R语言使用指南\">R语言使用指南</h2>\n<p>为了方便R语言版本的切换，R语言通过Docker部署，详见Docker篇。</p>\n"},{"title":"Bionet_WIFI使用指南","date":"2024-09-29T14:22:00.000Z","_content":"\n# Bionet_WIFI使用指南\n\n<img src=\"https://s2.loli.net/2024/09/29/yhNMvJ21PrfqVOk.jpg\" alt=\"使用指南\" style=\"zoom:67%;\" />\n\n<!-- toc -->\n\n适用对象：文宣楼A406课题组成员\n\nA406房间包含两个独立的路由器，分别有1000Mb的带宽。\n\n其SSID（名字）如下：\n\n<img src=\"https://s2.loli.net/2024/05/12/HDXRUkAf2tINVlp.png\" alt=\"image-20240512112431863.png\" style=\"zoom: 67%;\" />\n\n使用的时候，应选择排名比较靠前的WIFI使用，越靠前来说信号越好，速度越快。\n\n## 获取本机的真实MAC地址\n\n路由器开启了连接管控，可以找谭然、或者我来执行绑定和连接。设备绑定依赖于本机的真实MAC地址。首先要获取设备的真实MAC地址，获取方法如下：\n\n### PC设备：\n\n获取本机MAC地址\n\n在设置中查找MAC：\n\n<img src=\"https://s2.loli.net/2024/05/11/1IlVejHObDtQ6oE.png\" alt=\"image-20240511182342670.png\" style=\"zoom: 67%;\" />\n\n点击：\n\n<img src=\"https://s2.loli.net/2024/09/29/SAQXCqUmkYhjteF.png\" alt=\"image-20240928171559953\" style=\"zoom: 67%;\" />\n\n关闭随机硬件MAC地址：\n\n<img src=\"https://s2.loli.net/2024/05/11/OFXSioyE2GUqvhW.png\" alt=\"image-20240511182513806.png\" style=\"zoom:67%;\" />\n\n点击：\n\n<img src=\"https://s2.loli.net/2024/05/12/ULCXqEJRFigHPmz.png\" alt=\"image-20240511182756107.png\" style=\"zoom:67%;\" />\n\n然后记录下此信息：\n\n<img src=\"https://s2.loli.net/2024/05/12/zKdChegHlj5PfuY.png\" alt=\"image-20240511182816689.png\" style=\"zoom:80%;\" />\n\n以如下格式发送给我：\n\n```shell\n设备名称：neo_phone (姓名_设备名称)\nMAC地址：填入MAC地址\n```\n\n然后即可继续连接。\n\n### Android设备：\n\n以荣耀设备为例子：\n\n打开设备设置管理界面：\n\n<img src=\"https://s2.loli.net/2024/05/11/hJEzybCkvB7SfqP.png\" alt=\"image-20240511183320386.png\" style=\"zoom:67%;\" />\n\n在上方搜索栏搜索：MAC\n\n选择：\n\n<img src=\"https://s2.loli.net/2024/05/11/3oHQGbsweR1YINL.png\" alt=\"image-20240511183449726.png\" style=\"zoom:50%;\" />\n\n将此内容截图发给我：\n\n<img src=\"https://s2.loli.net/2024/05/11/WbVSzdspKXocCL9.png\" alt=\"image-20240511183526491.png\" style=\"zoom: 80%;\" />\n\n等我添加信息之后，选择对应的WIFI连接：\n\n连接时选择高级选项，将随机MAC地址修改成使用设备MAC：\n\n<img src=\"https://s2.loli.net/2024/05/11/QaoEg38j5WfxNYH.png\" alt=\"image-20240511183602054.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/05/11/92ESIyW4pxHRz1j.png\" alt=\"image-20240511183706756.png\" style=\"zoom: 50%;\" />\n\n输入密码连接即可，等我添加完成设备之后就可以上网了。\n\n### IOS设备：\n\nIOS设备需要先连接到WIFI，点击对应WIFI右侧的感叹号，查看MAC地址信息：\n\n```shell\n设备名称：neo_ipad/iphone/MAC (姓名_设备名称)\nMAC地址：填入MAC地址\n```\n\n<img src=\"https://s2.loli.net/2024/05/11/YbuERIdAP4XhZOy.png\" alt=\"image-20240511185628123.png\" style=\"zoom:67%;\" />\n\n连接之后会提示无法上网，问题不大，关闭自己的私有MAC地址：\n\n<img src=\"https://s2.loli.net/2024/05/11/FnKaXR76Tm2fpPu.png\" alt=\"image-20240511184700751.png\" style=\"zoom:67%;\" />","source":"_posts/Bionet_WiFi.md","raw":"---\ntitle:  Bionet_WIFI使用指南\ncategories:\n  - Bionet\ntags:\n  - Bionet\n  - A406\n  - WIFI\ndate: 2024/9/29 22:22:00\n---\n\n# Bionet_WIFI使用指南\n\n<img src=\"https://s2.loli.net/2024/09/29/yhNMvJ21PrfqVOk.jpg\" alt=\"使用指南\" style=\"zoom:67%;\" />\n\n<!-- toc -->\n\n适用对象：文宣楼A406课题组成员\n\nA406房间包含两个独立的路由器，分别有1000Mb的带宽。\n\n其SSID（名字）如下：\n\n<img src=\"https://s2.loli.net/2024/05/12/HDXRUkAf2tINVlp.png\" alt=\"image-20240512112431863.png\" style=\"zoom: 67%;\" />\n\n使用的时候，应选择排名比较靠前的WIFI使用，越靠前来说信号越好，速度越快。\n\n## 获取本机的真实MAC地址\n\n路由器开启了连接管控，可以找谭然、或者我来执行绑定和连接。设备绑定依赖于本机的真实MAC地址。首先要获取设备的真实MAC地址，获取方法如下：\n\n### PC设备：\n\n获取本机MAC地址\n\n在设置中查找MAC：\n\n<img src=\"https://s2.loli.net/2024/05/11/1IlVejHObDtQ6oE.png\" alt=\"image-20240511182342670.png\" style=\"zoom: 67%;\" />\n\n点击：\n\n<img src=\"https://s2.loli.net/2024/09/29/SAQXCqUmkYhjteF.png\" alt=\"image-20240928171559953\" style=\"zoom: 67%;\" />\n\n关闭随机硬件MAC地址：\n\n<img src=\"https://s2.loli.net/2024/05/11/OFXSioyE2GUqvhW.png\" alt=\"image-20240511182513806.png\" style=\"zoom:67%;\" />\n\n点击：\n\n<img src=\"https://s2.loli.net/2024/05/12/ULCXqEJRFigHPmz.png\" alt=\"image-20240511182756107.png\" style=\"zoom:67%;\" />\n\n然后记录下此信息：\n\n<img src=\"https://s2.loli.net/2024/05/12/zKdChegHlj5PfuY.png\" alt=\"image-20240511182816689.png\" style=\"zoom:80%;\" />\n\n以如下格式发送给我：\n\n```shell\n设备名称：neo_phone (姓名_设备名称)\nMAC地址：填入MAC地址\n```\n\n然后即可继续连接。\n\n### Android设备：\n\n以荣耀设备为例子：\n\n打开设备设置管理界面：\n\n<img src=\"https://s2.loli.net/2024/05/11/hJEzybCkvB7SfqP.png\" alt=\"image-20240511183320386.png\" style=\"zoom:67%;\" />\n\n在上方搜索栏搜索：MAC\n\n选择：\n\n<img src=\"https://s2.loli.net/2024/05/11/3oHQGbsweR1YINL.png\" alt=\"image-20240511183449726.png\" style=\"zoom:50%;\" />\n\n将此内容截图发给我：\n\n<img src=\"https://s2.loli.net/2024/05/11/WbVSzdspKXocCL9.png\" alt=\"image-20240511183526491.png\" style=\"zoom: 80%;\" />\n\n等我添加信息之后，选择对应的WIFI连接：\n\n连接时选择高级选项，将随机MAC地址修改成使用设备MAC：\n\n<img src=\"https://s2.loli.net/2024/05/11/QaoEg38j5WfxNYH.png\" alt=\"image-20240511183602054.png\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/05/11/92ESIyW4pxHRz1j.png\" alt=\"image-20240511183706756.png\" style=\"zoom: 50%;\" />\n\n输入密码连接即可，等我添加完成设备之后就可以上网了。\n\n### IOS设备：\n\nIOS设备需要先连接到WIFI，点击对应WIFI右侧的感叹号，查看MAC地址信息：\n\n```shell\n设备名称：neo_ipad/iphone/MAC (姓名_设备名称)\nMAC地址：填入MAC地址\n```\n\n<img src=\"https://s2.loli.net/2024/05/11/YbuERIdAP4XhZOy.png\" alt=\"image-20240511185628123.png\" style=\"zoom:67%;\" />\n\n连接之后会提示无法上网，问题不大，关闭自己的私有MAC地址：\n\n<img src=\"https://s2.loli.net/2024/05/11/FnKaXR76Tm2fpPu.png\" alt=\"image-20240511184700751.png\" style=\"zoom:67%;\" />","slug":"Bionet_WiFi","published":1,"updated":"2024-11-27T03:55:57.801Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti06001myjin16q6fgla","content":"<h1><span id=\"bionet_wifi使用指南\">Bionet_WIFI使用指南</span></h1>\n<img src=\"https://s2.loli.net/2024/09/29/yhNMvJ21PrfqVOk.jpg\" alt=\"使用指南\" style=\"zoom:67%;\">\n<!-- toc -->\n<ul>\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%9A%84%E7%9C%9F%E5%AE%9Emac%E5%9C%B0%E5%9D%80\">获取本机的真实MAC地址</a>\n<ul>\n<li><a href=\"#pc%E8%AE%BE%E5%A4%87\">PC设备：</a></li>\n<li><a href=\"#android%E8%AE%BE%E5%A4%87\">Android设备：</a></li>\n<li><a href=\"#ios%E8%AE%BE%E5%A4%87\">IOS设备：</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>适用对象：文宣楼A406课题组成员</p>\n<p>A406房间包含两个独立的路由器，分别有1000Mb的带宽。</p>\n<p>其SSID（名字）如下：</p>\n<img src=\"https://s2.loli.net/2024/05/12/HDXRUkAf2tINVlp.png\" alt=\"image-20240512112431863.png\" style=\"zoom: 67%;\">\n<p>使用的时候，应选择排名比较靠前的WIFI使用，越靠前来说信号越好，速度越快。</p>\n<h2><span id=\"获取本机的真实mac地址\">获取本机的真实MAC地址</span></h2>\n<p>路由器开启了连接管控，可以找谭然、或者我来执行绑定和连接。设备绑定依赖于本机的真实MAC地址。首先要获取设备的真实MAC地址，获取方法如下：</p>\n<h3><span id=\"pc设备\">PC设备：</span></h3>\n<p>获取本机MAC地址</p>\n<p>在设置中查找MAC：</p>\n<img src=\"https://s2.loli.net/2024/05/11/1IlVejHObDtQ6oE.png\" alt=\"image-20240511182342670.png\" style=\"zoom: 67%;\">\n<p>点击：</p>\n<img src=\"https://s2.loli.net/2024/09/29/SAQXCqUmkYhjteF.png\" alt=\"image-20240928171559953\" style=\"zoom: 67%;\">\n<p>关闭随机硬件MAC地址：</p>\n<img src=\"https://s2.loli.net/2024/05/11/OFXSioyE2GUqvhW.png\" alt=\"image-20240511182513806.png\" style=\"zoom:67%;\">\n<p>点击：</p>\n<img src=\"https://s2.loli.net/2024/05/12/ULCXqEJRFigHPmz.png\" alt=\"image-20240511182756107.png\" style=\"zoom:67%;\">\n<p>然后记录下此信息：</p>\n<img src=\"https://s2.loli.net/2024/05/12/zKdChegHlj5PfuY.png\" alt=\"image-20240511182816689.png\" style=\"zoom:80%;\">\n<p>以如下格式发送给我：</p>\n<pre><code class=\"language-shell\">设备名称：neo_phone (姓名_设备名称)\nMAC地址：填入MAC地址\n</code></pre>\n<p>然后即可继续连接。</p>\n<h3><span id=\"android设备\">Android设备：</span></h3>\n<p>以荣耀设备为例子：</p>\n<p>打开设备设置管理界面：</p>\n<img src=\"https://s2.loli.net/2024/05/11/hJEzybCkvB7SfqP.png\" alt=\"image-20240511183320386.png\" style=\"zoom:67%;\">\n<p>在上方搜索栏搜索：MAC</p>\n<p>选择：</p>\n<img src=\"https://s2.loli.net/2024/05/11/3oHQGbsweR1YINL.png\" alt=\"image-20240511183449726.png\" style=\"zoom:50%;\">\n<p>将此内容截图发给我：</p>\n<img src=\"https://s2.loli.net/2024/05/11/WbVSzdspKXocCL9.png\" alt=\"image-20240511183526491.png\" style=\"zoom: 80%;\">\n<p>等我添加信息之后，选择对应的WIFI连接：</p>\n<p>连接时选择高级选项，将随机MAC地址修改成使用设备MAC：</p>\n<img src=\"https://s2.loli.net/2024/05/11/QaoEg38j5WfxNYH.png\" alt=\"image-20240511183602054.png\" style=\"zoom:67%;\">\n<img src=\"https://s2.loli.net/2024/05/11/92ESIyW4pxHRz1j.png\" alt=\"image-20240511183706756.png\" style=\"zoom: 50%;\">\n<p>输入密码连接即可，等我添加完成设备之后就可以上网了。</p>\n<h3><span id=\"ios设备\">IOS设备：</span></h3>\n<p>IOS设备需要先连接到WIFI，点击对应WIFI右侧的感叹号，查看MAC地址信息：</p>\n<pre><code class=\"language-shell\">设备名称：neo_ipad/iphone/MAC (姓名_设备名称)\nMAC地址：填入MAC地址\n</code></pre>\n<img src=\"https://s2.loli.net/2024/05/11/YbuERIdAP4XhZOy.png\" alt=\"image-20240511185628123.png\" style=\"zoom:67%;\">\n<p>连接之后会提示无法上网，问题不大，关闭自己的私有MAC地址：</p>\n<img src=\"https://s2.loli.net/2024/05/11/FnKaXR76Tm2fpPu.png\" alt=\"image-20240511184700751.png\" style=\"zoom:67%;\">","excerpt":"","more":"<h1>Bionet_WIFI使用指南</h1>\n<img src=\"https://s2.loli.net/2024/09/29/yhNMvJ21PrfqVOk.jpg\" alt=\"使用指南\" style=\"zoom:67%;\" />\n<!-- toc -->\n<ul>\n<li><a href=\"#%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%9A%84%E7%9C%9F%E5%AE%9Emac%E5%9C%B0%E5%9D%80\">获取本机的真实MAC地址</a>\n<ul>\n<li><a href=\"#pc%E8%AE%BE%E5%A4%87\">PC设备：</a></li>\n<li><a href=\"#android%E8%AE%BE%E5%A4%87\">Android设备：</a></li>\n<li><a href=\"#ios%E8%AE%BE%E5%A4%87\">IOS设备：</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>适用对象：文宣楼A406课题组成员</p>\n<p>A406房间包含两个独立的路由器，分别有1000Mb的带宽。</p>\n<p>其SSID（名字）如下：</p>\n<img src=\"https://s2.loli.net/2024/05/12/HDXRUkAf2tINVlp.png\" alt=\"image-20240512112431863.png\" style=\"zoom: 67%;\" />\n<p>使用的时候，应选择排名比较靠前的WIFI使用，越靠前来说信号越好，速度越快。</p>\n<h2 id=\"获取本机的真实MAC地址\">获取本机的真实MAC地址</h2>\n<p>路由器开启了连接管控，可以找谭然、或者我来执行绑定和连接。设备绑定依赖于本机的真实MAC地址。首先要获取设备的真实MAC地址，获取方法如下：</p>\n<h3 id=\"PC设备：\">PC设备：</h3>\n<p>获取本机MAC地址</p>\n<p>在设置中查找MAC：</p>\n<img src=\"https://s2.loli.net/2024/05/11/1IlVejHObDtQ6oE.png\" alt=\"image-20240511182342670.png\" style=\"zoom: 67%;\" />\n<p>点击：</p>\n<img src=\"https://s2.loli.net/2024/09/29/SAQXCqUmkYhjteF.png\" alt=\"image-20240928171559953\" style=\"zoom: 67%;\" />\n<p>关闭随机硬件MAC地址：</p>\n<img src=\"https://s2.loli.net/2024/05/11/OFXSioyE2GUqvhW.png\" alt=\"image-20240511182513806.png\" style=\"zoom:67%;\" />\n<p>点击：</p>\n<img src=\"https://s2.loli.net/2024/05/12/ULCXqEJRFigHPmz.png\" alt=\"image-20240511182756107.png\" style=\"zoom:67%;\" />\n<p>然后记录下此信息：</p>\n<img src=\"https://s2.loli.net/2024/05/12/zKdChegHlj5PfuY.png\" alt=\"image-20240511182816689.png\" style=\"zoom:80%;\" />\n<p>以如下格式发送给我：</p>\n<pre><code class=\"language-shell\">设备名称：neo_phone (姓名_设备名称)\nMAC地址：填入MAC地址\n</code></pre>\n<p>然后即可继续连接。</p>\n<h3 id=\"Android设备：\">Android设备：</h3>\n<p>以荣耀设备为例子：</p>\n<p>打开设备设置管理界面：</p>\n<img src=\"https://s2.loli.net/2024/05/11/hJEzybCkvB7SfqP.png\" alt=\"image-20240511183320386.png\" style=\"zoom:67%;\" />\n<p>在上方搜索栏搜索：MAC</p>\n<p>选择：</p>\n<img src=\"https://s2.loli.net/2024/05/11/3oHQGbsweR1YINL.png\" alt=\"image-20240511183449726.png\" style=\"zoom:50%;\" />\n<p>将此内容截图发给我：</p>\n<img src=\"https://s2.loli.net/2024/05/11/WbVSzdspKXocCL9.png\" alt=\"image-20240511183526491.png\" style=\"zoom: 80%;\" />\n<p>等我添加信息之后，选择对应的WIFI连接：</p>\n<p>连接时选择高级选项，将随机MAC地址修改成使用设备MAC：</p>\n<img src=\"https://s2.loli.net/2024/05/11/QaoEg38j5WfxNYH.png\" alt=\"image-20240511183602054.png\" style=\"zoom:67%;\" />\n<img src=\"https://s2.loli.net/2024/05/11/92ESIyW4pxHRz1j.png\" alt=\"image-20240511183706756.png\" style=\"zoom: 50%;\" />\n<p>输入密码连接即可，等我添加完成设备之后就可以上网了。</p>\n<h3 id=\"IOS设备：\">IOS设备：</h3>\n<p>IOS设备需要先连接到WIFI，点击对应WIFI右侧的感叹号，查看MAC地址信息：</p>\n<pre><code class=\"language-shell\">设备名称：neo_ipad/iphone/MAC (姓名_设备名称)\nMAC地址：填入MAC地址\n</code></pre>\n<img src=\"https://s2.loli.net/2024/05/11/YbuERIdAP4XhZOy.png\" alt=\"image-20240511185628123.png\" style=\"zoom:67%;\" />\n<p>连接之后会提示无法上网，问题不大，关闭自己的私有MAC地址：</p>\n<img src=\"https://s2.loli.net/2024/05/11/FnKaXR76Tm2fpPu.png\" alt=\"image-20240511184700751.png\" style=\"zoom:67%;\" />"},{"title":"BionetServer-No1使用说明-进阶（Docker方式）","date":"2024-09-21T12:46:25.000Z","_content":"\n# BionetServer-No1使用说明-进阶（Docker方式）\n\n<img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.3\n\nDocker篇更新记录：\n\n- 添加了常见错误解决方案\n- 添加了复制容器使用说明\n- 修改了镜像使用指南\n- 删除了R部分内容，将在下一个版本重构R说明\n\n\nDate: 2025.9.24\n\nAuthors：魏持之，NeoNexus\n\n<!-- toc -->\n\n[TOC]\n\n\n\n## 开发的最佳实践\n\n开发的最佳实践基于Docker来实现，使用Docker已经成为世界上最重要和流行的开发模式，学习如何使用Docker来进行开发，不管你走到哪里，是科研还是进入互联网大厂，这一套开发方式的部署会让你受益无穷。下面将简单介绍一些基础概念，由于篇幅限制，介绍的不是很详细，但能帮你有一个初步的了解。\n\n**使用Docker的优势：**\n\n- **便于使用者管理环境**\n- **快速在多台部署有Docker基础环境的机器上运行对应程序，可以在不同的机器中迁移运行，无需重复调整开发环境。**\n- **支持集群部署**\n- **root权限**\n- **高性能，容器部署30s内即可完成**\n\n**第一次查看此文档建议按照顺序看，第一创建成功之后建议使用模板方法快速创建。**\n\n### Docker的使用与创建\n\n下图展示了Docker的基本运行原理，其运行在一个基本的操作系统上，并在一个Docker支持多个运行的基本环境。\n\n<img src=\"https://s2.loli.net/2024/01/25/TCh1nqvuyWL6Kp3.png\" alt=\"282c3hci\" style=\"zoom: 50%;\" />\n\n下图展示了传统的VM（虚拟机）架构，是运行在硬件的抽象层之上的，并且每一个虚拟机都有一个操作系统的支持，就是对应的Guest Operating System。\n\n<img src=\"https://s2.loli.net/2024/01/26/qgLmakBI7VMjoS8.png\" alt=\"7d2mwnd9\" style=\"zoom: 50%;\" />\n\n开发的最佳实践主要是在于使用Docker来进行环境的配置和使用。\n\n### image（镜像）和container（容器）的关系\n\n**镜像（Image）**：Docker镜像是一个静态文件，其中包含了应用程序运行所需的所有文件系统内容、库和配置。镜像是一个只读的模板。它可以用来创建一个或多个容器。\n\n**可以简单理解镜像是一个制作好就无法修改的模板**\n\n**容器（Container）**：Docker容器是镜像的运行实例。它实际上是一个独立的、轻量级的、可执行的软件包，包含了运行应用程序所需的一切：代码、运行时、库、环境变量和配置文件。容器可以被创建、启动、停止、删除和移动。每个容器都是相互隔离的，具有自己的文件系统、网络和进程空间。\n\n**容器可以看作一个镜像的动态转变，将其从静态唤醒变成一个应用，可以运行修改。**\n\n下面的状态图，阐述了使用过程中的状态改变：\n\n```mermaid\ngraph TD;\n    A[Docker Image] -- 创建 --> B[Docker Container]\n    B -- 基于 --> A\n    B -- 运行 --> C{应用运行中?}\n    C -- 是 --> D{正常}\n    C -- 否 --> E{已停止}\n    E -- 重启 --> C\n    E -- 删除 --> F[Destroyed Container]\n    D -- 删除 --> F\n\n```\n\n简单理解了容器和镜像的关系，我们可以尝试安装Docker并在Docker部署一个应用，这个应用可以是很多种类型，比如：部署一个可以使用显卡的运行环境（依赖环境也是一种应用）。\n\n### Docker本身的安装\n\n这里不再赘述，可以参考另一篇维护的文章，当中Docker部署的部分。\n\n### 通过portainer构建自己的容器\n\nportainer部署在No1服务器上，**portainer是用来管理所有Docker的管理软件**，同时也部署在Docker之上，使用portainer来创建容器的目的是减少命令的输入，方便用户使用，降低Docker的使用门槛，图形化的管理界面也比较直观的展现了所有容器的信息，减少创建过程的问题，同时Portainer具有服务器集群管理，节点拓展等功能，为以后实验室服务建设添砖加瓦。\n\n首先登录你的[Portainer](https://10.26.58.61:9443/#!/auth)\n\n每个人的账户已经创建好了，需要登陆密码私聊我即可。\n\n目前被部署在：https://10.26.58.61:9443/\n\n使用zerotier的时候地址为：https://10.11.12.166:9443/\n\n**注意端口号为9443**\n\n登录页面如图：\n\n<img src=\"https://s2.loli.net/2024/03/31/xbPwe2hVuviBRaj.png\" alt=\"image-20240331232840271\" style=\"zoom: 50%;\" />\n\n登录之后进入到管理界面：\n\n<img src=\"https://s2.loli.net/2024/03/31/iycUPfqC3osAXjT.png\" alt=\"image-20240331233057783\" style=\"zoom:150%;\" />\n\n点击链接按钮之后，下图就是其管理界面：\n\n<img src=\"https://s2.loli.net/2024/03/31/3C6jqihDFOX8xug.png\" alt=\"image-20240331232721281\" style=\"zoom:150%;\" />\n\n不过这里不是我们的主要目的，我们将目标放到右侧选项栏之中：\n\n<img src=\"https://s2.loli.net/2024/03/31/i2UTrdaMQuIoWR1.png\" alt=\"image-20240331233820435\" style=\"zoom:80%;\" />\n\n对于使用者来说，右侧的状态栏我们只关心这四个内容，Containers、Images、Networks、Volumes，下边将简单介绍一下这四个内容并在介绍的同时创建一个属于你自己的世界（容器）。\n\n#### Images（镜像）\n\n我们先来看一下Images页面，Images中文名称就是镜像，镜像在制作完之后和使用之前是无法更改的，也就是说镜像实际上就是某一套环境的固化版本、无法修改当中的内容，只能使用当中的内容。\n\n<img src=\"https://s2.loli.net/2024/03/31/UaTbB1pQetZsS6H.png\" alt=\"image-20240331235234493\" style=\"zoom:100%;\" />\n\n可以看到我们有一个不太正规命名的pytorch镜像，这是我第一次制作的镜像，我们可以通过一个基本的镜像来详细介绍一下镜像如何使用和创建，我们使用这里最后一个镜像来在nvidia的cudnn运行环境来进行测试。\n\n#### container（容器）\n\n**容器就是镜像运行起来的状态**，这时候镜像内容就由上文中不可修改的状态转变为可修改、可运行、可探查的状态，一个镜像包含了一套完整的运行所需依赖，并由一套自己的文件系统来支持运行，也就说容器和本地服务器是隔离开的、是互相不干扰的，是没有任何关系的（其实并不是，也有一定的逃逸方法，建议大家正常使用就不会遇到这些问题）。\n\n以下为从零开始创建一个新容器，**本文也有直接从一个已有容器复制新容器的使用指南**，但是更推荐看完从零开始创建容器并自己动手跟着操作一遍，遇到问题可以随时联系管理人员。\n\n来到container页面：\n\n![image-20240401002419124](https://s2.loli.net/2024/04/01/MOICl5ZJnrahszp.png)\n\n可以看到没有任何东西，这样我们就需要创建一个container，点右边的按钮来创建：\n\n<img src=\"https://s2.loli.net/2024/04/01/e6PQyo478sNWtnF.png\" alt=\"image-20240401003226298\" style=\"zoom:150%;\" />\n\n上图中演示的是NVIDIA的官方镜像，我这里也制作了几个适合组内任务的镜像，简单介绍下镜像列表如下，请选用**neonexus开头**的：\n\n![image-20251011170438527](https://s2.loli.net/2025/10/11/5nZ781tSY2TJipM.png)\n\n这里以**neonexusx/bionet_deeplearning:cuda121_cudnn9_conda_pytorch_devel_v1.1**这个镜像为例，说明一下名字的含义\n\nneonexusx/bionet代表是Docker hub的仓库所属者，deeplearning代表镜像用途（深度学习），后面的cuda121代表cuda 12.1版本，cudnn9同理，conda代表存在conda虚拟环境，pytorch代表深度学习框架，v1.1是版本号（镜像不定期会更新，可以实时关注下）至于选用哪一个请自行参照上文选择。\n\n设置主机和容器的端口号映射：\n\n<img src=\"https://s2.loli.net/2024/04/01/681u3F5fAKQvpmh.png\" alt=\"image-20240401004019203\"  />\n\n主机可使用的端口号在10086-10199之间，每个人使用的数量不受限制，只需要选择没有占用的即可，这里我占用的是10086，所以别人也无法使用了，但是如何查看别人用了什么端口号呢,使用相同的端口号会导致创建失败。\n\n容器需要使用的端口完全取决你的应用需要，比如R Studio就需要8787端口就需要将R的端口（8787）映射到10086到10199之间任意一个，当你从你的电脑链接的时候只需要选择你当时映射的主机端口号即可，不需要连接的时候选择8787。\n\n这里我建议你多留一个端口比如容器的10087来映射到10087来使用，这样万一有服务需要使用端口我们只需要重新映射一下服务即可，就不要再重新创建一个端口来使用了。\n\n![image-20240401005456274](https://s2.loli.net/2024/04/01/LpzZNdB4kwbmujS.png)\n\n#### 容器的配置\n\n最下面就是容器的详细配置了：\n\n![image-20240401150858895](https://s2.loli.net/2024/04/01/aAvQh2JOW1qe8rc.png)\n\n关于容器的配置这一部分，需要说明的是，大多数容器的配置都是一致的，只需要修改名字即可，填写请按照我给出的内容来填写，第一部分需要配置的比较少，按照图上的内容配置即可。\n\n##### 存储配置\n\n不要照着下面这张图片直接抄，请先看后边的内容：\n\n![image-20240402225643545](https://s2.loli.net/2024/04/02/zMe3tKOEyxlDAnr.png)\n\n**Bind类型不要选错！**\n\n`bind`是绑定本机路径到容器上某个路径之下，实现对应路径的内容在主机和容器之间相互共享的方法。\n\n举个例子：\n\n`type=bind,   source=/home/SoftWares/R_Share    ,    target=/home/R_Share,readonly \\`指的是将主机：`/home/SoftWares/P_Share`目录内容绑定到容器的`/home/R_Share`路径，注意这里的sorce指的是你的服务器本机端、target指的是容器端。\n\n这样这部分就可以互相共享文件，readonly指的是权限为可读，这样的设置当然是为防止你使用某一个数据集的时候有别人来篡改数据，造成你完全无法知晓跑出来的结果。\n\n**同时因为容器是以root权限来运行的，如果不使用readonly来限制很有可能你一条rm命令将大家的数据都删除了，这将造成无法挽回的后果。**\n\n`type=bind,   source=修改这里/Share_Space,      target=/container/path/Share_Space \\`\n\nShare_Space目录就没有只读权限这样的担忧，因为这个主机端的文件夹只有你能访问，这个文件需要你修改`修改这里`这四个字改成你的个人home目录：'/home/Neo/Share_Space '举个例子：\n\n<img src=\"https://s2.loli.net/2024/04/01/4yWVJQOmj82FDXL.png\" alt=\"image-20240401120000975\" style=\"zoom:80%;\" />\n\n##### 存储配置的最佳实践\n\n下图展示了存储配置的最佳实践，需要结合**NAS使用指南**和当前讲解来理解：\n\n```mermaid\ngraph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n    \n    \n    A--\"Datasets文件夹依赖于\"--->C\n    A--\"运行依赖于\"--->B\n    A--\"运行依赖于\"--->F\n    B--\"Datasets文件夹依赖于\"--->C\n    F--\"Datasets文件夹依赖于\"--->C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"--->B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==>C\n    D--\"连接运行\"--->A\n    E--\"数据\"-->D\n```\n\n红色的路径为推荐的上传数据集的方式：详见NAS使用说明。\n\n<img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\" />\n\n当你明白上述目录之后我们来填写上图中的内容，我已经简单写了一份出来，你只要复制其中的路径即可，不要搞错了主机和容器的区别。\n\n```dockerfile\nhost=/home/Datasets\t\t\tcontainer= /home/Datasets,\treadonly \nhost=/home/Neo/Share_Space\t\tcontainer= /home/Share_Space \tWritable\n```\n\n**注意这里的host指的是你的服务器本机端、container指的是容器端**，其他的内容按照图片选择即可。\n\n![image-20250925235253260](https://s2.loli.net/2025/09/25/yFznm7VK8CXNbQc.png)\n\n使用Tensorflow的同学注意需要将上图container的home替换为tf，如下图所示：\n\n![image-20250925235655461](https://s2.loli.net/2025/09/25/7Tsm3VjNaHJuYDz.png)\n\n##### lable配置\n\n![image-20240401121448908](https://s2.loli.net/2024/04/01/4k6VCyMg3izb1JO.png)\n\n##### 重启策略配置\n\n![image-20240401121532287](https://s2.loli.net/2024/04/02/nmW72gZ9DJFeNaA.png)\n\n##### 运行时配置\n\n将页面切换到此处：\n\n![image-20240423222756107](https://s2.loli.net/2024/04/23/ZJtPe1Rhmwj9SV5.png)\n\nshnm大小推荐至少128000MB，最大256000MB，使用多卡或者datakloader数量较多的程序请在16000MB以上。\n\n此处注意，因为有两组成员共用GPU，请bionet课题组使用如下配置：\n\n![image-20240513232522771](https://s2.loli.net/2024/05/13/tS7EbzL9iXdvw43.png)\n\n另外的成员，请使用如下配置：\n\n![image-20240513232551314](https://s2.loli.net/2024/05/13/n2k1jOqLD9EgJwK.png)\n\n最后一定要点击部署！容器才会生效~这个按钮就在基础部分。\n\n![image-20240402211408290](https://s2.loli.net/2024/04/02/MAe4yiPXOl1JLjN.png)\n\n创建完成之后我们就来到这个页面，可以看到容器已经在运行了：\n\n![image-20240401130626984](https://s2.loli.net/2024/04/01/icNmxPz4K8sSJLB.png)\n\n我们点击这里按道理是可以进入命令行的：\n\n![image-20240401151620031](https://s2.loli.net/2024/04/01/gXmcAYVQxflhp1O.png)\n\n![image-20240401151647884](https://s2.loli.net/2024/04/01/1RA7bZYBF5frCwU.png)\n\n同时这里也有容器的监控信息：\n\n![image-20240401151726479](https://s2.loli.net/2024/04/01/CwEZghoUN46szK8.png)\n\n![image-20240401151713327](https://s2.loli.net/2024/04/01/TiVyZEqe8n13c2w.png)\n\n#### Tensorflow使用Jupyter登录\n\nTensorflow环境使用Jupyter来使用，在上述镜像建立完成之后，我们首先找到我们映射的端口信息\n\n![image-20240426190845378](https://s2.loli.net/2024/04/26/5Or2iPdILDE8yae.png)\n\n点击镜像名字查看端口信息:\n\n<img src=\"https://s2.loli.net/2024/04/26/Gm7xojTqlBacEC5.png\" alt=\"image-20240426190920611\" style=\"zoom:50%;\" />\n\n我们这里使用了32768端口来映射Jupyter的8888端口，我们打开浏览器输入：10.26.58.61:32768\n\n![image-20240426191155106](https://s2.loli.net/2024/04/26/Znamz7ysDEvIRt9.png)\n\n建议第一次就设置好密码，输入密码，这样每次就不用单独去查找API_token了\n\n接下来我们去命令行找到token：\n\n![image-20240426191252515](https://s2.loli.net/2024/04/26/lrjHS82MOPuAo1D.png)\n\n![image-20240426191325862](https://s2.loli.net/2024/04/26/yKVCXlfHNc3QGm5.png)\n\n复制对应的token即可使用，也可以选择下边的修改密码来长久登录。Jupyter自带命令行，所以Portainer的界面的命令行无法使用们这里需要注意。\n\n关于Jupyter的使用这里就不再赘述，下面是pytorch的vscode链接方法。\n\n#### 使用已有容器复制\n\n![image-20250925234121499](https://s2.loli.net/2025/09/25/21IdBygZ6mCXn9b.png)\n\n如图所示，example 是按照上面流程创建的标准容器，通过对标准容器的修改可以可以直接使用别人生成好的容器配置，但需要注意的要修改端口，绑定硬盘路径等参数就可以生成符合你的使用需求的一个新容器。具体操作步骤如下，先点击你想要复制的容器（以example为例，下同）\n\n<img src=\"https://s2.loli.net/2025/09/25/SNiZ3e7LGQIofM8.png\" alt=\"image-20250925234406623\" style=\"zoom:67%;\" />\n\n点击Duplicate/Edit，进入如下界面\n\n<img src=\"https://s2.loli.net/2025/09/25/KxNbLFPwIjkYevg.png\" alt=\"image-20250925234659012\" style=\"zoom:67%;\" />\n\n记得点击\n\n![image-20250925234714104](https://s2.loli.net/2025/09/25/QXBf37IZvei5KW2.png)\n\n来保存容器\n\n之后就会得到一个新的容器了\n\n复制容器的好处是简单快捷，可以根据自己的使用场景微调镜像，但是还是推荐大家去看上面的从零开始创建容器的部分，可以深入的了解每个选项的作用，有问题也可以自己简单修复下。\n\n#### 使用VSCode连接容器\n\n下载vscode：[Visual Studio Code - Code Editing. Redefined](https://code.visualstudio.com/)。推荐使用新版。\n\n在连接之前我们先来使用Portainer来重启一下SSH服务，优化conda内容，方便来链接：\n\n我们使用Portainer自带的命令行：\n\n![image-20240402202202138](https://s2.loli.net/2024/04/02/XIogMAGRr7T68NC.png)\n\n点击这里打开容器的命令行。输入以下命令：\n\n```bash\nservice ssh restart && conda init && passwd && mkdir ~/.ssh && touch ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys\n```\n\n**命令行中粘贴快捷键为ctrl+shift+v**，这里减一直接复制以后粘贴。\n\n 命令的效果是修改密码，并增加一些系统设置内容。\n\n效果如下所示：\n\n![image-20240403165653496](https://s2.loli.net/2024/04/03/2BGjlk3HXq4owJp.png)\n\n注意这里修改密码要输入两次才可以，如果有一次和上一次输入的不一致就会失败，如下图所示：\n\n![image-20240403165843033](https://s2.loli.net/2024/04/03/NweW3LbgRA7tfi6.png)\n\n**不用紧张，再次输入上一个命令即可。**然后关闭这个页面。\n\n使用最新版的VSCode，这里下载安装就不再赘述了，打开Vscode之后：\n\n新版的vscoe自带remote链接如图所示：\n\n![image-20240401131807102](https://s2.loli.net/2024/04/01/TWKrERxcZo6lGh8.png)\n\n如果没有的话，请去插件市场安装一个：\n\n选择左侧**Extensions**选项卡，在输入框搜索**ssh**，选择安装**Remote-SSH**插件。这里我已经安装。\n\n![image-20240326113905983](https://s2.loli.net/2024/03/27/9PWEKZISgt6ip2O.png)\n\n安装之后让我们打开远程连接：\n\n<img src=\"https://s2.loli.net/2024/04/01/Wlsw1fQi5GyCdIR.png\" alt=\"image-20240401132035539\" style=\"zoom:50%;\" />\n\n可以看到有两种链接形式的存在：一个是tunnels另一个是SSH，这里选择SSH，点击加号创建新的连接：\n\n![image-20240401132122934](https://s2.loli.net/2024/04/01/H7pbtqXUFvjD9fC.png)\n\n点击之后会让你输入命令：\n\n端口号要更改~\n\n```bash\nssh root@10.26.58.61 -p 10086\n```\n\n**这里的-p指代的是端口号，也就是上文中所设置的端口号映射号，SSH服务默认使用22端口号我们将容器的22端口映射到服务器本机的10086端口，所以这里就要使用10086端口作为链接方式，这样我们只需要连接10086端口就可以连接到容器，注意这里的端口号要和你的容器设置保持一致。**\n\n**这里一定要修改成你的端口！！！！！！！！！！！！！！！！**\n\n**你可能会好奇为什么会是root，而不是其他用户，这里使用的root命令，是因为容器里面的root和主机的root并不一致，这里的root是容器中的管理权限用户，和外边并不相关。**\n\n**在你的容器里面你就是root！**\n\n**然后按下回车：**\n\n![image-20240401132210185](https://s2.loli.net/2024/04/01/u9Sjoazd56pRAVq.png)\n\n**一定要记住这个路径，万一有错误可以用到。**\n\n![image-20240401132414740](https://s2.loli.net/2024/04/01/kKQOC4yH7ftBgmj.png)\n\n然后右下角会弹出链接提示，选择链接：\n\n![image-20240401132647734](https://s2.loli.net/2024/04/01/2vsnJu4chxUjqgm.png)\n\n没有看到没有选择上也没关系，我们刷新一下列表就能看到链接信息了：\n\n![image-20240401132818238](https://s2.loli.net/2024/04/01/JWEOUhqfiLrxRKz.png)\n\n点击链接，输入密码之后开始下载，就说明成功了，容器的root密码为通用的123456：\n\n<img src=\"https://s2.loli.net/2024/04/01/EpvNT7hSaFxJBlc.png\" alt=\"image-20240401163918819\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/01/ymKYnV8FsrICNWA.png\" alt=\"image-20240401163649302\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/01/fCKThcgtrZI6Gzd.png\" alt=\"image-20240401163813111\" style=\"zoom:67%;\" />\n\n一般工作在home文件夹下：\n\n<img src=\"https://s2.loli.net/2024/04/01/j5YDfCvB91iPFcd.png\" alt=\"image-20240401163834329\" style=\"zoom:67%;\" />\n\n可以看到刚才挂载的几个位置：\n\n<img src=\"https://s2.loli.net/2024/04/01/yfx5aT4sM6QhDUb.png\" alt=\"image-20240401163853472\" style=\"zoom:67%;\" />\n\n我们在这里新建一个python脚本来测试：\n\n<img src=\"https://s2.loli.net/2024/04/01/vRESQnmKZ78dV6g.png\" alt=\"image-20240401164016267\" style=\"zoom: 80%;\" />\n\n将以下内容插入：\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport torch.backends.cudnn as cudnn\nfrom torchvision import datasets, transforms\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)\n        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)\n        self.conv2_drop = nn.Dropout2d()\n        self.fc1 = nn.Linear(320, 50)\n        self.fc2 = nn.Linear(50, 10)\n\n\n    def forward(self, x):\n        x = F.relu(F.max_pool2d(self.conv1(x), 2))\n        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))\n        x = x.view(-1, 320)\n        x = F.relu(self.fc1(x))\n        x = F.dropout(x, training=self.training)\n        x = self.fc2(x)\n        return F.log_softmax(x, dim=1)\n\n\ndef train(model, device, train_loader, optimizer, epoch):\n    model.train()\n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = F.nll_loss(output, target)\n        loss.backward()\n        optimizer.step()\n        if batch_idx % 10 == 0:\n            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n                epoch, batch_idx * len(data), len(train_loader.dataset),\n                       100. * batch_idx / len(train_loader), loss.item()))\n\n\ndef main():\n    cudnn.benchmark = True\n    torch.manual_seed(1)\n    device = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n    print(\"Using device: {}\".format(device))\n    kwargs = {'num_workers': 1, 'pin_memory': True}\n    train_loader = torch.utils.data.DataLoader(\n        datasets.MNIST('./data', train=True, download=True,\n                       transform=transforms.Compose([\n                           transforms.ToTensor(),\n                           transforms.Normalize((0.1307,), (0.3081,))\n                       ])),\n        batch_size=64, shuffle=True, **kwargs)\n\n    model = Net().to(device)\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)\n\n    for epoch in range(1, 11):\n        train(model, device, train_loader, optimizer, epoch)\n\nif __name__ == '__main__':\n    main()\n```\n\n新建之后会有右下角来提示安装对应的语言插件：\n\n<img src=\"https://s2.loli.net/2024/04/01/vknM61ilJ5fAdRL.png\" alt=\"image-20240401164200647\" style=\"zoom:80%;\" />\n\n没提示直接搜索也可以，在插件市场搜索：\n\n```txt\n@id:ms-python.python\n```\n\n同时还需要pylance，作为语法检查。\n\n<img src=\"https://s2.loli.net/2024/04/01/sbQwhgcJBERYHxm.png\" alt=\"image-20240401164247045\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2025/10/04/8gZmpbacAX6Hxkt.png\" alt=\"image-20251004234609532\" style=\"zoom: 67%;\" />\n\n然后点击安装在远程即可。\n\n#### 开启代码补全\n\n由于默认的代码补全并不是很好用这里要修改一下设置：\n\n![image-20240402224047196](https://s2.loli.net/2024/04/02/bzmETWanVH6YZ49.png)\n\n同时打开terminal来测试：\n\n<img src=\"https://s2.loli.net/2024/04/01/Zq1fXU98RvWlzYI.png\" alt=\"image-20240401164322474\" style=\"zoom: 67%;\" />\n\n输入命令：`nvidia-smi`\n\n<img src=\"https://s2.loli.net/2024/04/01/LdIuCHcFAz5Dxqo.png\" alt=\"image-20240401164337512\" style=\"zoom:67%;\" />\n\n如图所示，四个显卡都能看见，则创建成功。\n\n使用conda来创建环境，初始化codna：\n\n```bash\nconda init\n```\n\n重新开一个terminal：\n\n![image-20240401164542313](https://s2.loli.net/2024/04/01/qDS9gACboVTuacl.png)\n\n可以看到cnoda已经成功启动了：\n\n![image-20240401164605751](https://s2.loli.net/2024/04/01/BiWUqm79ehoQdJw.png)\n\n在安装之前我们来进行换源，我们将目录切换到这里：\n\n<img src=\"https://s2.loli.net/2024/04/01/Wom9RfSLKHzdqnl.png\" alt=\"image-20240401165118181\" style=\"zoom:80%;\" />\n\n新建一个：\n\n<img src=\"https://s2.loli.net/2024/04/01/5oOPIieFVp7Xvm2.png\" alt=\"image-20240401165149467\" style=\"zoom: 67%;\" />\n\n复制以下内容进去，记得ctrl+s保存：\n\n```bash\nchannels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/\n```\n\n**最近清华源也不太稳定~**，使用后无法下载删除文件恢复默认即可：\n\n使用如下命令清除缓存（想要恢复默认也需要使用这个）\n\n```bash\nconda clean -i\n```\n\n然后，打开一个新的terminal ，看一下conda是否有更新：\n\n使用命令：`conda info`\n\n结果应是如下：\n\n![image-20240401165401775](https://s2.loli.net/2024/04/01/L9oMIZgW6JEk1U5.png)\n\n我们安装一个pytorch来试一试：\n\n```bash\nconda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n```\n\n![image-20240401172245221](https://s2.loli.net/2024/04/01/aqHx1r2QAL4CDFR.png)\n\n点击运行：\n\n这里注意，你的当前目录不一定是你的文件夹，在运行之前要搞明白下方的命令行当前的目录在哪里是不是你想要的位置，因为在python中有很多相对路径要去处理，关于这点我们继续看下一张图：\n\n![image-20240401172544313](https://s2.loli.net/2024/04/01/QkYoVbXgyju13ZS.png)\n\n这里我们使用ls命令：\n\n![image-20240401192341093](https://s2.loli.net/2024/04/01/cLyZJ8p2xjCgqbV.png)\n\n这里MINIST数据集下载到当前文件夹下：\n\n![image-20240401192455633](https://s2.loli.net/2024/04/01/3MslfcPEINVeDFi.png)\n\n那么相对路径是./此时的绝对路径是什么呢？\n\n不错就是命令行前端这一部分，我们打开目录就可以看到，数聚集被下载到了这里：\n\n<img src=\"https://s2.loli.net/2024/04/01/EtfJeChiABw7r91.png\" alt=\"image-20240401192634760\" style=\"zoom:67%;\" />\n\n需要注意的是我们在base环境下安装的pytorch，右下角可以切换当前的解释器：\n\n![image-20240401172633176](https://s2.loli.net/2024/04/01/5EJBFVPhxKejkSw.png)\n\n**注意这里应是cuda**\n\n![image-20240401172730849](https://s2.loli.net/2024/04/01/1YRKaW4BApzJ2Fh.png)\n\n可以看到显卡被占用了：\n\n<img src=\"https://s2.loli.net/2024/04/01/OjzRcpxnSM7F9v1.png\" alt=\"image-20240401172940076\" style=\"zoom:67%;\" />\n\n### 容器的维护\n\n维护自身的容器也非常重要，在运行的时候我们可能建立多个bash，这些bash在切换路径的时候被vscode所遗忘，就会造成内存虚高，这对我们来说是不利的，在运行代码之前，记住一定是运行代码之前，要维护好自己的容器，就少删除一些垃圾bash，使用命令：\n\n```bash\nps -ef | grep shellIntegration-bash.sh\n```\n\n命令显示了多少个bash在运行：\n\n![image-20240401193622108](https://s2.loli.net/2024/04/01/VTCxHhd95vN6iAB.png)\n\n我们保留最后一个数字最大的（因为是当前正在使用的这个，数字越大，创建的时候越靠后）\n\n使用命令杀掉前两个：\n\n```\nkill -9 10970 11173\n```\n\n瞬间清净了~\n\n\n\n#### 开启免密码登录【可选】\n\n开启免密码登录方式如下：\n\n首先打开你的ssh配置文件：\n\n<img src=\"https://s2.loli.net/2024/04/03/dgPwOnKMThcuGAq.png\" alt=\"image-20240403170216864\" style=\"zoom:67%;\" />\n\n打开之后我们先放这里，等下再用。我们把这个路径叫做SSH配置路径，一定要记住这个路径，可以截图。\n\n我们在windos文件管理器中打开这个文件夹：\n\n<img src=\"https://s2.loli.net/2024/04/03/v9sV2CIUkceziL1.png\" alt=\"image-20240403170412513\" style=\"zoom:80%;\" />\n\n这里分为两种情况，一种是你已经有了上述`id_rsa.pub`文件，如上图红框所示。\n\n另一种情况是没有这个文件，如下所示：\n\n<img src=\"https://s2.loli.net/2024/04/03/z48qTZJ75yNMaoL.png\" alt=\"29c9f2a1ef1c58e7deeae3ac742c00f\" style=\"zoom:80%;\" />\n\n如果你没有，我们打开本地的系统命令行：\n\n<img src=\"https://s2.loli.net/2024/04/03/KenW8bEy1gwz9UI.png\" alt=\"image-20240403170517802\" style=\"zoom:80%;\" />\n\n输入以下内容：\n\n```bash\nssh-keygen\n```\n\n<img src=\"https://s2.loli.net/2024/04/03/ivOr8YQgDAbcLq2.png\" alt=\"image-20240403170800926\" style=\"zoom:80%;\" />\n\n这里会提示让你输入密钥文件保存在哪里，这里就要放在你刚才的那个路径的文件下面，就是在vscode设置中打开的路径。记住是文件夹，不是文件，文件夹通常名字为：\".ssh\"。\n\n输入之后一路回车下去直到看到这个图形生成：\n\n<img src=\"https://s2.loli.net/2024/04/03/WmeMaujYiO9Ix6G.png\" alt=\"image-20240403171025319\" style=\"zoom:67%;\" />\n\n这里就结束了，然后我们回过头打开这个文件，使用vscode或者记事本都可以，同时我们也打开远程服务器的这个目录下的文件：\n\n这路径全名是：\n\n```bash\n/root/.ssh/authorized_keys\n```\n\n<img src=\"https://s2.loli.net/2024/04/03/fHrEOVRzybCqh3W.png\" alt=\"image-20240403171155723\" style=\"zoom:67%;\" />\n\n打开之后我们将刚才打开的`id_rsa.pub`文件中的内容复制过来，通常如下图所示：\n\n<img src=\"https://s2.loli.net/2024/04/03/xXeDynObsMYK9Ez.png\" alt=\"image-20240403171427044\" style=\"zoom:80%;\" />\n\n然后我们回到最初打开的ssh配置文件，在你的电脑SSH配置路径上，如果没打开的话，我们还是点击这里打开：\n\n![image-20240403171545385](https://s2.loli.net/2024/04/03/6TcAB2P7SVDQUuC.png)\n\n添加一行内容：\n\n```bash\nIdentityFile \"C:\\Users\\NeoNexus\\.ssh\\id_rsa\"  这里的路径要修改成你的配置路径，要记得这里的id_rsa文件并不带pub后缀因为这是私钥\n```\n\n添加后效果如下：\n\n![image-20240403171709698](https://s2.loli.net/2024/04/03/sVCgWRw4FJBLZtj.png)\n\n记得Ctrl+S保存修改\n\n重启VSCode就可以愉快免密码直接使用了。\n","source":"_posts/Bionet-Server01使用说明 ——Docker篇.md","raw":"---\ntitle: BionetServer-No1使用说明-进阶（Docker方式）\ncategories:\n  - Bionet\ntags:\n  - Bionet\n  - ops\ndate: \"2024/09/21 20:46:25\"\n---\n\n# BionetServer-No1使用说明-进阶（Docker方式）\n\n<img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.3\n\nDocker篇更新记录：\n\n- 添加了常见错误解决方案\n- 添加了复制容器使用说明\n- 修改了镜像使用指南\n- 删除了R部分内容，将在下一个版本重构R说明\n\n\nDate: 2025.9.24\n\nAuthors：魏持之，NeoNexus\n\n<!-- toc -->\n\n[TOC]\n\n\n\n## 开发的最佳实践\n\n开发的最佳实践基于Docker来实现，使用Docker已经成为世界上最重要和流行的开发模式，学习如何使用Docker来进行开发，不管你走到哪里，是科研还是进入互联网大厂，这一套开发方式的部署会让你受益无穷。下面将简单介绍一些基础概念，由于篇幅限制，介绍的不是很详细，但能帮你有一个初步的了解。\n\n**使用Docker的优势：**\n\n- **便于使用者管理环境**\n- **快速在多台部署有Docker基础环境的机器上运行对应程序，可以在不同的机器中迁移运行，无需重复调整开发环境。**\n- **支持集群部署**\n- **root权限**\n- **高性能，容器部署30s内即可完成**\n\n**第一次查看此文档建议按照顺序看，第一创建成功之后建议使用模板方法快速创建。**\n\n### Docker的使用与创建\n\n下图展示了Docker的基本运行原理，其运行在一个基本的操作系统上，并在一个Docker支持多个运行的基本环境。\n\n<img src=\"https://s2.loli.net/2024/01/25/TCh1nqvuyWL6Kp3.png\" alt=\"282c3hci\" style=\"zoom: 50%;\" />\n\n下图展示了传统的VM（虚拟机）架构，是运行在硬件的抽象层之上的，并且每一个虚拟机都有一个操作系统的支持，就是对应的Guest Operating System。\n\n<img src=\"https://s2.loli.net/2024/01/26/qgLmakBI7VMjoS8.png\" alt=\"7d2mwnd9\" style=\"zoom: 50%;\" />\n\n开发的最佳实践主要是在于使用Docker来进行环境的配置和使用。\n\n### image（镜像）和container（容器）的关系\n\n**镜像（Image）**：Docker镜像是一个静态文件，其中包含了应用程序运行所需的所有文件系统内容、库和配置。镜像是一个只读的模板。它可以用来创建一个或多个容器。\n\n**可以简单理解镜像是一个制作好就无法修改的模板**\n\n**容器（Container）**：Docker容器是镜像的运行实例。它实际上是一个独立的、轻量级的、可执行的软件包，包含了运行应用程序所需的一切：代码、运行时、库、环境变量和配置文件。容器可以被创建、启动、停止、删除和移动。每个容器都是相互隔离的，具有自己的文件系统、网络和进程空间。\n\n**容器可以看作一个镜像的动态转变，将其从静态唤醒变成一个应用，可以运行修改。**\n\n下面的状态图，阐述了使用过程中的状态改变：\n\n```mermaid\ngraph TD;\n    A[Docker Image] -- 创建 --> B[Docker Container]\n    B -- 基于 --> A\n    B -- 运行 --> C{应用运行中?}\n    C -- 是 --> D{正常}\n    C -- 否 --> E{已停止}\n    E -- 重启 --> C\n    E -- 删除 --> F[Destroyed Container]\n    D -- 删除 --> F\n\n```\n\n简单理解了容器和镜像的关系，我们可以尝试安装Docker并在Docker部署一个应用，这个应用可以是很多种类型，比如：部署一个可以使用显卡的运行环境（依赖环境也是一种应用）。\n\n### Docker本身的安装\n\n这里不再赘述，可以参考另一篇维护的文章，当中Docker部署的部分。\n\n### 通过portainer构建自己的容器\n\nportainer部署在No1服务器上，**portainer是用来管理所有Docker的管理软件**，同时也部署在Docker之上，使用portainer来创建容器的目的是减少命令的输入，方便用户使用，降低Docker的使用门槛，图形化的管理界面也比较直观的展现了所有容器的信息，减少创建过程的问题，同时Portainer具有服务器集群管理，节点拓展等功能，为以后实验室服务建设添砖加瓦。\n\n首先登录你的[Portainer](https://10.26.58.61:9443/#!/auth)\n\n每个人的账户已经创建好了，需要登陆密码私聊我即可。\n\n目前被部署在：https://10.26.58.61:9443/\n\n使用zerotier的时候地址为：https://10.11.12.166:9443/\n\n**注意端口号为9443**\n\n登录页面如图：\n\n<img src=\"https://s2.loli.net/2024/03/31/xbPwe2hVuviBRaj.png\" alt=\"image-20240331232840271\" style=\"zoom: 50%;\" />\n\n登录之后进入到管理界面：\n\n<img src=\"https://s2.loli.net/2024/03/31/iycUPfqC3osAXjT.png\" alt=\"image-20240331233057783\" style=\"zoom:150%;\" />\n\n点击链接按钮之后，下图就是其管理界面：\n\n<img src=\"https://s2.loli.net/2024/03/31/3C6jqihDFOX8xug.png\" alt=\"image-20240331232721281\" style=\"zoom:150%;\" />\n\n不过这里不是我们的主要目的，我们将目标放到右侧选项栏之中：\n\n<img src=\"https://s2.loli.net/2024/03/31/i2UTrdaMQuIoWR1.png\" alt=\"image-20240331233820435\" style=\"zoom:80%;\" />\n\n对于使用者来说，右侧的状态栏我们只关心这四个内容，Containers、Images、Networks、Volumes，下边将简单介绍一下这四个内容并在介绍的同时创建一个属于你自己的世界（容器）。\n\n#### Images（镜像）\n\n我们先来看一下Images页面，Images中文名称就是镜像，镜像在制作完之后和使用之前是无法更改的，也就是说镜像实际上就是某一套环境的固化版本、无法修改当中的内容，只能使用当中的内容。\n\n<img src=\"https://s2.loli.net/2024/03/31/UaTbB1pQetZsS6H.png\" alt=\"image-20240331235234493\" style=\"zoom:100%;\" />\n\n可以看到我们有一个不太正规命名的pytorch镜像，这是我第一次制作的镜像，我们可以通过一个基本的镜像来详细介绍一下镜像如何使用和创建，我们使用这里最后一个镜像来在nvidia的cudnn运行环境来进行测试。\n\n#### container（容器）\n\n**容器就是镜像运行起来的状态**，这时候镜像内容就由上文中不可修改的状态转变为可修改、可运行、可探查的状态，一个镜像包含了一套完整的运行所需依赖，并由一套自己的文件系统来支持运行，也就说容器和本地服务器是隔离开的、是互相不干扰的，是没有任何关系的（其实并不是，也有一定的逃逸方法，建议大家正常使用就不会遇到这些问题）。\n\n以下为从零开始创建一个新容器，**本文也有直接从一个已有容器复制新容器的使用指南**，但是更推荐看完从零开始创建容器并自己动手跟着操作一遍，遇到问题可以随时联系管理人员。\n\n来到container页面：\n\n![image-20240401002419124](https://s2.loli.net/2024/04/01/MOICl5ZJnrahszp.png)\n\n可以看到没有任何东西，这样我们就需要创建一个container，点右边的按钮来创建：\n\n<img src=\"https://s2.loli.net/2024/04/01/e6PQyo478sNWtnF.png\" alt=\"image-20240401003226298\" style=\"zoom:150%;\" />\n\n上图中演示的是NVIDIA的官方镜像，我这里也制作了几个适合组内任务的镜像，简单介绍下镜像列表如下，请选用**neonexus开头**的：\n\n![image-20251011170438527](https://s2.loli.net/2025/10/11/5nZ781tSY2TJipM.png)\n\n这里以**neonexusx/bionet_deeplearning:cuda121_cudnn9_conda_pytorch_devel_v1.1**这个镜像为例，说明一下名字的含义\n\nneonexusx/bionet代表是Docker hub的仓库所属者，deeplearning代表镜像用途（深度学习），后面的cuda121代表cuda 12.1版本，cudnn9同理，conda代表存在conda虚拟环境，pytorch代表深度学习框架，v1.1是版本号（镜像不定期会更新，可以实时关注下）至于选用哪一个请自行参照上文选择。\n\n设置主机和容器的端口号映射：\n\n<img src=\"https://s2.loli.net/2024/04/01/681u3F5fAKQvpmh.png\" alt=\"image-20240401004019203\"  />\n\n主机可使用的端口号在10086-10199之间，每个人使用的数量不受限制，只需要选择没有占用的即可，这里我占用的是10086，所以别人也无法使用了，但是如何查看别人用了什么端口号呢,使用相同的端口号会导致创建失败。\n\n容器需要使用的端口完全取决你的应用需要，比如R Studio就需要8787端口就需要将R的端口（8787）映射到10086到10199之间任意一个，当你从你的电脑链接的时候只需要选择你当时映射的主机端口号即可，不需要连接的时候选择8787。\n\n这里我建议你多留一个端口比如容器的10087来映射到10087来使用，这样万一有服务需要使用端口我们只需要重新映射一下服务即可，就不要再重新创建一个端口来使用了。\n\n![image-20240401005456274](https://s2.loli.net/2024/04/01/LpzZNdB4kwbmujS.png)\n\n#### 容器的配置\n\n最下面就是容器的详细配置了：\n\n![image-20240401150858895](https://s2.loli.net/2024/04/01/aAvQh2JOW1qe8rc.png)\n\n关于容器的配置这一部分，需要说明的是，大多数容器的配置都是一致的，只需要修改名字即可，填写请按照我给出的内容来填写，第一部分需要配置的比较少，按照图上的内容配置即可。\n\n##### 存储配置\n\n不要照着下面这张图片直接抄，请先看后边的内容：\n\n![image-20240402225643545](https://s2.loli.net/2024/04/02/zMe3tKOEyxlDAnr.png)\n\n**Bind类型不要选错！**\n\n`bind`是绑定本机路径到容器上某个路径之下，实现对应路径的内容在主机和容器之间相互共享的方法。\n\n举个例子：\n\n`type=bind,   source=/home/SoftWares/R_Share    ,    target=/home/R_Share,readonly \\`指的是将主机：`/home/SoftWares/P_Share`目录内容绑定到容器的`/home/R_Share`路径，注意这里的sorce指的是你的服务器本机端、target指的是容器端。\n\n这样这部分就可以互相共享文件，readonly指的是权限为可读，这样的设置当然是为防止你使用某一个数据集的时候有别人来篡改数据，造成你完全无法知晓跑出来的结果。\n\n**同时因为容器是以root权限来运行的，如果不使用readonly来限制很有可能你一条rm命令将大家的数据都删除了，这将造成无法挽回的后果。**\n\n`type=bind,   source=修改这里/Share_Space,      target=/container/path/Share_Space \\`\n\nShare_Space目录就没有只读权限这样的担忧，因为这个主机端的文件夹只有你能访问，这个文件需要你修改`修改这里`这四个字改成你的个人home目录：'/home/Neo/Share_Space '举个例子：\n\n<img src=\"https://s2.loli.net/2024/04/01/4yWVJQOmj82FDXL.png\" alt=\"image-20240401120000975\" style=\"zoom:80%;\" />\n\n##### 存储配置的最佳实践\n\n下图展示了存储配置的最佳实践，需要结合**NAS使用指南**和当前讲解来理解：\n\n```mermaid\ngraph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n    \n    \n    A--\"Datasets文件夹依赖于\"--->C\n    A--\"运行依赖于\"--->B\n    A--\"运行依赖于\"--->F\n    B--\"Datasets文件夹依赖于\"--->C\n    F--\"Datasets文件夹依赖于\"--->C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"--->B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==>C\n    D--\"连接运行\"--->A\n    E--\"数据\"-->D\n```\n\n红色的路径为推荐的上传数据集的方式：详见NAS使用说明。\n\n<img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\" />\n\n当你明白上述目录之后我们来填写上图中的内容，我已经简单写了一份出来，你只要复制其中的路径即可，不要搞错了主机和容器的区别。\n\n```dockerfile\nhost=/home/Datasets\t\t\tcontainer= /home/Datasets,\treadonly \nhost=/home/Neo/Share_Space\t\tcontainer= /home/Share_Space \tWritable\n```\n\n**注意这里的host指的是你的服务器本机端、container指的是容器端**，其他的内容按照图片选择即可。\n\n![image-20250925235253260](https://s2.loli.net/2025/09/25/yFznm7VK8CXNbQc.png)\n\n使用Tensorflow的同学注意需要将上图container的home替换为tf，如下图所示：\n\n![image-20250925235655461](https://s2.loli.net/2025/09/25/7Tsm3VjNaHJuYDz.png)\n\n##### lable配置\n\n![image-20240401121448908](https://s2.loli.net/2024/04/01/4k6VCyMg3izb1JO.png)\n\n##### 重启策略配置\n\n![image-20240401121532287](https://s2.loli.net/2024/04/02/nmW72gZ9DJFeNaA.png)\n\n##### 运行时配置\n\n将页面切换到此处：\n\n![image-20240423222756107](https://s2.loli.net/2024/04/23/ZJtPe1Rhmwj9SV5.png)\n\nshnm大小推荐至少128000MB，最大256000MB，使用多卡或者datakloader数量较多的程序请在16000MB以上。\n\n此处注意，因为有两组成员共用GPU，请bionet课题组使用如下配置：\n\n![image-20240513232522771](https://s2.loli.net/2024/05/13/tS7EbzL9iXdvw43.png)\n\n另外的成员，请使用如下配置：\n\n![image-20240513232551314](https://s2.loli.net/2024/05/13/n2k1jOqLD9EgJwK.png)\n\n最后一定要点击部署！容器才会生效~这个按钮就在基础部分。\n\n![image-20240402211408290](https://s2.loli.net/2024/04/02/MAe4yiPXOl1JLjN.png)\n\n创建完成之后我们就来到这个页面，可以看到容器已经在运行了：\n\n![image-20240401130626984](https://s2.loli.net/2024/04/01/icNmxPz4K8sSJLB.png)\n\n我们点击这里按道理是可以进入命令行的：\n\n![image-20240401151620031](https://s2.loli.net/2024/04/01/gXmcAYVQxflhp1O.png)\n\n![image-20240401151647884](https://s2.loli.net/2024/04/01/1RA7bZYBF5frCwU.png)\n\n同时这里也有容器的监控信息：\n\n![image-20240401151726479](https://s2.loli.net/2024/04/01/CwEZghoUN46szK8.png)\n\n![image-20240401151713327](https://s2.loli.net/2024/04/01/TiVyZEqe8n13c2w.png)\n\n#### Tensorflow使用Jupyter登录\n\nTensorflow环境使用Jupyter来使用，在上述镜像建立完成之后，我们首先找到我们映射的端口信息\n\n![image-20240426190845378](https://s2.loli.net/2024/04/26/5Or2iPdILDE8yae.png)\n\n点击镜像名字查看端口信息:\n\n<img src=\"https://s2.loli.net/2024/04/26/Gm7xojTqlBacEC5.png\" alt=\"image-20240426190920611\" style=\"zoom:50%;\" />\n\n我们这里使用了32768端口来映射Jupyter的8888端口，我们打开浏览器输入：10.26.58.61:32768\n\n![image-20240426191155106](https://s2.loli.net/2024/04/26/Znamz7ysDEvIRt9.png)\n\n建议第一次就设置好密码，输入密码，这样每次就不用单独去查找API_token了\n\n接下来我们去命令行找到token：\n\n![image-20240426191252515](https://s2.loli.net/2024/04/26/lrjHS82MOPuAo1D.png)\n\n![image-20240426191325862](https://s2.loli.net/2024/04/26/yKVCXlfHNc3QGm5.png)\n\n复制对应的token即可使用，也可以选择下边的修改密码来长久登录。Jupyter自带命令行，所以Portainer的界面的命令行无法使用们这里需要注意。\n\n关于Jupyter的使用这里就不再赘述，下面是pytorch的vscode链接方法。\n\n#### 使用已有容器复制\n\n![image-20250925234121499](https://s2.loli.net/2025/09/25/21IdBygZ6mCXn9b.png)\n\n如图所示，example 是按照上面流程创建的标准容器，通过对标准容器的修改可以可以直接使用别人生成好的容器配置，但需要注意的要修改端口，绑定硬盘路径等参数就可以生成符合你的使用需求的一个新容器。具体操作步骤如下，先点击你想要复制的容器（以example为例，下同）\n\n<img src=\"https://s2.loli.net/2025/09/25/SNiZ3e7LGQIofM8.png\" alt=\"image-20250925234406623\" style=\"zoom:67%;\" />\n\n点击Duplicate/Edit，进入如下界面\n\n<img src=\"https://s2.loli.net/2025/09/25/KxNbLFPwIjkYevg.png\" alt=\"image-20250925234659012\" style=\"zoom:67%;\" />\n\n记得点击\n\n![image-20250925234714104](https://s2.loli.net/2025/09/25/QXBf37IZvei5KW2.png)\n\n来保存容器\n\n之后就会得到一个新的容器了\n\n复制容器的好处是简单快捷，可以根据自己的使用场景微调镜像，但是还是推荐大家去看上面的从零开始创建容器的部分，可以深入的了解每个选项的作用，有问题也可以自己简单修复下。\n\n#### 使用VSCode连接容器\n\n下载vscode：[Visual Studio Code - Code Editing. Redefined](https://code.visualstudio.com/)。推荐使用新版。\n\n在连接之前我们先来使用Portainer来重启一下SSH服务，优化conda内容，方便来链接：\n\n我们使用Portainer自带的命令行：\n\n![image-20240402202202138](https://s2.loli.net/2024/04/02/XIogMAGRr7T68NC.png)\n\n点击这里打开容器的命令行。输入以下命令：\n\n```bash\nservice ssh restart && conda init && passwd && mkdir ~/.ssh && touch ~/.ssh/authorized_keys && chmod 700 ~/.ssh && chmod 600 ~/.ssh/authorized_keys\n```\n\n**命令行中粘贴快捷键为ctrl+shift+v**，这里减一直接复制以后粘贴。\n\n 命令的效果是修改密码，并增加一些系统设置内容。\n\n效果如下所示：\n\n![image-20240403165653496](https://s2.loli.net/2024/04/03/2BGjlk3HXq4owJp.png)\n\n注意这里修改密码要输入两次才可以，如果有一次和上一次输入的不一致就会失败，如下图所示：\n\n![image-20240403165843033](https://s2.loli.net/2024/04/03/NweW3LbgRA7tfi6.png)\n\n**不用紧张，再次输入上一个命令即可。**然后关闭这个页面。\n\n使用最新版的VSCode，这里下载安装就不再赘述了，打开Vscode之后：\n\n新版的vscoe自带remote链接如图所示：\n\n![image-20240401131807102](https://s2.loli.net/2024/04/01/TWKrERxcZo6lGh8.png)\n\n如果没有的话，请去插件市场安装一个：\n\n选择左侧**Extensions**选项卡，在输入框搜索**ssh**，选择安装**Remote-SSH**插件。这里我已经安装。\n\n![image-20240326113905983](https://s2.loli.net/2024/03/27/9PWEKZISgt6ip2O.png)\n\n安装之后让我们打开远程连接：\n\n<img src=\"https://s2.loli.net/2024/04/01/Wlsw1fQi5GyCdIR.png\" alt=\"image-20240401132035539\" style=\"zoom:50%;\" />\n\n可以看到有两种链接形式的存在：一个是tunnels另一个是SSH，这里选择SSH，点击加号创建新的连接：\n\n![image-20240401132122934](https://s2.loli.net/2024/04/01/H7pbtqXUFvjD9fC.png)\n\n点击之后会让你输入命令：\n\n端口号要更改~\n\n```bash\nssh root@10.26.58.61 -p 10086\n```\n\n**这里的-p指代的是端口号，也就是上文中所设置的端口号映射号，SSH服务默认使用22端口号我们将容器的22端口映射到服务器本机的10086端口，所以这里就要使用10086端口作为链接方式，这样我们只需要连接10086端口就可以连接到容器，注意这里的端口号要和你的容器设置保持一致。**\n\n**这里一定要修改成你的端口！！！！！！！！！！！！！！！！**\n\n**你可能会好奇为什么会是root，而不是其他用户，这里使用的root命令，是因为容器里面的root和主机的root并不一致，这里的root是容器中的管理权限用户，和外边并不相关。**\n\n**在你的容器里面你就是root！**\n\n**然后按下回车：**\n\n![image-20240401132210185](https://s2.loli.net/2024/04/01/u9Sjoazd56pRAVq.png)\n\n**一定要记住这个路径，万一有错误可以用到。**\n\n![image-20240401132414740](https://s2.loli.net/2024/04/01/kKQOC4yH7ftBgmj.png)\n\n然后右下角会弹出链接提示，选择链接：\n\n![image-20240401132647734](https://s2.loli.net/2024/04/01/2vsnJu4chxUjqgm.png)\n\n没有看到没有选择上也没关系，我们刷新一下列表就能看到链接信息了：\n\n![image-20240401132818238](https://s2.loli.net/2024/04/01/JWEOUhqfiLrxRKz.png)\n\n点击链接，输入密码之后开始下载，就说明成功了，容器的root密码为通用的123456：\n\n<img src=\"https://s2.loli.net/2024/04/01/EpvNT7hSaFxJBlc.png\" alt=\"image-20240401163918819\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/01/ymKYnV8FsrICNWA.png\" alt=\"image-20240401163649302\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/01/fCKThcgtrZI6Gzd.png\" alt=\"image-20240401163813111\" style=\"zoom:67%;\" />\n\n一般工作在home文件夹下：\n\n<img src=\"https://s2.loli.net/2024/04/01/j5YDfCvB91iPFcd.png\" alt=\"image-20240401163834329\" style=\"zoom:67%;\" />\n\n可以看到刚才挂载的几个位置：\n\n<img src=\"https://s2.loli.net/2024/04/01/yfx5aT4sM6QhDUb.png\" alt=\"image-20240401163853472\" style=\"zoom:67%;\" />\n\n我们在这里新建一个python脚本来测试：\n\n<img src=\"https://s2.loli.net/2024/04/01/vRESQnmKZ78dV6g.png\" alt=\"image-20240401164016267\" style=\"zoom: 80%;\" />\n\n将以下内容插入：\n\n```python\nimport torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport torch.backends.cudnn as cudnn\nfrom torchvision import datasets, transforms\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)\n        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)\n        self.conv2_drop = nn.Dropout2d()\n        self.fc1 = nn.Linear(320, 50)\n        self.fc2 = nn.Linear(50, 10)\n\n\n    def forward(self, x):\n        x = F.relu(F.max_pool2d(self.conv1(x), 2))\n        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))\n        x = x.view(-1, 320)\n        x = F.relu(self.fc1(x))\n        x = F.dropout(x, training=self.training)\n        x = self.fc2(x)\n        return F.log_softmax(x, dim=1)\n\n\ndef train(model, device, train_loader, optimizer, epoch):\n    model.train()\n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = F.nll_loss(output, target)\n        loss.backward()\n        optimizer.step()\n        if batch_idx % 10 == 0:\n            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n                epoch, batch_idx * len(data), len(train_loader.dataset),\n                       100. * batch_idx / len(train_loader), loss.item()))\n\n\ndef main():\n    cudnn.benchmark = True\n    torch.manual_seed(1)\n    device = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n    print(\"Using device: {}\".format(device))\n    kwargs = {'num_workers': 1, 'pin_memory': True}\n    train_loader = torch.utils.data.DataLoader(\n        datasets.MNIST('./data', train=True, download=True,\n                       transform=transforms.Compose([\n                           transforms.ToTensor(),\n                           transforms.Normalize((0.1307,), (0.3081,))\n                       ])),\n        batch_size=64, shuffle=True, **kwargs)\n\n    model = Net().to(device)\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)\n\n    for epoch in range(1, 11):\n        train(model, device, train_loader, optimizer, epoch)\n\nif __name__ == '__main__':\n    main()\n```\n\n新建之后会有右下角来提示安装对应的语言插件：\n\n<img src=\"https://s2.loli.net/2024/04/01/vknM61ilJ5fAdRL.png\" alt=\"image-20240401164200647\" style=\"zoom:80%;\" />\n\n没提示直接搜索也可以，在插件市场搜索：\n\n```txt\n@id:ms-python.python\n```\n\n同时还需要pylance，作为语法检查。\n\n<img src=\"https://s2.loli.net/2024/04/01/sbQwhgcJBERYHxm.png\" alt=\"image-20240401164247045\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2025/10/04/8gZmpbacAX6Hxkt.png\" alt=\"image-20251004234609532\" style=\"zoom: 67%;\" />\n\n然后点击安装在远程即可。\n\n#### 开启代码补全\n\n由于默认的代码补全并不是很好用这里要修改一下设置：\n\n![image-20240402224047196](https://s2.loli.net/2024/04/02/bzmETWanVH6YZ49.png)\n\n同时打开terminal来测试：\n\n<img src=\"https://s2.loli.net/2024/04/01/Zq1fXU98RvWlzYI.png\" alt=\"image-20240401164322474\" style=\"zoom: 67%;\" />\n\n输入命令：`nvidia-smi`\n\n<img src=\"https://s2.loli.net/2024/04/01/LdIuCHcFAz5Dxqo.png\" alt=\"image-20240401164337512\" style=\"zoom:67%;\" />\n\n如图所示，四个显卡都能看见，则创建成功。\n\n使用conda来创建环境，初始化codna：\n\n```bash\nconda init\n```\n\n重新开一个terminal：\n\n![image-20240401164542313](https://s2.loli.net/2024/04/01/qDS9gACboVTuacl.png)\n\n可以看到cnoda已经成功启动了：\n\n![image-20240401164605751](https://s2.loli.net/2024/04/01/BiWUqm79ehoQdJw.png)\n\n在安装之前我们来进行换源，我们将目录切换到这里：\n\n<img src=\"https://s2.loli.net/2024/04/01/Wom9RfSLKHzdqnl.png\" alt=\"image-20240401165118181\" style=\"zoom:80%;\" />\n\n新建一个：\n\n<img src=\"https://s2.loli.net/2024/04/01/5oOPIieFVp7Xvm2.png\" alt=\"image-20240401165149467\" style=\"zoom: 67%;\" />\n\n复制以下内容进去，记得ctrl+s保存：\n\n```bash\nchannels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/\n```\n\n**最近清华源也不太稳定~**，使用后无法下载删除文件恢复默认即可：\n\n使用如下命令清除缓存（想要恢复默认也需要使用这个）\n\n```bash\nconda clean -i\n```\n\n然后，打开一个新的terminal ，看一下conda是否有更新：\n\n使用命令：`conda info`\n\n结果应是如下：\n\n![image-20240401165401775](https://s2.loli.net/2024/04/01/L9oMIZgW6JEk1U5.png)\n\n我们安装一个pytorch来试一试：\n\n```bash\nconda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n```\n\n![image-20240401172245221](https://s2.loli.net/2024/04/01/aqHx1r2QAL4CDFR.png)\n\n点击运行：\n\n这里注意，你的当前目录不一定是你的文件夹，在运行之前要搞明白下方的命令行当前的目录在哪里是不是你想要的位置，因为在python中有很多相对路径要去处理，关于这点我们继续看下一张图：\n\n![image-20240401172544313](https://s2.loli.net/2024/04/01/QkYoVbXgyju13ZS.png)\n\n这里我们使用ls命令：\n\n![image-20240401192341093](https://s2.loli.net/2024/04/01/cLyZJ8p2xjCgqbV.png)\n\n这里MINIST数据集下载到当前文件夹下：\n\n![image-20240401192455633](https://s2.loli.net/2024/04/01/3MslfcPEINVeDFi.png)\n\n那么相对路径是./此时的绝对路径是什么呢？\n\n不错就是命令行前端这一部分，我们打开目录就可以看到，数聚集被下载到了这里：\n\n<img src=\"https://s2.loli.net/2024/04/01/EtfJeChiABw7r91.png\" alt=\"image-20240401192634760\" style=\"zoom:67%;\" />\n\n需要注意的是我们在base环境下安装的pytorch，右下角可以切换当前的解释器：\n\n![image-20240401172633176](https://s2.loli.net/2024/04/01/5EJBFVPhxKejkSw.png)\n\n**注意这里应是cuda**\n\n![image-20240401172730849](https://s2.loli.net/2024/04/01/1YRKaW4BApzJ2Fh.png)\n\n可以看到显卡被占用了：\n\n<img src=\"https://s2.loli.net/2024/04/01/OjzRcpxnSM7F9v1.png\" alt=\"image-20240401172940076\" style=\"zoom:67%;\" />\n\n### 容器的维护\n\n维护自身的容器也非常重要，在运行的时候我们可能建立多个bash，这些bash在切换路径的时候被vscode所遗忘，就会造成内存虚高，这对我们来说是不利的，在运行代码之前，记住一定是运行代码之前，要维护好自己的容器，就少删除一些垃圾bash，使用命令：\n\n```bash\nps -ef | grep shellIntegration-bash.sh\n```\n\n命令显示了多少个bash在运行：\n\n![image-20240401193622108](https://s2.loli.net/2024/04/01/VTCxHhd95vN6iAB.png)\n\n我们保留最后一个数字最大的（因为是当前正在使用的这个，数字越大，创建的时候越靠后）\n\n使用命令杀掉前两个：\n\n```\nkill -9 10970 11173\n```\n\n瞬间清净了~\n\n\n\n#### 开启免密码登录【可选】\n\n开启免密码登录方式如下：\n\n首先打开你的ssh配置文件：\n\n<img src=\"https://s2.loli.net/2024/04/03/dgPwOnKMThcuGAq.png\" alt=\"image-20240403170216864\" style=\"zoom:67%;\" />\n\n打开之后我们先放这里，等下再用。我们把这个路径叫做SSH配置路径，一定要记住这个路径，可以截图。\n\n我们在windos文件管理器中打开这个文件夹：\n\n<img src=\"https://s2.loli.net/2024/04/03/v9sV2CIUkceziL1.png\" alt=\"image-20240403170412513\" style=\"zoom:80%;\" />\n\n这里分为两种情况，一种是你已经有了上述`id_rsa.pub`文件，如上图红框所示。\n\n另一种情况是没有这个文件，如下所示：\n\n<img src=\"https://s2.loli.net/2024/04/03/z48qTZJ75yNMaoL.png\" alt=\"29c9f2a1ef1c58e7deeae3ac742c00f\" style=\"zoom:80%;\" />\n\n如果你没有，我们打开本地的系统命令行：\n\n<img src=\"https://s2.loli.net/2024/04/03/KenW8bEy1gwz9UI.png\" alt=\"image-20240403170517802\" style=\"zoom:80%;\" />\n\n输入以下内容：\n\n```bash\nssh-keygen\n```\n\n<img src=\"https://s2.loli.net/2024/04/03/ivOr8YQgDAbcLq2.png\" alt=\"image-20240403170800926\" style=\"zoom:80%;\" />\n\n这里会提示让你输入密钥文件保存在哪里，这里就要放在你刚才的那个路径的文件下面，就是在vscode设置中打开的路径。记住是文件夹，不是文件，文件夹通常名字为：\".ssh\"。\n\n输入之后一路回车下去直到看到这个图形生成：\n\n<img src=\"https://s2.loli.net/2024/04/03/WmeMaujYiO9Ix6G.png\" alt=\"image-20240403171025319\" style=\"zoom:67%;\" />\n\n这里就结束了，然后我们回过头打开这个文件，使用vscode或者记事本都可以，同时我们也打开远程服务器的这个目录下的文件：\n\n这路径全名是：\n\n```bash\n/root/.ssh/authorized_keys\n```\n\n<img src=\"https://s2.loli.net/2024/04/03/fHrEOVRzybCqh3W.png\" alt=\"image-20240403171155723\" style=\"zoom:67%;\" />\n\n打开之后我们将刚才打开的`id_rsa.pub`文件中的内容复制过来，通常如下图所示：\n\n<img src=\"https://s2.loli.net/2024/04/03/xXeDynObsMYK9Ez.png\" alt=\"image-20240403171427044\" style=\"zoom:80%;\" />\n\n然后我们回到最初打开的ssh配置文件，在你的电脑SSH配置路径上，如果没打开的话，我们还是点击这里打开：\n\n![image-20240403171545385](https://s2.loli.net/2024/04/03/6TcAB2P7SVDQUuC.png)\n\n添加一行内容：\n\n```bash\nIdentityFile \"C:\\Users\\NeoNexus\\.ssh\\id_rsa\"  这里的路径要修改成你的配置路径，要记得这里的id_rsa文件并不带pub后缀因为这是私钥\n```\n\n添加后效果如下：\n\n![image-20240403171709698](https://s2.loli.net/2024/04/03/sVCgWRw4FJBLZtj.png)\n\n记得Ctrl+S保存修改\n\n重启VSCode就可以愉快免密码直接使用了。\n","slug":"Bionet-Server01使用说明 ——Docker篇","published":1,"updated":"2025-10-11T09:28:45.074Z","_id":"cm3zcti06001qyjinbw52gp3o","comments":1,"layout":"post","photos":[],"content":"<h1><span id=\"bionetserver-no1使用说明-进阶docker方式\">BionetServer-No1使用说明-进阶（Docker方式）</span></h1><p><img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\"></p>\n<p><img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\"></p>\n<p>Version:1.3</p>\n<p>Docker篇更新记录：</p>\n<ul>\n<li>添加了常见错误解决方案</li>\n<li>添加了复制容器使用说明</li>\n<li>修改了镜像使用指南</li>\n<li>删除了R部分内容，将在下一个版本重构R说明</li>\n</ul>\n<p>Date: 2025.9.24</p>\n<p>Authors：魏持之，NeoNexus</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#开发的最佳实践\">开发的最佳实践</a><ul>\n<li><a href=\"#docker的使用与创建\">Docker的使用与创建</a></li>\n<li><a href=\"#image镜像和container容器的关系\">image（镜像）和container（容器）的关系</a></li>\n<li><a href=\"#docker本身的安装\">Docker本身的安装</a></li>\n<li><a href=\"#通过portainer构建自己的容器\">通过portainer构建自己的容器</a><ul>\n<li><a href=\"#images镜像\">Images（镜像）</a></li>\n<li><a href=\"#container容器\">container（容器）</a></li>\n<li><a href=\"#容器的配置\">容器的配置</a><ul>\n<li><a href=\"#存储配置\">存储配置</a></li>\n<li><a href=\"#存储配置的最佳实践\">存储配置的最佳实践</a></li>\n<li><a href=\"#lable配置\">lable配置</a></li>\n<li><a href=\"#重启策略配置\">重启策略配置</a></li>\n<li><a href=\"#运行时配置\">运行时配置</a></li>\n</ul>\n</li>\n<li><a href=\"#tensorflow使用jupyter登录\">Tensorflow使用Jupyter登录</a></li>\n<li><a href=\"#使用已有容器复制\">使用已有容器复制</a></li>\n<li><a href=\"#使用vscode连接容器\">使用VSCode连接容器</a></li>\n<li><a href=\"#开启代码补全\">开启代码补全</a></li>\n</ul>\n</li>\n<li><a href=\"#容器的维护\">容器的维护</a><ul>\n<li><a href=\"#开启免密码登录可选\">开启免密码登录【可选】</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2><span id=\"开发的最佳实践\">开发的最佳实践</span></h2><p>开发的最佳实践基于Docker来实现，使用Docker已经成为世界上最重要和流行的开发模式，学习如何使用Docker来进行开发，不管你走到哪里，是科研还是进入互联网大厂，这一套开发方式的部署会让你受益无穷。下面将简单介绍一些基础概念，由于篇幅限制，介绍的不是很详细，但能帮你有一个初步的了解。</p>\n<p><strong>使用Docker的优势：</strong></p>\n<ul>\n<li><strong>便于使用者管理环境</strong></li>\n<li><strong>快速在多台部署有Docker基础环境的机器上运行对应程序，可以在不同的机器中迁移运行，无需重复调整开发环境。</strong></li>\n<li><strong>支持集群部署</strong></li>\n<li><strong>root权限</strong></li>\n<li><strong>高性能，容器部署30s内即可完成</strong></li>\n</ul>\n<p><strong>第一次查看此文档建议按照顺序看，第一创建成功之后建议使用模板方法快速创建。</strong></p>\n<h3><span id=\"docker的使用与创建\">Docker的使用与创建</span></h3><p>下图展示了Docker的基本运行原理，其运行在一个基本的操作系统上，并在一个Docker支持多个运行的基本环境。</p>\n<p><img src=\"https://s2.loli.net/2024/01/25/TCh1nqvuyWL6Kp3.png\" alt=\"282c3hci\" style=\"zoom: 50%;\"></p>\n<p>下图展示了传统的VM（虚拟机）架构，是运行在硬件的抽象层之上的，并且每一个虚拟机都有一个操作系统的支持，就是对应的Guest Operating System。</p>\n<p><img src=\"https://s2.loli.net/2024/01/26/qgLmakBI7VMjoS8.png\" alt=\"7d2mwnd9\" style=\"zoom: 50%;\"></p>\n<p>开发的最佳实践主要是在于使用Docker来进行环境的配置和使用。</p>\n<h3><span id=\"image镜像和container容器的关系\">image（镜像）和container（容器）的关系</span></h3><p><strong>镜像（Image）</strong>：Docker镜像是一个静态文件，其中包含了应用程序运行所需的所有文件系统内容、库和配置。镜像是一个只读的模板。它可以用来创建一个或多个容器。</p>\n<p><strong>可以简单理解镜像是一个制作好就无法修改的模板</strong></p>\n<p><strong>容器（Container）</strong>：Docker容器是镜像的运行实例。它实际上是一个独立的、轻量级的、可执行的软件包，包含了运行应用程序所需的一切：代码、运行时、库、环境变量和配置文件。容器可以被创建、启动、停止、删除和移动。每个容器都是相互隔离的，具有自己的文件系统、网络和进程空间。</p>\n<p><strong>容器可以看作一个镜像的动态转变，将其从静态唤醒变成一个应用，可以运行修改。</strong></p>\n<p>下面的状态图，阐述了使用过程中的状态改变：</p>\n<pre class=\"mermaid\">graph TD;\n    A[Docker Image] -- 创建 --&gt; B[Docker Container]\n    B -- 基于 --&gt; A\n    B -- 运行 --&gt; C{应用运行中?}\n    C -- 是 --&gt; D{正常}\n    C -- 否 --&gt; E{已停止}\n    E -- 重启 --&gt; C\n    E -- 删除 --&gt; F[Destroyed Container]\n    D -- 删除 --&gt; F</pre>\n\n<p>简单理解了容器和镜像的关系，我们可以尝试安装Docker并在Docker部署一个应用，这个应用可以是很多种类型，比如：部署一个可以使用显卡的运行环境（依赖环境也是一种应用）。</p>\n<h3><span id=\"docker本身的安装\">Docker本身的安装</span></h3><p>这里不再赘述，可以参考另一篇维护的文章，当中Docker部署的部分。</p>\n<h3><span id=\"通过portainer构建自己的容器\">通过portainer构建自己的容器</span></h3><p>portainer部署在No1服务器上，<strong>portainer是用来管理所有Docker的管理软件</strong>，同时也部署在Docker之上，使用portainer来创建容器的目的是减少命令的输入，方便用户使用，降低Docker的使用门槛，图形化的管理界面也比较直观的展现了所有容器的信息，减少创建过程的问题，同时Portainer具有服务器集群管理，节点拓展等功能，为以后实验室服务建设添砖加瓦。</p>\n<p>首先登录你的<a href=\"https://10.26.58.61:9443/#!/auth\">Portainer</a></p>\n<p>每个人的账户已经创建好了，需要登陆密码私聊我即可。</p>\n<p>目前被部署在：<a href=\"https://10.26.58.61:9443/\">https://10.26.58.61:9443/</a></p>\n<p>使用zerotier的时候地址为：<a href=\"https://10.11.12.166:9443/\">https://10.11.12.166:9443/</a></p>\n<p><strong>注意端口号为9443</strong></p>\n<p>登录页面如图：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/xbPwe2hVuviBRaj.png\" alt=\"image-20240331232840271\" style=\"zoom: 50%;\"></p>\n<p>登录之后进入到管理界面：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/iycUPfqC3osAXjT.png\" alt=\"image-20240331233057783\" style=\"zoom:150%;\"></p>\n<p>点击链接按钮之后，下图就是其管理界面：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/3C6jqihDFOX8xug.png\" alt=\"image-20240331232721281\" style=\"zoom:150%;\"></p>\n<p>不过这里不是我们的主要目的，我们将目标放到右侧选项栏之中：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/i2UTrdaMQuIoWR1.png\" alt=\"image-20240331233820435\" style=\"zoom:80%;\"></p>\n<p>对于使用者来说，右侧的状态栏我们只关心这四个内容，Containers、Images、Networks、Volumes，下边将简单介绍一下这四个内容并在介绍的同时创建一个属于你自己的世界（容器）。</p>\n<h4><span id=\"images镜像\">Images（镜像）</span></h4><p>我们先来看一下Images页面，Images中文名称就是镜像，镜像在制作完之后和使用之前是无法更改的，也就是说镜像实际上就是某一套环境的固化版本、无法修改当中的内容，只能使用当中的内容。</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/UaTbB1pQetZsS6H.png\" alt=\"image-20240331235234493\" style=\"zoom:100%;\"></p>\n<p>可以看到我们有一个不太正规命名的pytorch镜像，这是我第一次制作的镜像，我们可以通过一个基本的镜像来详细介绍一下镜像如何使用和创建，我们使用这里最后一个镜像来在nvidia的cudnn运行环境来进行测试。</p>\n<h4><span id=\"container容器\">container（容器）</span></h4><p><strong>容器就是镜像运行起来的状态</strong>，这时候镜像内容就由上文中不可修改的状态转变为可修改、可运行、可探查的状态，一个镜像包含了一套完整的运行所需依赖，并由一套自己的文件系统来支持运行，也就说容器和本地服务器是隔离开的、是互相不干扰的，是没有任何关系的（其实并不是，也有一定的逃逸方法，建议大家正常使用就不会遇到这些问题）。</p>\n<p>以下为从零开始创建一个新容器，<strong>本文也有直接从一个已有容器复制新容器的使用指南</strong>，但是更推荐看完从零开始创建容器并自己动手跟着操作一遍，遇到问题可以随时联系管理人员。</p>\n<p>来到container页面：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/MOICl5ZJnrahszp.png\" alt=\"image-20240401002419124\"></p>\n<p>可以看到没有任何东西，这样我们就需要创建一个container，点右边的按钮来创建：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/e6PQyo478sNWtnF.png\" alt=\"image-20240401003226298\" style=\"zoom:150%;\"></p>\n<p>上图中演示的是NVIDIA的官方镜像，我这里也制作了几个适合组内任务的镜像，简单介绍下镜像列表如下，请选用<strong>neonexus开头</strong>的：</p>\n<p><img src=\"https://s2.loli.net/2025/10/11/5nZ781tSY2TJipM.png\" alt=\"image-20251011170438527\"></p>\n<p>这里以<strong>neonexusx/bionet_deeplearning:cuda121_cudnn9_conda_pytorch_devel_v1.1</strong>这个镜像为例，说明一下名字的含义</p>\n<p>neonexusx/bionet代表是Docker hub的仓库所属者，deeplearning代表镜像用途（深度学习），后面的cuda121代表cuda 12.1版本，cudnn9同理，conda代表存在conda虚拟环境，pytorch代表深度学习框架，v1.1是版本号（镜像不定期会更新，可以实时关注下）至于选用哪一个请自行参照上文选择。</p>\n<p>设置主机和容器的端口号映射：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/681u3F5fAKQvpmh.png\" alt=\"image-20240401004019203\"></p>\n<p>主机可使用的端口号在10086-10199之间，每个人使用的数量不受限制，只需要选择没有占用的即可，这里我占用的是10086，所以别人也无法使用了，但是如何查看别人用了什么端口号呢,使用相同的端口号会导致创建失败。</p>\n<p>容器需要使用的端口完全取决你的应用需要，比如R Studio就需要8787端口就需要将R的端口（8787）映射到10086到10199之间任意一个，当你从你的电脑链接的时候只需要选择你当时映射的主机端口号即可，不需要连接的时候选择8787。</p>\n<p>这里我建议你多留一个端口比如容器的10087来映射到10087来使用，这样万一有服务需要使用端口我们只需要重新映射一下服务即可，就不要再重新创建一个端口来使用了。</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/LpzZNdB4kwbmujS.png\" alt=\"image-20240401005456274\"></p>\n<h4><span id=\"容器的配置\">容器的配置</span></h4><p>最下面就是容器的详细配置了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/aAvQh2JOW1qe8rc.png\" alt=\"image-20240401150858895\"></p>\n<p>关于容器的配置这一部分，需要说明的是，大多数容器的配置都是一致的，只需要修改名字即可，填写请按照我给出的内容来填写，第一部分需要配置的比较少，按照图上的内容配置即可。</p>\n<h5><span id=\"存储配置\">存储配置</span></h5><p>不要照着下面这张图片直接抄，请先看后边的内容：</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/zMe3tKOEyxlDAnr.png\" alt=\"image-20240402225643545\"></p>\n<p><strong>Bind类型不要选错！</strong></p>\n<p><code>bind</code>是绑定本机路径到容器上某个路径之下，实现对应路径的内容在主机和容器之间相互共享的方法。</p>\n<p>举个例子：</p>\n<p><code>type=bind,   source=/home/SoftWares/R_Share    ,    target=/home/R_Share,readonly \\</code>指的是将主机：<code>/home/SoftWares/P_Share</code>目录内容绑定到容器的<code>/home/R_Share</code>路径，注意这里的sorce指的是你的服务器本机端、target指的是容器端。</p>\n<p>这样这部分就可以互相共享文件，readonly指的是权限为可读，这样的设置当然是为防止你使用某一个数据集的时候有别人来篡改数据，造成你完全无法知晓跑出来的结果。</p>\n<p><strong>同时因为容器是以root权限来运行的，如果不使用readonly来限制很有可能你一条rm命令将大家的数据都删除了，这将造成无法挽回的后果。</strong></p>\n<p><code>type=bind,   source=修改这里/Share_Space,      target=/container/path/Share_Space \\</code></p>\n<p>Share_Space目录就没有只读权限这样的担忧，因为这个主机端的文件夹只有你能访问，这个文件需要你修改<code>修改这里</code>这四个字改成你的个人home目录：’/home/Neo/Share_Space ‘举个例子：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/4yWVJQOmj82FDXL.png\" alt=\"image-20240401120000975\" style=\"zoom:80%;\"></p>\n<h5><span id=\"存储配置的最佳实践\">存储配置的最佳实践</span></h5><p>下图展示了存储配置的最佳实践，需要结合<strong>NAS使用指南</strong>和当前讲解来理解：</p>\n<pre class=\"mermaid\">graph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n\n\n    A--\"Datasets文件夹依赖于\"---&gt;C\n    A--\"运行依赖于\"---&gt;B\n    A--\"运行依赖于\"---&gt;F\n    B--\"Datasets文件夹依赖于\"---&gt;C\n    F--\"Datasets文件夹依赖于\"---&gt;C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"---&gt;B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==&gt;C\n    D--\"连接运行\"---&gt;A\n    E--\"数据\"--&gt;D</pre>\n\n<p>红色的路径为推荐的上传数据集的方式：详见NAS使用说明。</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\"></p>\n<p>当你明白上述目录之后我们来填写上图中的内容，我已经简单写了一份出来，你只要复制其中的路径即可，不要搞错了主机和容器的区别。</p>\n<pre><code class=\"lang-dockerfile\">host=/home/Datasets            container= /home/Datasets,    readonly \nhost=/home/Neo/Share_Space        container= /home/Share_Space     Writable\n</code></pre>\n<p><strong>注意这里的host指的是你的服务器本机端、container指的是容器端</strong>，其他的内容按照图片选择即可。</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/yFznm7VK8CXNbQc.png\" alt=\"image-20250925235253260\"></p>\n<p>使用Tensorflow的同学注意需要将上图container的home替换为tf，如下图所示：</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/7Tsm3VjNaHJuYDz.png\" alt=\"image-20250925235655461\"></p>\n<h5><span id=\"lable配置\">lable配置</span></h5><p><img src=\"https://s2.loli.net/2024/04/01/4k6VCyMg3izb1JO.png\" alt=\"image-20240401121448908\"></p>\n<h5><span id=\"重启策略配置\">重启策略配置</span></h5><p><img src=\"https://s2.loli.net/2024/04/02/nmW72gZ9DJFeNaA.png\" alt=\"image-20240401121532287\"></p>\n<h5><span id=\"运行时配置\">运行时配置</span></h5><p>将页面切换到此处：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/ZJtPe1Rhmwj9SV5.png\" alt=\"image-20240423222756107\"></p>\n<p>shnm大小推荐至少128000MB，最大256000MB，使用多卡或者datakloader数量较多的程序请在16000MB以上。</p>\n<p>此处注意，因为有两组成员共用GPU，请bionet课题组使用如下配置：</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/tS7EbzL9iXdvw43.png\" alt=\"image-20240513232522771\"></p>\n<p>另外的成员，请使用如下配置：</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/n2k1jOqLD9EgJwK.png\" alt=\"image-20240513232551314\"></p>\n<p>最后一定要点击部署！容器才会生效~这个按钮就在基础部分。</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/MAe4yiPXOl1JLjN.png\" alt=\"image-20240402211408290\"></p>\n<p>创建完成之后我们就来到这个页面，可以看到容器已经在运行了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/icNmxPz4K8sSJLB.png\" alt=\"image-20240401130626984\"></p>\n<p>我们点击这里按道理是可以进入命令行的：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/gXmcAYVQxflhp1O.png\" alt=\"image-20240401151620031\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/1RA7bZYBF5frCwU.png\" alt=\"image-20240401151647884\"></p>\n<p>同时这里也有容器的监控信息：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/CwEZghoUN46szK8.png\" alt=\"image-20240401151726479\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/TiVyZEqe8n13c2w.png\" alt=\"image-20240401151713327\"></p>\n<h4><span id=\"tensorflow使用jupyter登录\">Tensorflow使用Jupyter登录</span></h4><p>Tensorflow环境使用Jupyter来使用，在上述镜像建立完成之后，我们首先找到我们映射的端口信息</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/5Or2iPdILDE8yae.png\" alt=\"image-20240426190845378\"></p>\n<p>点击镜像名字查看端口信息:</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/Gm7xojTqlBacEC5.png\" alt=\"image-20240426190920611\" style=\"zoom:50%;\"></p>\n<p>我们这里使用了32768端口来映射Jupyter的8888端口，我们打开浏览器输入：10.26.58.61:32768</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/Znamz7ysDEvIRt9.png\" alt=\"image-20240426191155106\"></p>\n<p>建议第一次就设置好密码，输入密码，这样每次就不用单独去查找API_token了</p>\n<p>接下来我们去命令行找到token：</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/lrjHS82MOPuAo1D.png\" alt=\"image-20240426191252515\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/26/yKVCXlfHNc3QGm5.png\" alt=\"image-20240426191325862\"></p>\n<p>复制对应的token即可使用，也可以选择下边的修改密码来长久登录。Jupyter自带命令行，所以Portainer的界面的命令行无法使用们这里需要注意。</p>\n<p>关于Jupyter的使用这里就不再赘述，下面是pytorch的vscode链接方法。</p>\n<h4><span id=\"使用已有容器复制\">使用已有容器复制</span></h4><p><img src=\"https://s2.loli.net/2025/09/25/21IdBygZ6mCXn9b.png\" alt=\"image-20250925234121499\"></p>\n<p>如图所示，example 是按照上面流程创建的标准容器，通过对标准容器的修改可以可以直接使用别人生成好的容器配置，但需要注意的要修改端口，绑定硬盘路径等参数就可以生成符合你的使用需求的一个新容器。具体操作步骤如下，先点击你想要复制的容器（以example为例，下同）</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/SNiZ3e7LGQIofM8.png\" alt=\"image-20250925234406623\" style=\"zoom:67%;\"></p>\n<p>点击Duplicate/Edit，进入如下界面</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/KxNbLFPwIjkYevg.png\" alt=\"image-20250925234659012\" style=\"zoom:67%;\"></p>\n<p>记得点击</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/QXBf37IZvei5KW2.png\" alt=\"image-20250925234714104\"></p>\n<p>来保存容器</p>\n<p>之后就会得到一个新的容器了</p>\n<p>复制容器的好处是简单快捷，可以根据自己的使用场景微调镜像，但是还是推荐大家去看上面的从零开始创建容器的部分，可以深入的了解每个选项的作用，有问题也可以自己简单修复下。</p>\n<h4><span id=\"使用vscode连接容器\">使用VSCode连接容器</span></h4><p>下载vscode：<a href=\"https://code.visualstudio.com/\">Visual Studio Code - Code Editing. Redefined</a>。推荐使用新版。</p>\n<p>在连接之前我们先来使用Portainer来重启一下SSH服务，优化conda内容，方便来链接：</p>\n<p>我们使用Portainer自带的命令行：</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/XIogMAGRr7T68NC.png\" alt=\"image-20240402202202138\"></p>\n<p>点击这里打开容器的命令行。输入以下命令：</p>\n<pre><code class=\"lang-bash\">service ssh restart &amp;&amp; conda init &amp;&amp; passwd &amp;&amp; mkdir ~/.ssh &amp;&amp; touch ~/.ssh/authorized_keys &amp;&amp; chmod 700 ~/.ssh &amp;&amp; chmod 600 ~/.ssh/authorized_keys\n</code></pre>\n<p><strong>命令行中粘贴快捷键为ctrl+shift+v</strong>，这里减一直接复制以后粘贴。</p>\n<p> 命令的效果是修改密码，并增加一些系统设置内容。</p>\n<p>效果如下所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/2BGjlk3HXq4owJp.png\" alt=\"image-20240403165653496\"></p>\n<p>注意这里修改密码要输入两次才可以，如果有一次和上一次输入的不一致就会失败，如下图所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/NweW3LbgRA7tfi6.png\" alt=\"image-20240403165843033\"></p>\n<p><strong>不用紧张，再次输入上一个命令即可。</strong>然后关闭这个页面。</p>\n<p>使用最新版的VSCode，这里下载安装就不再赘述了，打开Vscode之后：</p>\n<p>新版的vscoe自带remote链接如图所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/TWKrERxcZo6lGh8.png\" alt=\"image-20240401131807102\"></p>\n<p>如果没有的话，请去插件市场安装一个：</p>\n<p>选择左侧<strong>Extensions</strong>选项卡，在输入框搜索<strong>ssh</strong>，选择安装<strong>Remote-SSH</strong>插件。这里我已经安装。</p>\n<p><img src=\"https://s2.loli.net/2024/03/27/9PWEKZISgt6ip2O.png\" alt=\"image-20240326113905983\"></p>\n<p>安装之后让我们打开远程连接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/Wlsw1fQi5GyCdIR.png\" alt=\"image-20240401132035539\" style=\"zoom:50%;\"></p>\n<p>可以看到有两种链接形式的存在：一个是tunnels另一个是SSH，这里选择SSH，点击加号创建新的连接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/H7pbtqXUFvjD9fC.png\" alt=\"image-20240401132122934\"></p>\n<p>点击之后会让你输入命令：</p>\n<p>端口号要更改~</p>\n<pre><code class=\"lang-bash\">ssh root@10.26.58.61 -p 10086\n</code></pre>\n<p><strong>这里的-p指代的是端口号，也就是上文中所设置的端口号映射号，SSH服务默认使用22端口号我们将容器的22端口映射到服务器本机的10086端口，所以这里就要使用10086端口作为链接方式，这样我们只需要连接10086端口就可以连接到容器，注意这里的端口号要和你的容器设置保持一致。</strong></p>\n<p><strong>这里一定要修改成你的端口！！！！！！！！！！！！！！！！</strong></p>\n<p><strong>你可能会好奇为什么会是root，而不是其他用户，这里使用的root命令，是因为容器里面的root和主机的root并不一致，这里的root是容器中的管理权限用户，和外边并不相关。</strong></p>\n<p><strong>在你的容器里面你就是root！</strong></p>\n<p><strong>然后按下回车：</strong></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/u9Sjoazd56pRAVq.png\" alt=\"image-20240401132210185\"></p>\n<p><strong>一定要记住这个路径，万一有错误可以用到。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/kKQOC4yH7ftBgmj.png\" alt=\"image-20240401132414740\"></p>\n<p>然后右下角会弹出链接提示，选择链接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/2vsnJu4chxUjqgm.png\" alt=\"image-20240401132647734\"></p>\n<p>没有看到没有选择上也没关系，我们刷新一下列表就能看到链接信息了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/JWEOUhqfiLrxRKz.png\" alt=\"image-20240401132818238\"></p>\n<p>点击链接，输入密码之后开始下载，就说明成功了，容器的root密码为通用的123456：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/EpvNT7hSaFxJBlc.png\" alt=\"image-20240401163918819\" style=\"zoom:67%;\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/ymKYnV8FsrICNWA.png\" alt=\"image-20240401163649302\" style=\"zoom:80%;\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/fCKThcgtrZI6Gzd.png\" alt=\"image-20240401163813111\" style=\"zoom:67%;\"></p>\n<p>一般工作在home文件夹下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/j5YDfCvB91iPFcd.png\" alt=\"image-20240401163834329\" style=\"zoom:67%;\"></p>\n<p>可以看到刚才挂载的几个位置：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/yfx5aT4sM6QhDUb.png\" alt=\"image-20240401163853472\" style=\"zoom:67%;\"></p>\n<p>我们在这里新建一个python脚本来测试：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/vRESQnmKZ78dV6g.png\" alt=\"image-20240401164016267\" style=\"zoom: 80%;\"></p>\n<p>将以下内容插入：</p>\n<pre><code class=\"lang-python\">import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport torch.backends.cudnn as cudnn\nfrom torchvision import datasets, transforms\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)\n        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)\n        self.conv2_drop = nn.Dropout2d()\n        self.fc1 = nn.Linear(320, 50)\n        self.fc2 = nn.Linear(50, 10)\n\n\n    def forward(self, x):\n        x = F.relu(F.max_pool2d(self.conv1(x), 2))\n        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))\n        x = x.view(-1, 320)\n        x = F.relu(self.fc1(x))\n        x = F.dropout(x, training=self.training)\n        x = self.fc2(x)\n        return F.log_softmax(x, dim=1)\n\n\ndef train(model, device, train_loader, optimizer, epoch):\n    model.train()\n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = F.nll_loss(output, target)\n        loss.backward()\n        optimizer.step()\n        if batch_idx % 10 == 0:\n            print('Train Epoch: {} [{}/{} ({:.0f}%)]\\tLoss: {:.6f}'.format(\n                epoch, batch_idx * len(data), len(train_loader.dataset),\n                       100. * batch_idx / len(train_loader), loss.item()))\n\n\ndef main():\n    cudnn.benchmark = True\n    torch.manual_seed(1)\n    device = torch.device(\"cuda\") if torch.cuda.is_available() else torch.device(\"cpu\")\n    print(\"Using device: {}\".format(device))\n    kwargs = {'num_workers': 1, 'pin_memory': True}\n    train_loader = torch.utils.data.DataLoader(\n        datasets.MNIST('./data', train=True, download=True,\n                       transform=transforms.Compose([\n                           transforms.ToTensor(),\n                           transforms.Normalize((0.1307,), (0.3081,))\n                       ])),\n        batch_size=64, shuffle=True, **kwargs)\n\n    model = Net().to(device)\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)\n\n    for epoch in range(1, 11):\n        train(model, device, train_loader, optimizer, epoch)\n\nif __name__ == '__main__':\n    main()\n</code></pre>\n<p>新建之后会有右下角来提示安装对应的语言插件：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/vknM61ilJ5fAdRL.png\" alt=\"image-20240401164200647\" style=\"zoom:80%;\"></p>\n<p>没提示直接搜索也可以，在插件市场搜索：</p>\n<pre><code class=\"lang-txt\">@id:ms-python.python\n</code></pre>\n<p>同时还需要pylance，作为语法检查。</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/sbQwhgcJBERYHxm.png\" alt=\"image-20240401164247045\" style=\"zoom:80%;\"></p>\n<p><img src=\"https://s2.loli.net/2025/10/04/8gZmpbacAX6Hxkt.png\" alt=\"image-20251004234609532\" style=\"zoom: 67%;\"></p>\n<p>然后点击安装在远程即可。</p>\n<h4><span id=\"开启代码补全\">开启代码补全</span></h4><p>由于默认的代码补全并不是很好用这里要修改一下设置：</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/bzmETWanVH6YZ49.png\" alt=\"image-20240402224047196\"></p>\n<p>同时打开terminal来测试：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/Zq1fXU98RvWlzYI.png\" alt=\"image-20240401164322474\" style=\"zoom: 67%;\"></p>\n<p>输入命令：<code>nvidia-smi</code></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/LdIuCHcFAz5Dxqo.png\" alt=\"image-20240401164337512\" style=\"zoom:67%;\"></p>\n<p>如图所示，四个显卡都能看见，则创建成功。</p>\n<p>使用conda来创建环境，初始化codna：</p>\n<pre><code class=\"lang-bash\">conda init\n</code></pre>\n<p>重新开一个terminal：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/qDS9gACboVTuacl.png\" alt=\"image-20240401164542313\"></p>\n<p>可以看到cnoda已经成功启动了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/BiWUqm79ehoQdJw.png\" alt=\"image-20240401164605751\"></p>\n<p>在安装之前我们来进行换源，我们将目录切换到这里：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/Wom9RfSLKHzdqnl.png\" alt=\"image-20240401165118181\" style=\"zoom:80%;\"></p>\n<p>新建一个：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5oOPIieFVp7Xvm2.png\" alt=\"image-20240401165149467\" style=\"zoom: 67%;\"></p>\n<p>复制以下内容进去，记得ctrl+s保存：</p>\n<pre><code class=\"lang-bash\">channels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/\n</code></pre>\n<p><strong>最近清华源也不太稳定~</strong>，使用后无法下载删除文件恢复默认即可：</p>\n<p>使用如下命令清除缓存（想要恢复默认也需要使用这个）</p>\n<pre><code class=\"lang-bash\">conda clean -i\n</code></pre>\n<p>然后，打开一个新的terminal ，看一下conda是否有更新：</p>\n<p>使用命令：<code>conda info</code></p>\n<p>结果应是如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/L9oMIZgW6JEk1U5.png\" alt=\"image-20240401165401775\"></p>\n<p>我们安装一个pytorch来试一试：</p>\n<pre><code class=\"lang-bash\">conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/01/aqHx1r2QAL4CDFR.png\" alt=\"image-20240401172245221\"></p>\n<p>点击运行：</p>\n<p>这里注意，你的当前目录不一定是你的文件夹，在运行之前要搞明白下方的命令行当前的目录在哪里是不是你想要的位置，因为在python中有很多相对路径要去处理，关于这点我们继续看下一张图：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/QkYoVbXgyju13ZS.png\" alt=\"image-20240401172544313\"></p>\n<p>这里我们使用ls命令：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/cLyZJ8p2xjCgqbV.png\" alt=\"image-20240401192341093\"></p>\n<p>这里MINIST数据集下载到当前文件夹下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/3MslfcPEINVeDFi.png\" alt=\"image-20240401192455633\"></p>\n<p>那么相对路径是./此时的绝对路径是什么呢？</p>\n<p>不错就是命令行前端这一部分，我们打开目录就可以看到，数聚集被下载到了这里：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/EtfJeChiABw7r91.png\" alt=\"image-20240401192634760\" style=\"zoom:67%;\"></p>\n<p>需要注意的是我们在base环境下安装的pytorch，右下角可以切换当前的解释器：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5EJBFVPhxKejkSw.png\" alt=\"image-20240401172633176\"></p>\n<p><strong>注意这里应是cuda</strong></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/1YRKaW4BApzJ2Fh.png\" alt=\"image-20240401172730849\"></p>\n<p>可以看到显卡被占用了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/OjzRcpxnSM7F9v1.png\" alt=\"image-20240401172940076\" style=\"zoom:67%;\"></p>\n<h3><span id=\"容器的维护\">容器的维护</span></h3><p>维护自身的容器也非常重要，在运行的时候我们可能建立多个bash，这些bash在切换路径的时候被vscode所遗忘，就会造成内存虚高，这对我们来说是不利的，在运行代码之前，记住一定是运行代码之前，要维护好自己的容器，就少删除一些垃圾bash，使用命令：</p>\n<pre><code class=\"lang-bash\">ps -ef | grep shellIntegration-bash.sh\n</code></pre>\n<p>命令显示了多少个bash在运行：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/VTCxHhd95vN6iAB.png\" alt=\"image-20240401193622108\"></p>\n<p>我们保留最后一个数字最大的（因为是当前正在使用的这个，数字越大，创建的时候越靠后）</p>\n<p>使用命令杀掉前两个：</p>\n<pre><code>kill -9 10970 11173\n</code></pre><p>瞬间清净了~</p>\n<h4><span id=\"开启免密码登录可选\">开启免密码登录【可选】</span></h4><p>开启免密码登录方式如下：</p>\n<p>首先打开你的ssh配置文件：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/dgPwOnKMThcuGAq.png\" alt=\"image-20240403170216864\" style=\"zoom:67%;\"></p>\n<p>打开之后我们先放这里，等下再用。我们把这个路径叫做SSH配置路径，一定要记住这个路径，可以截图。</p>\n<p>我们在windos文件管理器中打开这个文件夹：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/v9sV2CIUkceziL1.png\" alt=\"image-20240403170412513\" style=\"zoom:80%;\"></p>\n<p>这里分为两种情况，一种是你已经有了上述<code>id_rsa.pub</code>文件，如上图红框所示。</p>\n<p>另一种情况是没有这个文件，如下所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/z48qTZJ75yNMaoL.png\" alt=\"29c9f2a1ef1c58e7deeae3ac742c00f\" style=\"zoom:80%;\"></p>\n<p>如果你没有，我们打开本地的系统命令行：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/KenW8bEy1gwz9UI.png\" alt=\"image-20240403170517802\" style=\"zoom:80%;\"></p>\n<p>输入以下内容：</p>\n<pre><code class=\"lang-bash\">ssh-keygen\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/03/ivOr8YQgDAbcLq2.png\" alt=\"image-20240403170800926\" style=\"zoom:80%;\"></p>\n<p>这里会提示让你输入密钥文件保存在哪里，这里就要放在你刚才的那个路径的文件下面，就是在vscode设置中打开的路径。记住是文件夹，不是文件，文件夹通常名字为：”.ssh”。</p>\n<p>输入之后一路回车下去直到看到这个图形生成：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/WmeMaujYiO9Ix6G.png\" alt=\"image-20240403171025319\" style=\"zoom:67%;\"></p>\n<p>这里就结束了，然后我们回过头打开这个文件，使用vscode或者记事本都可以，同时我们也打开远程服务器的这个目录下的文件：</p>\n<p>这路径全名是：</p>\n<pre><code class=\"lang-bash\">/root/.ssh/authorized_keys\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/03/fHrEOVRzybCqh3W.png\" alt=\"image-20240403171155723\" style=\"zoom:67%;\"></p>\n<p>打开之后我们将刚才打开的<code>id_rsa.pub</code>文件中的内容复制过来，通常如下图所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/xXeDynObsMYK9Ez.png\" alt=\"image-20240403171427044\" style=\"zoom:80%;\"></p>\n<p>然后我们回到最初打开的ssh配置文件，在你的电脑SSH配置路径上，如果没打开的话，我们还是点击这里打开：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/6TcAB2P7SVDQUuC.png\" alt=\"image-20240403171545385\"></p>\n<p>添加一行内容：</p>\n<pre><code class=\"lang-bash\">IdentityFile \"C:\\Users\\NeoNexus\\.ssh\\id_rsa\"  这里的路径要修改成你的配置路径，要记得这里的id_rsa文件并不带pub后缀因为这是私钥\n</code></pre>\n<p>添加后效果如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/sVCgWRw4FJBLZtj.png\" alt=\"image-20240403171709698\"></p>\n<p>记得Ctrl+S保存修改</p>\n<p>重启VSCode就可以愉快免密码直接使用了。</p>\n","excerpt":"","more":"<h1 id=\"BionetServer-No1使用说明-进阶（Docker方式）\"><a href=\"#BionetServer-No1使用说明-进阶（Docker方式）\" class=\"headerlink\" title=\"BionetServer-No1使用说明-进阶（Docker方式）\"></a>BionetServer-No1使用说明-进阶（Docker方式）</h1><p><img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" /></p>\n<p>Version:1.3</p>\n<p>Docker篇更新记录：</p>\n<ul>\n<li>添加了常见错误解决方案</li>\n<li>添加了复制容器使用说明</li>\n<li>修改了镜像使用指南</li>\n<li>删除了R部分内容，将在下一个版本重构R说明</li>\n</ul>\n<p>Date: 2025.9.24</p>\n<p>Authors：魏持之，NeoNexus</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#开发的最佳实践\">开发的最佳实践</a><ul>\n<li><a href=\"#docker的使用与创建\">Docker的使用与创建</a></li>\n<li><a href=\"#image镜像和container容器的关系\">image（镜像）和container（容器）的关系</a></li>\n<li><a href=\"#docker本身的安装\">Docker本身的安装</a></li>\n<li><a href=\"#通过portainer构建自己的容器\">通过portainer构建自己的容器</a><ul>\n<li><a href=\"#images镜像\">Images（镜像）</a></li>\n<li><a href=\"#container容器\">container（容器）</a></li>\n<li><a href=\"#容器的配置\">容器的配置</a><ul>\n<li><a href=\"#存储配置\">存储配置</a></li>\n<li><a href=\"#存储配置的最佳实践\">存储配置的最佳实践</a></li>\n<li><a href=\"#lable配置\">lable配置</a></li>\n<li><a href=\"#重启策略配置\">重启策略配置</a></li>\n<li><a href=\"#运行时配置\">运行时配置</a></li>\n</ul>\n</li>\n<li><a href=\"#tensorflow使用jupyter登录\">Tensorflow使用Jupyter登录</a></li>\n<li><a href=\"#使用已有容器复制\">使用已有容器复制</a></li>\n<li><a href=\"#使用vscode连接容器\">使用VSCode连接容器</a></li>\n<li><a href=\"#开启代码补全\">开启代码补全</a></li>\n</ul>\n</li>\n<li><a href=\"#容器的维护\">容器的维护</a><ul>\n<li><a href=\"#开启免密码登录可选\">开启免密码登录【可选】</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2 id=\"开发的最佳实践\"><a href=\"#开发的最佳实践\" class=\"headerlink\" title=\"开发的最佳实践\"></a>开发的最佳实践</h2><p>开发的最佳实践基于Docker来实现，使用Docker已经成为世界上最重要和流行的开发模式，学习如何使用Docker来进行开发，不管你走到哪里，是科研还是进入互联网大厂，这一套开发方式的部署会让你受益无穷。下面将简单介绍一些基础概念，由于篇幅限制，介绍的不是很详细，但能帮你有一个初步的了解。</p>\n<p><strong>使用Docker的优势：</strong></p>\n<ul>\n<li><strong>便于使用者管理环境</strong></li>\n<li><strong>快速在多台部署有Docker基础环境的机器上运行对应程序，可以在不同的机器中迁移运行，无需重复调整开发环境。</strong></li>\n<li><strong>支持集群部署</strong></li>\n<li><strong>root权限</strong></li>\n<li><strong>高性能，容器部署30s内即可完成</strong></li>\n</ul>\n<p><strong>第一次查看此文档建议按照顺序看，第一创建成功之后建议使用模板方法快速创建。</strong></p>\n<h3 id=\"Docker的使用与创建\"><a href=\"#Docker的使用与创建\" class=\"headerlink\" title=\"Docker的使用与创建\"></a>Docker的使用与创建</h3><p>下图展示了Docker的基本运行原理，其运行在一个基本的操作系统上，并在一个Docker支持多个运行的基本环境。</p>\n<p><img src=\"https://s2.loli.net/2024/01/25/TCh1nqvuyWL6Kp3.png\" alt=\"282c3hci\" style=\"zoom: 50%;\" /></p>\n<p>下图展示了传统的VM（虚拟机）架构，是运行在硬件的抽象层之上的，并且每一个虚拟机都有一个操作系统的支持，就是对应的Guest Operating System。</p>\n<p><img src=\"https://s2.loli.net/2024/01/26/qgLmakBI7VMjoS8.png\" alt=\"7d2mwnd9\" style=\"zoom: 50%;\" /></p>\n<p>开发的最佳实践主要是在于使用Docker来进行环境的配置和使用。</p>\n<h3 id=\"image（镜像）和container（容器）的关系\"><a href=\"#image（镜像）和container（容器）的关系\" class=\"headerlink\" title=\"image（镜像）和container（容器）的关系\"></a>image（镜像）和container（容器）的关系</h3><p><strong>镜像（Image）</strong>：Docker镜像是一个静态文件，其中包含了应用程序运行所需的所有文件系统内容、库和配置。镜像是一个只读的模板。它可以用来创建一个或多个容器。</p>\n<p><strong>可以简单理解镜像是一个制作好就无法修改的模板</strong></p>\n<p><strong>容器（Container）</strong>：Docker容器是镜像的运行实例。它实际上是一个独立的、轻量级的、可执行的软件包，包含了运行应用程序所需的一切：代码、运行时、库、环境变量和配置文件。容器可以被创建、启动、停止、删除和移动。每个容器都是相互隔离的，具有自己的文件系统、网络和进程空间。</p>\n<p><strong>容器可以看作一个镜像的动态转变，将其从静态唤醒变成一个应用，可以运行修改。</strong></p>\n<p>下面的状态图，阐述了使用过程中的状态改变：</p>\n<pre class=\"mermaid\">graph TD;\n    A[Docker Image] -- 创建 --> B[Docker Container]\n    B -- 基于 --> A\n    B -- 运行 --> C{应用运行中?}\n    C -- 是 --> D{正常}\n    C -- 否 --> E{已停止}\n    E -- 重启 --> C\n    E -- 删除 --> F[Destroyed Container]\n    D -- 删除 --> F</pre>\n\n<p>简单理解了容器和镜像的关系，我们可以尝试安装Docker并在Docker部署一个应用，这个应用可以是很多种类型，比如：部署一个可以使用显卡的运行环境（依赖环境也是一种应用）。</p>\n<h3 id=\"Docker本身的安装\"><a href=\"#Docker本身的安装\" class=\"headerlink\" title=\"Docker本身的安装\"></a>Docker本身的安装</h3><p>这里不再赘述，可以参考另一篇维护的文章，当中Docker部署的部分。</p>\n<h3 id=\"通过portainer构建自己的容器\"><a href=\"#通过portainer构建自己的容器\" class=\"headerlink\" title=\"通过portainer构建自己的容器\"></a>通过portainer构建自己的容器</h3><p>portainer部署在No1服务器上，<strong>portainer是用来管理所有Docker的管理软件</strong>，同时也部署在Docker之上，使用portainer来创建容器的目的是减少命令的输入，方便用户使用，降低Docker的使用门槛，图形化的管理界面也比较直观的展现了所有容器的信息，减少创建过程的问题，同时Portainer具有服务器集群管理，节点拓展等功能，为以后实验室服务建设添砖加瓦。</p>\n<p>首先登录你的<a href=\"https://10.26.58.61:9443/#!/auth\">Portainer</a></p>\n<p>每个人的账户已经创建好了，需要登陆密码私聊我即可。</p>\n<p>目前被部署在：<a href=\"https://10.26.58.61:9443/\">https://10.26.58.61:9443/</a></p>\n<p>使用zerotier的时候地址为：<a href=\"https://10.11.12.166:9443/\">https://10.11.12.166:9443/</a></p>\n<p><strong>注意端口号为9443</strong></p>\n<p>登录页面如图：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/xbPwe2hVuviBRaj.png\" alt=\"image-20240331232840271\" style=\"zoom: 50%;\" /></p>\n<p>登录之后进入到管理界面：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/iycUPfqC3osAXjT.png\" alt=\"image-20240331233057783\" style=\"zoom:150%;\" /></p>\n<p>点击链接按钮之后，下图就是其管理界面：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/3C6jqihDFOX8xug.png\" alt=\"image-20240331232721281\" style=\"zoom:150%;\" /></p>\n<p>不过这里不是我们的主要目的，我们将目标放到右侧选项栏之中：</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/i2UTrdaMQuIoWR1.png\" alt=\"image-20240331233820435\" style=\"zoom:80%;\" /></p>\n<p>对于使用者来说，右侧的状态栏我们只关心这四个内容，Containers、Images、Networks、Volumes，下边将简单介绍一下这四个内容并在介绍的同时创建一个属于你自己的世界（容器）。</p>\n<h4 id=\"Images（镜像）\"><a href=\"#Images（镜像）\" class=\"headerlink\" title=\"Images（镜像）\"></a>Images（镜像）</h4><p>我们先来看一下Images页面，Images中文名称就是镜像，镜像在制作完之后和使用之前是无法更改的，也就是说镜像实际上就是某一套环境的固化版本、无法修改当中的内容，只能使用当中的内容。</p>\n<p><img src=\"https://s2.loli.net/2024/03/31/UaTbB1pQetZsS6H.png\" alt=\"image-20240331235234493\" style=\"zoom:100%;\" /></p>\n<p>可以看到我们有一个不太正规命名的pytorch镜像，这是我第一次制作的镜像，我们可以通过一个基本的镜像来详细介绍一下镜像如何使用和创建，我们使用这里最后一个镜像来在nvidia的cudnn运行环境来进行测试。</p>\n<h4 id=\"container（容器）\"><a href=\"#container（容器）\" class=\"headerlink\" title=\"container（容器）\"></a>container（容器）</h4><p><strong>容器就是镜像运行起来的状态</strong>，这时候镜像内容就由上文中不可修改的状态转变为可修改、可运行、可探查的状态，一个镜像包含了一套完整的运行所需依赖，并由一套自己的文件系统来支持运行，也就说容器和本地服务器是隔离开的、是互相不干扰的，是没有任何关系的（其实并不是，也有一定的逃逸方法，建议大家正常使用就不会遇到这些问题）。</p>\n<p>以下为从零开始创建一个新容器，<strong>本文也有直接从一个已有容器复制新容器的使用指南</strong>，但是更推荐看完从零开始创建容器并自己动手跟着操作一遍，遇到问题可以随时联系管理人员。</p>\n<p>来到container页面：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/MOICl5ZJnrahszp.png\" alt=\"image-20240401002419124\"></p>\n<p>可以看到没有任何东西，这样我们就需要创建一个container，点右边的按钮来创建：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/e6PQyo478sNWtnF.png\" alt=\"image-20240401003226298\" style=\"zoom:150%;\" /></p>\n<p>上图中演示的是NVIDIA的官方镜像，我这里也制作了几个适合组内任务的镜像，简单介绍下镜像列表如下，请选用<strong>neonexus开头</strong>的：</p>\n<p><img src=\"https://s2.loli.net/2025/10/11/5nZ781tSY2TJipM.png\" alt=\"image-20251011170438527\"></p>\n<p>这里以<strong>neonexusx/bionet_deeplearning:cuda121_cudnn9_conda_pytorch_devel_v1.1</strong>这个镜像为例，说明一下名字的含义</p>\n<p>neonexusx/bionet代表是Docker hub的仓库所属者，deeplearning代表镜像用途（深度学习），后面的cuda121代表cuda 12.1版本，cudnn9同理，conda代表存在conda虚拟环境，pytorch代表深度学习框架，v1.1是版本号（镜像不定期会更新，可以实时关注下）至于选用哪一个请自行参照上文选择。</p>\n<p>设置主机和容器的端口号映射：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/681u3F5fAKQvpmh.png\" alt=\"image-20240401004019203\"  /></p>\n<p>主机可使用的端口号在10086-10199之间，每个人使用的数量不受限制，只需要选择没有占用的即可，这里我占用的是10086，所以别人也无法使用了，但是如何查看别人用了什么端口号呢,使用相同的端口号会导致创建失败。</p>\n<p>容器需要使用的端口完全取决你的应用需要，比如R Studio就需要8787端口就需要将R的端口（8787）映射到10086到10199之间任意一个，当你从你的电脑链接的时候只需要选择你当时映射的主机端口号即可，不需要连接的时候选择8787。</p>\n<p>这里我建议你多留一个端口比如容器的10087来映射到10087来使用，这样万一有服务需要使用端口我们只需要重新映射一下服务即可，就不要再重新创建一个端口来使用了。</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/LpzZNdB4kwbmujS.png\" alt=\"image-20240401005456274\"></p>\n<h4 id=\"容器的配置\"><a href=\"#容器的配置\" class=\"headerlink\" title=\"容器的配置\"></a>容器的配置</h4><p>最下面就是容器的详细配置了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/aAvQh2JOW1qe8rc.png\" alt=\"image-20240401150858895\"></p>\n<p>关于容器的配置这一部分，需要说明的是，大多数容器的配置都是一致的，只需要修改名字即可，填写请按照我给出的内容来填写，第一部分需要配置的比较少，按照图上的内容配置即可。</p>\n<h5 id=\"存储配置\"><a href=\"#存储配置\" class=\"headerlink\" title=\"存储配置\"></a>存储配置</h5><p>不要照着下面这张图片直接抄，请先看后边的内容：</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/zMe3tKOEyxlDAnr.png\" alt=\"image-20240402225643545\"></p>\n<p><strong>Bind类型不要选错！</strong></p>\n<p><code>bind</code>是绑定本机路径到容器上某个路径之下，实现对应路径的内容在主机和容器之间相互共享的方法。</p>\n<p>举个例子：</p>\n<p><code>type=bind,   source=/home/SoftWares/R_Share    ,    target=/home/R_Share,readonly \\</code>指的是将主机：<code>/home/SoftWares/P_Share</code>目录内容绑定到容器的<code>/home/R_Share</code>路径，注意这里的sorce指的是你的服务器本机端、target指的是容器端。</p>\n<p>这样这部分就可以互相共享文件，readonly指的是权限为可读，这样的设置当然是为防止你使用某一个数据集的时候有别人来篡改数据，造成你完全无法知晓跑出来的结果。</p>\n<p><strong>同时因为容器是以root权限来运行的，如果不使用readonly来限制很有可能你一条rm命令将大家的数据都删除了，这将造成无法挽回的后果。</strong></p>\n<p><code>type=bind,   source=修改这里/Share_Space,      target=/container/path/Share_Space \\</code></p>\n<p>Share_Space目录就没有只读权限这样的担忧，因为这个主机端的文件夹只有你能访问，这个文件需要你修改<code>修改这里</code>这四个字改成你的个人home目录：’/home/Neo/Share_Space ‘举个例子：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/4yWVJQOmj82FDXL.png\" alt=\"image-20240401120000975\" style=\"zoom:80%;\" /></p>\n<h5 id=\"存储配置的最佳实践\"><a href=\"#存储配置的最佳实践\" class=\"headerlink\" title=\"存储配置的最佳实践\"></a>存储配置的最佳实践</h5><p>下图展示了存储配置的最佳实践，需要结合<strong>NAS使用指南</strong>和当前讲解来理解：</p>\n<pre class=\"mermaid\">graph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n\n\n    A--\"Datasets文件夹依赖于\"--->C\n    A--\"运行依赖于\"--->B\n    A--\"运行依赖于\"--->F\n    B--\"Datasets文件夹依赖于\"--->C\n    F--\"Datasets文件夹依赖于\"--->C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"--->B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==>C\n    D--\"连接运行\"--->A\n    E--\"数据\"-->D</pre>\n\n<p>红色的路径为推荐的上传数据集的方式：详见NAS使用说明。</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\" /></p>\n<p>当你明白上述目录之后我们来填写上图中的内容，我已经简单写了一份出来，你只要复制其中的路径即可，不要搞错了主机和容器的区别。</p>\n<pre><code class=\"lang-dockerfile\">host=/home/Datasets            container= /home/Datasets,    readonly \nhost=/home/Neo/Share_Space        container= /home/Share_Space     Writable\n</code></pre>\n<p><strong>注意这里的host指的是你的服务器本机端、container指的是容器端</strong>，其他的内容按照图片选择即可。</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/yFznm7VK8CXNbQc.png\" alt=\"image-20250925235253260\"></p>\n<p>使用Tensorflow的同学注意需要将上图container的home替换为tf，如下图所示：</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/7Tsm3VjNaHJuYDz.png\" alt=\"image-20250925235655461\"></p>\n<h5 id=\"lable配置\"><a href=\"#lable配置\" class=\"headerlink\" title=\"lable配置\"></a>lable配置</h5><p><img src=\"https://s2.loli.net/2024/04/01/4k6VCyMg3izb1JO.png\" alt=\"image-20240401121448908\"></p>\n<h5 id=\"重启策略配置\"><a href=\"#重启策略配置\" class=\"headerlink\" title=\"重启策略配置\"></a>重启策略配置</h5><p><img src=\"https://s2.loli.net/2024/04/02/nmW72gZ9DJFeNaA.png\" alt=\"image-20240401121532287\"></p>\n<h5 id=\"运行时配置\"><a href=\"#运行时配置\" class=\"headerlink\" title=\"运行时配置\"></a>运行时配置</h5><p>将页面切换到此处：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/ZJtPe1Rhmwj9SV5.png\" alt=\"image-20240423222756107\"></p>\n<p>shnm大小推荐至少128000MB，最大256000MB，使用多卡或者datakloader数量较多的程序请在16000MB以上。</p>\n<p>此处注意，因为有两组成员共用GPU，请bionet课题组使用如下配置：</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/tS7EbzL9iXdvw43.png\" alt=\"image-20240513232522771\"></p>\n<p>另外的成员，请使用如下配置：</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/n2k1jOqLD9EgJwK.png\" alt=\"image-20240513232551314\"></p>\n<p>最后一定要点击部署！容器才会生效~这个按钮就在基础部分。</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/MAe4yiPXOl1JLjN.png\" alt=\"image-20240402211408290\"></p>\n<p>创建完成之后我们就来到这个页面，可以看到容器已经在运行了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/icNmxPz4K8sSJLB.png\" alt=\"image-20240401130626984\"></p>\n<p>我们点击这里按道理是可以进入命令行的：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/gXmcAYVQxflhp1O.png\" alt=\"image-20240401151620031\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/1RA7bZYBF5frCwU.png\" alt=\"image-20240401151647884\"></p>\n<p>同时这里也有容器的监控信息：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/CwEZghoUN46szK8.png\" alt=\"image-20240401151726479\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/TiVyZEqe8n13c2w.png\" alt=\"image-20240401151713327\"></p>\n<h4 id=\"Tensorflow使用Jupyter登录\"><a href=\"#Tensorflow使用Jupyter登录\" class=\"headerlink\" title=\"Tensorflow使用Jupyter登录\"></a>Tensorflow使用Jupyter登录</h4><p>Tensorflow环境使用Jupyter来使用，在上述镜像建立完成之后，我们首先找到我们映射的端口信息</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/5Or2iPdILDE8yae.png\" alt=\"image-20240426190845378\"></p>\n<p>点击镜像名字查看端口信息:</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/Gm7xojTqlBacEC5.png\" alt=\"image-20240426190920611\" style=\"zoom:50%;\" /></p>\n<p>我们这里使用了32768端口来映射Jupyter的8888端口，我们打开浏览器输入：10.26.58.61:32768</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/Znamz7ysDEvIRt9.png\" alt=\"image-20240426191155106\"></p>\n<p>建议第一次就设置好密码，输入密码，这样每次就不用单独去查找API_token了</p>\n<p>接下来我们去命令行找到token：</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/lrjHS82MOPuAo1D.png\" alt=\"image-20240426191252515\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/26/yKVCXlfHNc3QGm5.png\" alt=\"image-20240426191325862\"></p>\n<p>复制对应的token即可使用，也可以选择下边的修改密码来长久登录。Jupyter自带命令行，所以Portainer的界面的命令行无法使用们这里需要注意。</p>\n<p>关于Jupyter的使用这里就不再赘述，下面是pytorch的vscode链接方法。</p>\n<h4 id=\"使用已有容器复制\"><a href=\"#使用已有容器复制\" class=\"headerlink\" title=\"使用已有容器复制\"></a>使用已有容器复制</h4><p><img src=\"https://s2.loli.net/2025/09/25/21IdBygZ6mCXn9b.png\" alt=\"image-20250925234121499\"></p>\n<p>如图所示，example 是按照上面流程创建的标准容器，通过对标准容器的修改可以可以直接使用别人生成好的容器配置，但需要注意的要修改端口，绑定硬盘路径等参数就可以生成符合你的使用需求的一个新容器。具体操作步骤如下，先点击你想要复制的容器（以example为例，下同）</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/SNiZ3e7LGQIofM8.png\" alt=\"image-20250925234406623\" style=\"zoom:67%;\" /></p>\n<p>点击Duplicate/Edit，进入如下界面</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/KxNbLFPwIjkYevg.png\" alt=\"image-20250925234659012\" style=\"zoom:67%;\" /></p>\n<p>记得点击</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/QXBf37IZvei5KW2.png\" alt=\"image-20250925234714104\"></p>\n<p>来保存容器</p>\n<p>之后就会得到一个新的容器了</p>\n<p>复制容器的好处是简单快捷，可以根据自己的使用场景微调镜像，但是还是推荐大家去看上面的从零开始创建容器的部分，可以深入的了解每个选项的作用，有问题也可以自己简单修复下。</p>\n<h4 id=\"使用VSCode连接容器\"><a href=\"#使用VSCode连接容器\" class=\"headerlink\" title=\"使用VSCode连接容器\"></a>使用VSCode连接容器</h4><p>下载vscode：<a href=\"https://code.visualstudio.com/\">Visual Studio Code - Code Editing. Redefined</a>。推荐使用新版。</p>\n<p>在连接之前我们先来使用Portainer来重启一下SSH服务，优化conda内容，方便来链接：</p>\n<p>我们使用Portainer自带的命令行：</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/XIogMAGRr7T68NC.png\" alt=\"image-20240402202202138\"></p>\n<p>点击这里打开容器的命令行。输入以下命令：</p>\n<pre><code class=\"lang-bash\">service ssh restart &amp;&amp; conda init &amp;&amp; passwd &amp;&amp; mkdir ~/.ssh &amp;&amp; touch ~/.ssh/authorized_keys &amp;&amp; chmod 700 ~/.ssh &amp;&amp; chmod 600 ~/.ssh/authorized_keys\n</code></pre>\n<p><strong>命令行中粘贴快捷键为ctrl+shift+v</strong>，这里减一直接复制以后粘贴。</p>\n<p> 命令的效果是修改密码，并增加一些系统设置内容。</p>\n<p>效果如下所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/2BGjlk3HXq4owJp.png\" alt=\"image-20240403165653496\"></p>\n<p>注意这里修改密码要输入两次才可以，如果有一次和上一次输入的不一致就会失败，如下图所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/NweW3LbgRA7tfi6.png\" alt=\"image-20240403165843033\"></p>\n<p><strong>不用紧张，再次输入上一个命令即可。</strong>然后关闭这个页面。</p>\n<p>使用最新版的VSCode，这里下载安装就不再赘述了，打开Vscode之后：</p>\n<p>新版的vscoe自带remote链接如图所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/TWKrERxcZo6lGh8.png\" alt=\"image-20240401131807102\"></p>\n<p>如果没有的话，请去插件市场安装一个：</p>\n<p>选择左侧<strong>Extensions</strong>选项卡，在输入框搜索<strong>ssh</strong>，选择安装<strong>Remote-SSH</strong>插件。这里我已经安装。</p>\n<p><img src=\"https://s2.loli.net/2024/03/27/9PWEKZISgt6ip2O.png\" alt=\"image-20240326113905983\"></p>\n<p>安装之后让我们打开远程连接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/Wlsw1fQi5GyCdIR.png\" alt=\"image-20240401132035539\" style=\"zoom:50%;\" /></p>\n<p>可以看到有两种链接形式的存在：一个是tunnels另一个是SSH，这里选择SSH，点击加号创建新的连接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/H7pbtqXUFvjD9fC.png\" alt=\"image-20240401132122934\"></p>\n<p>点击之后会让你输入命令：</p>\n<p>端口号要更改~</p>\n<pre><code class=\"lang-bash\">ssh root@10.26.58.61 -p 10086\n</code></pre>\n<p><strong>这里的-p指代的是端口号，也就是上文中所设置的端口号映射号，SSH服务默认使用22端口号我们将容器的22端口映射到服务器本机的10086端口，所以这里就要使用10086端口作为链接方式，这样我们只需要连接10086端口就可以连接到容器，注意这里的端口号要和你的容器设置保持一致。</strong></p>\n<p><strong>这里一定要修改成你的端口！！！！！！！！！！！！！！！！</strong></p>\n<p><strong>你可能会好奇为什么会是root，而不是其他用户，这里使用的root命令，是因为容器里面的root和主机的root并不一致，这里的root是容器中的管理权限用户，和外边并不相关。</strong></p>\n<p><strong>在你的容器里面你就是root！</strong></p>\n<p><strong>然后按下回车：</strong></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/u9Sjoazd56pRAVq.png\" alt=\"image-20240401132210185\"></p>\n<p><strong>一定要记住这个路径，万一有错误可以用到。</strong></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/kKQOC4yH7ftBgmj.png\" alt=\"image-20240401132414740\"></p>\n<p>然后右下角会弹出链接提示，选择链接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/2vsnJu4chxUjqgm.png\" alt=\"image-20240401132647734\"></p>\n<p>没有看到没有选择上也没关系，我们刷新一下列表就能看到链接信息了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/JWEOUhqfiLrxRKz.png\" alt=\"image-20240401132818238\"></p>\n<p>点击链接，输入密码之后开始下载，就说明成功了，容器的root密码为通用的123456：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/EpvNT7hSaFxJBlc.png\" alt=\"image-20240401163918819\" style=\"zoom:67%;\" /></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/ymKYnV8FsrICNWA.png\" alt=\"image-20240401163649302\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/fCKThcgtrZI6Gzd.png\" alt=\"image-20240401163813111\" style=\"zoom:67%;\" /></p>\n<p>一般工作在home文件夹下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/j5YDfCvB91iPFcd.png\" alt=\"image-20240401163834329\" style=\"zoom:67%;\" /></p>\n<p>可以看到刚才挂载的几个位置：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/yfx5aT4sM6QhDUb.png\" alt=\"image-20240401163853472\" style=\"zoom:67%;\" /></p>\n<p>我们在这里新建一个python脚本来测试：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/vRESQnmKZ78dV6g.png\" alt=\"image-20240401164016267\" style=\"zoom: 80%;\" /></p>\n<p>将以下内容插入：</p>\n<pre><code class=\"lang-python\">import torch\nimport torch.nn as nn\nimport torch.nn.functional as F\nimport torch.optim as optim\nimport torch.backends.cudnn as cudnn\nfrom torchvision import datasets, transforms\n\n\nclass Net(nn.Module):\n    def __init__(self):\n        super(Net, self).__init__()\n        self.conv1 = nn.Conv2d(1, 10, kernel_size=5)\n        self.conv2 = nn.Conv2d(10, 20, kernel_size=5)\n        self.conv2_drop = nn.Dropout2d()\n        self.fc1 = nn.Linear(320, 50)\n        self.fc2 = nn.Linear(50, 10)\n\n\n    def forward(self, x):\n        x = F.relu(F.max_pool2d(self.conv1(x), 2))\n        x = F.relu(F.max_pool2d(self.conv2_drop(self.conv2(x)), 2))\n        x = x.view(-1, 320)\n        x = F.relu(self.fc1(x))\n        x = F.dropout(x, training=self.training)\n        x = self.fc2(x)\n        return F.log_softmax(x, dim=1)\n\n\ndef train(model, device, train_loader, optimizer, epoch):\n    model.train()\n    for batch_idx, (data, target) in enumerate(train_loader):\n        data, target = data.to(device), target.to(device)\n        optimizer.zero_grad()\n        output = model(data)\n        loss = F.nll_loss(output, target)\n        loss.backward()\n        optimizer.step()\n        if batch_idx % 10 == 0:\n            print(&#39;Train Epoch: &#123;&#125; [&#123;&#125;/&#123;&#125; (&#123;:.0f&#125;%)]\\tLoss: &#123;:.6f&#125;&#39;.format(\n                epoch, batch_idx * len(data), len(train_loader.dataset),\n                       100. * batch_idx / len(train_loader), loss.item()))\n\n\ndef main():\n    cudnn.benchmark = True\n    torch.manual_seed(1)\n    device = torch.device(&quot;cuda&quot;) if torch.cuda.is_available() else torch.device(&quot;cpu&quot;)\n    print(&quot;Using device: &#123;&#125;&quot;.format(device))\n    kwargs = &#123;&#39;num_workers&#39;: 1, &#39;pin_memory&#39;: True&#125;\n    train_loader = torch.utils.data.DataLoader(\n        datasets.MNIST(&#39;./data&#39;, train=True, download=True,\n                       transform=transforms.Compose([\n                           transforms.ToTensor(),\n                           transforms.Normalize((0.1307,), (0.3081,))\n                       ])),\n        batch_size=64, shuffle=True, **kwargs)\n\n    model = Net().to(device)\n    optimizer = optim.SGD(model.parameters(), lr=0.01, momentum=0.5)\n\n    for epoch in range(1, 11):\n        train(model, device, train_loader, optimizer, epoch)\n\nif __name__ == &#39;__main__&#39;:\n    main()\n</code></pre>\n<p>新建之后会有右下角来提示安装对应的语言插件：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/vknM61ilJ5fAdRL.png\" alt=\"image-20240401164200647\" style=\"zoom:80%;\" /></p>\n<p>没提示直接搜索也可以，在插件市场搜索：</p>\n<pre><code class=\"lang-txt\">@id:ms-python.python\n</code></pre>\n<p>同时还需要pylance，作为语法检查。</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/sbQwhgcJBERYHxm.png\" alt=\"image-20240401164247045\" style=\"zoom:80%;\" /></p>\n<p><img src=\"https://s2.loli.net/2025/10/04/8gZmpbacAX6Hxkt.png\" alt=\"image-20251004234609532\" style=\"zoom: 67%;\" /></p>\n<p>然后点击安装在远程即可。</p>\n<h4 id=\"开启代码补全\"><a href=\"#开启代码补全\" class=\"headerlink\" title=\"开启代码补全\"></a>开启代码补全</h4><p>由于默认的代码补全并不是很好用这里要修改一下设置：</p>\n<p><img src=\"https://s2.loli.net/2024/04/02/bzmETWanVH6YZ49.png\" alt=\"image-20240402224047196\"></p>\n<p>同时打开terminal来测试：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/Zq1fXU98RvWlzYI.png\" alt=\"image-20240401164322474\" style=\"zoom: 67%;\" /></p>\n<p>输入命令：<code>nvidia-smi</code></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/LdIuCHcFAz5Dxqo.png\" alt=\"image-20240401164337512\" style=\"zoom:67%;\" /></p>\n<p>如图所示，四个显卡都能看见，则创建成功。</p>\n<p>使用conda来创建环境，初始化codna：</p>\n<pre><code class=\"lang-bash\">conda init\n</code></pre>\n<p>重新开一个terminal：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/qDS9gACboVTuacl.png\" alt=\"image-20240401164542313\"></p>\n<p>可以看到cnoda已经成功启动了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/BiWUqm79ehoQdJw.png\" alt=\"image-20240401164605751\"></p>\n<p>在安装之前我们来进行换源，我们将目录切换到这里：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/Wom9RfSLKHzdqnl.png\" alt=\"image-20240401165118181\" style=\"zoom:80%;\" /></p>\n<p>新建一个：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5oOPIieFVp7Xvm2.png\" alt=\"image-20240401165149467\" style=\"zoom: 67%;\" /></p>\n<p>复制以下内容进去，记得ctrl+s保存：</p>\n<pre><code class=\"lang-bash\">channels:\n  - defaults\nshow_channel_urls: true\ndefault_channels:\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\n  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\ncustom_channels:\n  conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\n  deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/\n</code></pre>\n<p><strong>最近清华源也不太稳定~</strong>，使用后无法下载删除文件恢复默认即可：</p>\n<p>使用如下命令清除缓存（想要恢复默认也需要使用这个）</p>\n<pre><code class=\"lang-bash\">conda clean -i\n</code></pre>\n<p>然后，打开一个新的terminal ，看一下conda是否有更新：</p>\n<p>使用命令：<code>conda info</code></p>\n<p>结果应是如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/L9oMIZgW6JEk1U5.png\" alt=\"image-20240401165401775\"></p>\n<p>我们安装一个pytorch来试一试：</p>\n<pre><code class=\"lang-bash\">conda install pytorch torchvision torchaudio pytorch-cuda=12.1 -c pytorch -c nvidia\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/01/aqHx1r2QAL4CDFR.png\" alt=\"image-20240401172245221\"></p>\n<p>点击运行：</p>\n<p>这里注意，你的当前目录不一定是你的文件夹，在运行之前要搞明白下方的命令行当前的目录在哪里是不是你想要的位置，因为在python中有很多相对路径要去处理，关于这点我们继续看下一张图：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/QkYoVbXgyju13ZS.png\" alt=\"image-20240401172544313\"></p>\n<p>这里我们使用ls命令：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/cLyZJ8p2xjCgqbV.png\" alt=\"image-20240401192341093\"></p>\n<p>这里MINIST数据集下载到当前文件夹下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/3MslfcPEINVeDFi.png\" alt=\"image-20240401192455633\"></p>\n<p>那么相对路径是./此时的绝对路径是什么呢？</p>\n<p>不错就是命令行前端这一部分，我们打开目录就可以看到，数聚集被下载到了这里：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/EtfJeChiABw7r91.png\" alt=\"image-20240401192634760\" style=\"zoom:67%;\" /></p>\n<p>需要注意的是我们在base环境下安装的pytorch，右下角可以切换当前的解释器：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5EJBFVPhxKejkSw.png\" alt=\"image-20240401172633176\"></p>\n<p><strong>注意这里应是cuda</strong></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/1YRKaW4BApzJ2Fh.png\" alt=\"image-20240401172730849\"></p>\n<p>可以看到显卡被占用了：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/OjzRcpxnSM7F9v1.png\" alt=\"image-20240401172940076\" style=\"zoom:67%;\" /></p>\n<h3 id=\"容器的维护\"><a href=\"#容器的维护\" class=\"headerlink\" title=\"容器的维护\"></a>容器的维护</h3><p>维护自身的容器也非常重要，在运行的时候我们可能建立多个bash，这些bash在切换路径的时候被vscode所遗忘，就会造成内存虚高，这对我们来说是不利的，在运行代码之前，记住一定是运行代码之前，要维护好自己的容器，就少删除一些垃圾bash，使用命令：</p>\n<pre><code class=\"lang-bash\">ps -ef | grep shellIntegration-bash.sh\n</code></pre>\n<p>命令显示了多少个bash在运行：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/VTCxHhd95vN6iAB.png\" alt=\"image-20240401193622108\"></p>\n<p>我们保留最后一个数字最大的（因为是当前正在使用的这个，数字越大，创建的时候越靠后）</p>\n<p>使用命令杀掉前两个：</p>\n<pre><code>kill -9 10970 11173\n</code></pre><p>瞬间清净了~</p>\n<h4 id=\"开启免密码登录【可选】\"><a href=\"#开启免密码登录【可选】\" class=\"headerlink\" title=\"开启免密码登录【可选】\"></a>开启免密码登录【可选】</h4><p>开启免密码登录方式如下：</p>\n<p>首先打开你的ssh配置文件：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/dgPwOnKMThcuGAq.png\" alt=\"image-20240403170216864\" style=\"zoom:67%;\" /></p>\n<p>打开之后我们先放这里，等下再用。我们把这个路径叫做SSH配置路径，一定要记住这个路径，可以截图。</p>\n<p>我们在windos文件管理器中打开这个文件夹：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/v9sV2CIUkceziL1.png\" alt=\"image-20240403170412513\" style=\"zoom:80%;\" /></p>\n<p>这里分为两种情况，一种是你已经有了上述<code>id_rsa.pub</code>文件，如上图红框所示。</p>\n<p>另一种情况是没有这个文件，如下所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/z48qTZJ75yNMaoL.png\" alt=\"29c9f2a1ef1c58e7deeae3ac742c00f\" style=\"zoom:80%;\" /></p>\n<p>如果你没有，我们打开本地的系统命令行：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/KenW8bEy1gwz9UI.png\" alt=\"image-20240403170517802\" style=\"zoom:80%;\" /></p>\n<p>输入以下内容：</p>\n<pre><code class=\"lang-bash\">ssh-keygen\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/03/ivOr8YQgDAbcLq2.png\" alt=\"image-20240403170800926\" style=\"zoom:80%;\" /></p>\n<p>这里会提示让你输入密钥文件保存在哪里，这里就要放在你刚才的那个路径的文件下面，就是在vscode设置中打开的路径。记住是文件夹，不是文件，文件夹通常名字为：”.ssh”。</p>\n<p>输入之后一路回车下去直到看到这个图形生成：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/WmeMaujYiO9Ix6G.png\" alt=\"image-20240403171025319\" style=\"zoom:67%;\" /></p>\n<p>这里就结束了，然后我们回过头打开这个文件，使用vscode或者记事本都可以，同时我们也打开远程服务器的这个目录下的文件：</p>\n<p>这路径全名是：</p>\n<pre><code class=\"lang-bash\">/root/.ssh/authorized_keys\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/03/fHrEOVRzybCqh3W.png\" alt=\"image-20240403171155723\" style=\"zoom:67%;\" /></p>\n<p>打开之后我们将刚才打开的<code>id_rsa.pub</code>文件中的内容复制过来，通常如下图所示：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/xXeDynObsMYK9Ez.png\" alt=\"image-20240403171427044\" style=\"zoom:80%;\" /></p>\n<p>然后我们回到最初打开的ssh配置文件，在你的电脑SSH配置路径上，如果没打开的话，我们还是点击这里打开：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/6TcAB2P7SVDQUuC.png\" alt=\"image-20240403171545385\"></p>\n<p>添加一行内容：</p>\n<pre><code class=\"lang-bash\">IdentityFile &quot;C:\\Users\\NeoNexus\\.ssh\\id_rsa&quot;  这里的路径要修改成你的配置路径，要记得这里的id_rsa文件并不带pub后缀因为这是私钥\n</code></pre>\n<p>添加后效果如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/03/sVCgWRw4FJBLZtj.png\" alt=\"image-20240403171709698\"></p>\n<p>记得Ctrl+S保存修改</p>\n<p>重启VSCode就可以愉快免密码直接使用了。</p>\n"},{"title":"Git(1)","excerpt":"关于Git的一些补充，包含一些基础之类的，以防忘记","date":"2024-10-21T16:40:01.000Z","_content":"\n# Git——关于Git的一些补充（1）\n\n\n\n<img src=\"https://s2.loli.net/2024/10/22/zrPTFChwRB1jf9g.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527526564\" style=\"zoom: 50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\n\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n## Git基础\n\n基础内容请参考[廖雪峰Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)，这里只做一点概念的补充，来方便理解。\n\n### Git文件的生命周期\n\n此部分补充上述教程中**创建版本库**的部分内容\n\nGit所管理的文件可以处于以下五种状态：\n\n未跟踪（untracked）、未修改（clean）、已修改（modified）、已暂存（staged）、已提交（committed）\n\n```mermaid\nsequenceDiagram\nparticipant untracked\nclean ->> untracked:(rm)\nclean  -->> modified:(edit data or code)\nuntracked -->> staged:(add)\nmodified -->> staged: (add)\nstaged -->> +committed:(commit)\ncommitted ->>-clean: (committed)\n```\n\n上图中（浏览器右侧有切换到浅色主题的按钮，使用之后看的更清楚），线上的命令代表了在各个状态变化中使用的命令名称，状态clean和其翻译并对不上，其原因是clean代表的是刚刚完成克隆或者刚刚提交完成之后的仓库状态，详细状态切换及使用的命令的参数可以参考廖雪峰的教程。其中committed部分指的是每次提交完成之后工作区的代码又返回了clean状态，即没有变化，更改的意思，并没有其对应的命令。\n\n由此五种状态的转变可以引出——什么是**仓库**?\n\nGit是如何在存储空间中划分的?\n\n是如何将的代码在各个状态中进行保存的？\n\n### Git文件的存储空间的划分\n\n- **工作目录(Working Directory)：**工作目录实际上是项目中某一个版本的单次检出（check out）。这些文件是从Git目录下的压缩数据库内被提取出，放置在磁盘上以供使用和修改。也就是你能看到的项目内容。\n- **暂存区(Stage/Index)：暂存区是一个文件，一般位于Git目录中**，保存了下次提交内容的相关信息。有时候也被称之为**索引**。\n- **Git目录(Repository)：**：Git目录是保存项目元数据和对象数据库的地方。这是Git最重要的部分，也是其他计算机中克隆仓库时复制的内容。\n\n在你使用命令之后整个工作流程 上划分如下：\n\n```mermaid\nsequenceDiagram\nbox rgb(\t30,144,255, .5) Working Directory\nparticipant untracked\nparticipant clean\nparticipant modified\nend\n\nbox rgb(0,255,255, .5) Index\nparticipant staged\nend\n\nbox rgb(255,65,81,.8) Repository\nparticipant committed\nend\n\nclean ->> untracked:(rm)\nclean  -->> modified:(edit data or code)\n\nuntracked -->> staged:(add)\nmodified -->> staged: (add)\n\n\nstaged -->> +committed:(commit)\ncommitted ->>-clean: (committed)\n```\n\n蓝色部分是你的工作区域，也就是你修改的或者使用的代码皆是存在于此的,其中比较重要的是add和commit命令，使用这两个命令或者操作会将文件拉入Index区或者Repository区。受限于mermaid画图无法嵌套，实际上Index应是Repository区的一部分。\n\n### Git安装过程补充说明\n\n<img src=\"https://s2.loli.net/2024/03/20/Az8EiRo5dcKFJyU.png\" alt=\"git_pull\" style=\"zoom: 80%;\" />\n\n在安装过程中，git会让你选择pull操作的逻辑：\n\nFast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：\n\n```mermaid\nsequenceDiagram\n  main -->> orgin/main : pull\n```\n\nmain节点落后于服务器上的main（以后都称之为origin/main），此时执行Fast-forward操作就是将当把服务器的远程分支合并到main之上，也就是执行merge操作，此时main指针会向前走一个，这样的操作就是Fast-forward。\n\nmerge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：\n\n```mermaid\ngraph LR\n\nFirst_commit-->Second_commit\nFirst_commit --> Remote_commit\nSecond_commit -->merge_commit\nRemote_commit -->merge_commit\n```\n\n在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。\n\nRebase操作指的是在上述情况之上直接将Remote_commit修改，再合并到Second_commit之上：\n\n```mermaid\ngraph LR\n\nFirst_commit-->Second_commit\nSecond_commit -->Remote_commit_changed\n```\n\n这里选择默认即可。当然git pull --rebase操作不仅仅能实现这种效果，更多内容请参考下一篇，关于分支管理的内容。\n\n### Git的撤销操作\n\n#### 修正上一次的提交\n\n撤销上一次的提交指的是上一次的提交会被这次新的提交所覆盖，假设你的commit信息在上次输入错误了，我们就可以使用：\n\n```bash\ngit commit --amend\n```\n\n来再次进行提交，这次提交还是会打开输入信息框，修改后信息就会更新，且上一次提交就被覆盖了或者说应该是被修正了。\n\n第一次提交：\n\n<img src=\"https://s2.loli.net/2024/05/04/aiWVk9C2Pxw6l7N.png\" alt=\"image-20240504170607739\" style=\"zoom: 80%;\" />\n\n第二次提交：\n\n<img src=\"https://s2.loli.net/2024/05/04/C2itf4nJyqeI58h.png\" alt=\"image-20240504170440919\" style=\"zoom:80%;\" />\n\n#### 撤销暂存区的文件\n\n如果你不小心提交了不该提交的内容到index区，我们可以使用：\n\n```bash\ngit reset HEAD filename\n```\n\n来将其从暂存区中删除，记得不要使用rm，rm同时也会把其从工作区一起删除，这是二者的区别。\n\n### Git的rm命令补充\n\n要从版本管理系统中移除某一个文件，你需要把它先从已跟踪文件列表里面删除，然后再提交修改才可以，这里就要使用rm命令来实现，如果没有使用git rm，而是简单的直接从文件列表删除，就会产生如下后果：\n\n我们将copy结尾的文件删除，其已经被修改后提交：\n\n<img src=\"https://s2.loli.net/2024/05/04/qAQYlBJtoOypmdi.png\" alt=\"image-20240504161643586\" style=\"zoom: 80%;\" />\n\n我们将其手动删除，查看git的状态。\n\n![image-20240504162813549](https://s2.loli.net/2024/05/04/wcDiKaIsxWnbSTq.png)\n\n这里就会提示你有一个删除操作没有提交到暂存区，你需要手动使用\n\n```bash\ngit add .\n```\n\n来将删除操作暂存，并用commit命令提交到committed区。\n\n![image-20240504163209617](https://s2.loli.net/2024/05/04/CiKJpLdIoen9gDO.png)\n\n这样的操作略显麻烦，不过问题不大，我们可以直接使用rm命令来进行操作。**rm命令会将文件从暂存区和工作区直接删除**，这样提交的时候就不会有未跟踪的文件提示了。\n\n![image-20240504163329446](https://s2.loli.net/2024/05/04/vlLWsxwRzoQd31B.png)\n\n### Git的diff命令补充\n\n在安装完成之后，我们使用git bash 来查看 diff，在diff查看之前我们应该有一个已经committed的版本，方便我们来查看不同之处，这里使用的就是本篇文章的存储库来查看，\n\n写到这里，我们使用命令：\n\n```bash\ngit diff\n```\n\n效果如下：\n\n<img src=\"https://s2.loli.net/2024/05/04/Cda3xO4zrnKjIMQ.png\" alt=\"image-20240504065415466\" style=\"zoom:67%;\" />\n\n上图红红绿绿的部分，就是代表了修改的内容，这个表格是用来查看你相对于索引（index）（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。，我们从头开始，解析这一段代表的是什么意思。\n\n#### Git diff 解析\n\ngit所使用的diff是1990年，GNU diff率先推出了\"合并格式\"的diff，将需要比较文件的上下文合并在一起显示的一种diff格式、不同的diff格式不同，目前比较多的是GNU diff格式，git在此基础上添加了一些信息，用来显示一些内容。\n\n第一部分实际上是文件的基本信息，用来显示git的对象：\n\n一般格式如下：\n\n```bash\n　　diff --git a/f1 b/f1\n```\n\n进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。\n\n由于我的文件包含中文，所以中文被解析成了对应的字符，仔细看实际上是能发现对应的内容的：\n\n![image-20240504071327934](https://s2.loli.net/2024/05/04/h21MAUDnIKNGZci.png)\n\n然后一行显示的是两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）\n\n```bash\nindex a7a1862..fcf1525 100644\n```\n\n第三行表示进行比较的两个文件。\n\n![image-20240504071546670](https://s2.loli.net/2024/05/04/rx3Rhn2KuSql5sJ.png)\n\n\"---\"表示变动前的版本，\"+++\"表示变动后的版本。\n\n第二部分，变动的位置用两个@作为起首和结束。\n\n```bash\n@@ -33,14 +33,18 @@\n```\n\n`-33`中`-`代表第一个文件也就是上一个版本的文件，33代表第33行，`14`代表连续14行，合在一起意思就是从33行起连续14行，同样的，`+`代表变动后的文件，从33行开始一直到18行。\n\n第三部分，就是具体的修改内容了：\n\n![image-20240504160151147](https://s2.loli.net/2024/05/04/NDy3dtEzwSjgGiC.png)\n\n文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。图片中的`+- --` 均为文档自身包含一个-号，与git无关。\n\n参考：[读懂diff - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)\n\n## Git的mv命令\n\ngit并不会显式的跟踪文件的移动，如果你在文件管理系统中，直接重名了文件，git并不能发觉，会将其认为是一个新的文件，如此这般我们就需要将文件重新加入到跟踪队列，实际上我们可以说使用git mv命令来实现更快捷的操作：\n\n如图我们直接修改文件夹中的README.md文件为README，此时git会发觉到：\n\n![image-20240505201754780](https://s2.loli.net/2024/05/05/8WlI4OXQTgKF6zB.png)\n\n不过问题不大我们可以直接用mv来修改，这样git就会自动将其加入到追踪文件中：\n\n```bash\ngit mv README.md README\n```\n\n此时可以看到对应的文件被变成了这个样子：\n\n![image-20240505201925068](https://s2.loli.net/2024/05/05/XiM13yEHIQYtPhj.png)\n\n我们直接提交修改即可。需要注意的是，这一个操作相当于将其改名之后，并将其提交到stage区域，如果你想改回来，就需要将暂存区的内容清空使用上文的reset命令，最后再手动将名字修改回来。\n\n## Github Windows Version Install\n\n很多人上来就要安装Git for windows项目，我是不推荐的，Github针对Git开发了更方便的Github Desktop软件，主要包含GUI和操作，同时也针对了PowerShell做了兼容，这一点非常好。便于跨平台的使用。(这是比较老的说法了，实际上他们放弃了维护CLI部分，专注使用GUI部分，详见：[Where does Github desktop install command line version of Git - Stack Overflow](https://stackoverflow.com/questions/34565238/where-does-github-desktop-install-command-line-version-of-git))，但对新手来说GUI更适合一点，虽然无法使用全部的Git命令，但GUI已经足够了。\n\n下载地址如下：[GitHub Desktop | Simple collaboration from your desktop](https://desktop.github.com/)\n\n下载后注册账号登陆即可：\n\n<img src=\"https://s2.loli.net/2024/03/19/KMDWurV9LT4BEks.png\" alt=\"image-20240319230316232\" style=\"zoom:67%;\" />\n\n设置本地Git信息也是易如反掌，我的建议是对于工具类不需要太过深入了解，但是要有求知的心，建议看完Git for Windows项目的教程之后再来看这个会更加理解，本人入门的时候也是用的Git for Windows来进行配置的，整个过程受益颇多。\n\n<img src=\"https://s2.loli.net/2024/03/19/dP9IvSoFAfQ6gLR.png\" alt=\"image-20240319231027438\" style=\"zoom:67%;\" />\n\n我们可以简单过一遍教程：\n\n<img src=\"https://s2.loli.net/2024/03/19/X7RhIFyA136Gv95.png\" alt=\"image-20240319231115582\" style=\"zoom:67%;\" />\n\n这里省略了几个验证的细节，只需要点点就可以了，来到正式的界面：\n\n<img src=\"https://s2.loli.net/2024/03/19/eCDZ7wXPvxYk5RL.png\" alt=\"image-20240319231404949\" style=\"zoom:67%;\" />\n\n右侧写了教程的步骤，这里要我们创建一个新的分支，分支的含义在这里已经详细阐述了，简单来说就是可以允许不同版本的代码同时在相同仓库下进行开发。点击创建新的分支之后：\n\n<img src=\"https://s2.loli.net/2024/03/19/62jQlzivfNc5npk.png\" alt=\"image-20240319231619311\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/03/19/g3HRmj8wDQfIlAi.png\" alt=\"image-20240319231712553\" style=\"zoom: 80%;\" />\n\n会使用系统默认的编辑器打开对应文本文件：\n\n<img src=\"https://s2.loli.net/2024/03/19/d6F8ScXOKLpyTIP.png\" alt=\"image-20240319231807726\" style=\"zoom:67%;\" />\n\n在下方添加以下总结信息，这对参与项目者十分重要，来标识你干了什么。\n\n<img src=\"https://s2.loli.net/2024/03/19/AeWmqkO4jX2CQrs.png\" alt=\"image-20240319231917272\" style=\"zoom:67%;\" />\n\n最后将分支推送到Github之上：\n\n<img src=\"https://s2.loli.net/2024/03/19/CbuW9apGqoK5VHj.png\" alt=\"image-20240319232010779\" style=\"zoom:67%;\" />\n\npull request，是将你修改好的代码推送到审核人员那里，在审核人员将你实现的功能合并到主分支或者某一个分支之上。\n\n<img src=\"https://s2.loli.net/2024/03/19/NQGVcslxkqAomgY.png\" alt=\"image-20240319232103905\" style=\"zoom:67%;\" />\n\n跳转到网页进行申请处理\n\n<img src=\"https://s2.loli.net/2024/03/19/GfbUMrgaVCxk5O2.png\" alt=\"image-20240319232223793\" style=\"zoom: 80%;\" />\n\n审核人员审核之后也就是分支合并之后，可以选择删除你的开发分支，删除之后GIt上就剩下了一个分支。\n\n<img src=\"https://s2.loli.net/2024/03/19/6xujJ7V1TZhek8P.png\" alt=\"image-20240319232351124\" style=\"zoom: 80%;\" />","source":"_posts/Git__Base(1).md","raw":"---\ntitle: Git(1)\ncategories:\n  - git\ntags:\n  - branch\n  - base\nexcerpt: \"关于Git的一些补充，包含一些基础之类的，以防忘记\"\ndate: 2024/10/22 00:40:01\n---\n\n# Git——关于Git的一些补充（1）\n\n\n\n<img src=\"https://s2.loli.net/2024/10/22/zrPTFChwRB1jf9g.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527526564\" style=\"zoom: 50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\n\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n## Git基础\n\n基础内容请参考[廖雪峰Git教程](https://www.liaoxuefeng.com/wiki/896043488029600)，这里只做一点概念的补充，来方便理解。\n\n### Git文件的生命周期\n\n此部分补充上述教程中**创建版本库**的部分内容\n\nGit所管理的文件可以处于以下五种状态：\n\n未跟踪（untracked）、未修改（clean）、已修改（modified）、已暂存（staged）、已提交（committed）\n\n```mermaid\nsequenceDiagram\nparticipant untracked\nclean ->> untracked:(rm)\nclean  -->> modified:(edit data or code)\nuntracked -->> staged:(add)\nmodified -->> staged: (add)\nstaged -->> +committed:(commit)\ncommitted ->>-clean: (committed)\n```\n\n上图中（浏览器右侧有切换到浅色主题的按钮，使用之后看的更清楚），线上的命令代表了在各个状态变化中使用的命令名称，状态clean和其翻译并对不上，其原因是clean代表的是刚刚完成克隆或者刚刚提交完成之后的仓库状态，详细状态切换及使用的命令的参数可以参考廖雪峰的教程。其中committed部分指的是每次提交完成之后工作区的代码又返回了clean状态，即没有变化，更改的意思，并没有其对应的命令。\n\n由此五种状态的转变可以引出——什么是**仓库**?\n\nGit是如何在存储空间中划分的?\n\n是如何将的代码在各个状态中进行保存的？\n\n### Git文件的存储空间的划分\n\n- **工作目录(Working Directory)：**工作目录实际上是项目中某一个版本的单次检出（check out）。这些文件是从Git目录下的压缩数据库内被提取出，放置在磁盘上以供使用和修改。也就是你能看到的项目内容。\n- **暂存区(Stage/Index)：暂存区是一个文件，一般位于Git目录中**，保存了下次提交内容的相关信息。有时候也被称之为**索引**。\n- **Git目录(Repository)：**：Git目录是保存项目元数据和对象数据库的地方。这是Git最重要的部分，也是其他计算机中克隆仓库时复制的内容。\n\n在你使用命令之后整个工作流程 上划分如下：\n\n```mermaid\nsequenceDiagram\nbox rgb(\t30,144,255, .5) Working Directory\nparticipant untracked\nparticipant clean\nparticipant modified\nend\n\nbox rgb(0,255,255, .5) Index\nparticipant staged\nend\n\nbox rgb(255,65,81,.8) Repository\nparticipant committed\nend\n\nclean ->> untracked:(rm)\nclean  -->> modified:(edit data or code)\n\nuntracked -->> staged:(add)\nmodified -->> staged: (add)\n\n\nstaged -->> +committed:(commit)\ncommitted ->>-clean: (committed)\n```\n\n蓝色部分是你的工作区域，也就是你修改的或者使用的代码皆是存在于此的,其中比较重要的是add和commit命令，使用这两个命令或者操作会将文件拉入Index区或者Repository区。受限于mermaid画图无法嵌套，实际上Index应是Repository区的一部分。\n\n### Git安装过程补充说明\n\n<img src=\"https://s2.loli.net/2024/03/20/Az8EiRo5dcKFJyU.png\" alt=\"git_pull\" style=\"zoom: 80%;\" />\n\n在安装过程中，git会让你选择pull操作的逻辑：\n\nFast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：\n\n```mermaid\nsequenceDiagram\n  main -->> orgin/main : pull\n```\n\nmain节点落后于服务器上的main（以后都称之为origin/main），此时执行Fast-forward操作就是将当把服务器的远程分支合并到main之上，也就是执行merge操作，此时main指针会向前走一个，这样的操作就是Fast-forward。\n\nmerge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：\n\n```mermaid\ngraph LR\n\nFirst_commit-->Second_commit\nFirst_commit --> Remote_commit\nSecond_commit -->merge_commit\nRemote_commit -->merge_commit\n```\n\n在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。\n\nRebase操作指的是在上述情况之上直接将Remote_commit修改，再合并到Second_commit之上：\n\n```mermaid\ngraph LR\n\nFirst_commit-->Second_commit\nSecond_commit -->Remote_commit_changed\n```\n\n这里选择默认即可。当然git pull --rebase操作不仅仅能实现这种效果，更多内容请参考下一篇，关于分支管理的内容。\n\n### Git的撤销操作\n\n#### 修正上一次的提交\n\n撤销上一次的提交指的是上一次的提交会被这次新的提交所覆盖，假设你的commit信息在上次输入错误了，我们就可以使用：\n\n```bash\ngit commit --amend\n```\n\n来再次进行提交，这次提交还是会打开输入信息框，修改后信息就会更新，且上一次提交就被覆盖了或者说应该是被修正了。\n\n第一次提交：\n\n<img src=\"https://s2.loli.net/2024/05/04/aiWVk9C2Pxw6l7N.png\" alt=\"image-20240504170607739\" style=\"zoom: 80%;\" />\n\n第二次提交：\n\n<img src=\"https://s2.loli.net/2024/05/04/C2itf4nJyqeI58h.png\" alt=\"image-20240504170440919\" style=\"zoom:80%;\" />\n\n#### 撤销暂存区的文件\n\n如果你不小心提交了不该提交的内容到index区，我们可以使用：\n\n```bash\ngit reset HEAD filename\n```\n\n来将其从暂存区中删除，记得不要使用rm，rm同时也会把其从工作区一起删除，这是二者的区别。\n\n### Git的rm命令补充\n\n要从版本管理系统中移除某一个文件，你需要把它先从已跟踪文件列表里面删除，然后再提交修改才可以，这里就要使用rm命令来实现，如果没有使用git rm，而是简单的直接从文件列表删除，就会产生如下后果：\n\n我们将copy结尾的文件删除，其已经被修改后提交：\n\n<img src=\"https://s2.loli.net/2024/05/04/qAQYlBJtoOypmdi.png\" alt=\"image-20240504161643586\" style=\"zoom: 80%;\" />\n\n我们将其手动删除，查看git的状态。\n\n![image-20240504162813549](https://s2.loli.net/2024/05/04/wcDiKaIsxWnbSTq.png)\n\n这里就会提示你有一个删除操作没有提交到暂存区，你需要手动使用\n\n```bash\ngit add .\n```\n\n来将删除操作暂存，并用commit命令提交到committed区。\n\n![image-20240504163209617](https://s2.loli.net/2024/05/04/CiKJpLdIoen9gDO.png)\n\n这样的操作略显麻烦，不过问题不大，我们可以直接使用rm命令来进行操作。**rm命令会将文件从暂存区和工作区直接删除**，这样提交的时候就不会有未跟踪的文件提示了。\n\n![image-20240504163329446](https://s2.loli.net/2024/05/04/vlLWsxwRzoQd31B.png)\n\n### Git的diff命令补充\n\n在安装完成之后，我们使用git bash 来查看 diff，在diff查看之前我们应该有一个已经committed的版本，方便我们来查看不同之处，这里使用的就是本篇文章的存储库来查看，\n\n写到这里，我们使用命令：\n\n```bash\ngit diff\n```\n\n效果如下：\n\n<img src=\"https://s2.loli.net/2024/05/04/Cda3xO4zrnKjIMQ.png\" alt=\"image-20240504065415466\" style=\"zoom:67%;\" />\n\n上图红红绿绿的部分，就是代表了修改的内容，这个表格是用来查看你相对于索引（index）（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。，我们从头开始，解析这一段代表的是什么意思。\n\n#### Git diff 解析\n\ngit所使用的diff是1990年，GNU diff率先推出了\"合并格式\"的diff，将需要比较文件的上下文合并在一起显示的一种diff格式、不同的diff格式不同，目前比较多的是GNU diff格式，git在此基础上添加了一些信息，用来显示一些内容。\n\n第一部分实际上是文件的基本信息，用来显示git的对象：\n\n一般格式如下：\n\n```bash\n　　diff --git a/f1 b/f1\n```\n\n进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。\n\n由于我的文件包含中文，所以中文被解析成了对应的字符，仔细看实际上是能发现对应的内容的：\n\n![image-20240504071327934](https://s2.loli.net/2024/05/04/h21MAUDnIKNGZci.png)\n\n然后一行显示的是两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）\n\n```bash\nindex a7a1862..fcf1525 100644\n```\n\n第三行表示进行比较的两个文件。\n\n![image-20240504071546670](https://s2.loli.net/2024/05/04/rx3Rhn2KuSql5sJ.png)\n\n\"---\"表示变动前的版本，\"+++\"表示变动后的版本。\n\n第二部分，变动的位置用两个@作为起首和结束。\n\n```bash\n@@ -33,14 +33,18 @@\n```\n\n`-33`中`-`代表第一个文件也就是上一个版本的文件，33代表第33行，`14`代表连续14行，合在一起意思就是从33行起连续14行，同样的，`+`代表变动后的文件，从33行开始一直到18行。\n\n第三部分，就是具体的修改内容了：\n\n![image-20240504160151147](https://s2.loli.net/2024/05/04/NDy3dtEzwSjgGiC.png)\n\n文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。图片中的`+- --` 均为文档自身包含一个-号，与git无关。\n\n参考：[读懂diff - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)\n\n## Git的mv命令\n\ngit并不会显式的跟踪文件的移动，如果你在文件管理系统中，直接重名了文件，git并不能发觉，会将其认为是一个新的文件，如此这般我们就需要将文件重新加入到跟踪队列，实际上我们可以说使用git mv命令来实现更快捷的操作：\n\n如图我们直接修改文件夹中的README.md文件为README，此时git会发觉到：\n\n![image-20240505201754780](https://s2.loli.net/2024/05/05/8WlI4OXQTgKF6zB.png)\n\n不过问题不大我们可以直接用mv来修改，这样git就会自动将其加入到追踪文件中：\n\n```bash\ngit mv README.md README\n```\n\n此时可以看到对应的文件被变成了这个样子：\n\n![image-20240505201925068](https://s2.loli.net/2024/05/05/XiM13yEHIQYtPhj.png)\n\n我们直接提交修改即可。需要注意的是，这一个操作相当于将其改名之后，并将其提交到stage区域，如果你想改回来，就需要将暂存区的内容清空使用上文的reset命令，最后再手动将名字修改回来。\n\n## Github Windows Version Install\n\n很多人上来就要安装Git for windows项目，我是不推荐的，Github针对Git开发了更方便的Github Desktop软件，主要包含GUI和操作，同时也针对了PowerShell做了兼容，这一点非常好。便于跨平台的使用。(这是比较老的说法了，实际上他们放弃了维护CLI部分，专注使用GUI部分，详见：[Where does Github desktop install command line version of Git - Stack Overflow](https://stackoverflow.com/questions/34565238/where-does-github-desktop-install-command-line-version-of-git))，但对新手来说GUI更适合一点，虽然无法使用全部的Git命令，但GUI已经足够了。\n\n下载地址如下：[GitHub Desktop | Simple collaboration from your desktop](https://desktop.github.com/)\n\n下载后注册账号登陆即可：\n\n<img src=\"https://s2.loli.net/2024/03/19/KMDWurV9LT4BEks.png\" alt=\"image-20240319230316232\" style=\"zoom:67%;\" />\n\n设置本地Git信息也是易如反掌，我的建议是对于工具类不需要太过深入了解，但是要有求知的心，建议看完Git for Windows项目的教程之后再来看这个会更加理解，本人入门的时候也是用的Git for Windows来进行配置的，整个过程受益颇多。\n\n<img src=\"https://s2.loli.net/2024/03/19/dP9IvSoFAfQ6gLR.png\" alt=\"image-20240319231027438\" style=\"zoom:67%;\" />\n\n我们可以简单过一遍教程：\n\n<img src=\"https://s2.loli.net/2024/03/19/X7RhIFyA136Gv95.png\" alt=\"image-20240319231115582\" style=\"zoom:67%;\" />\n\n这里省略了几个验证的细节，只需要点点就可以了，来到正式的界面：\n\n<img src=\"https://s2.loli.net/2024/03/19/eCDZ7wXPvxYk5RL.png\" alt=\"image-20240319231404949\" style=\"zoom:67%;\" />\n\n右侧写了教程的步骤，这里要我们创建一个新的分支，分支的含义在这里已经详细阐述了，简单来说就是可以允许不同版本的代码同时在相同仓库下进行开发。点击创建新的分支之后：\n\n<img src=\"https://s2.loli.net/2024/03/19/62jQlzivfNc5npk.png\" alt=\"image-20240319231619311\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2024/03/19/g3HRmj8wDQfIlAi.png\" alt=\"image-20240319231712553\" style=\"zoom: 80%;\" />\n\n会使用系统默认的编辑器打开对应文本文件：\n\n<img src=\"https://s2.loli.net/2024/03/19/d6F8ScXOKLpyTIP.png\" alt=\"image-20240319231807726\" style=\"zoom:67%;\" />\n\n在下方添加以下总结信息，这对参与项目者十分重要，来标识你干了什么。\n\n<img src=\"https://s2.loli.net/2024/03/19/AeWmqkO4jX2CQrs.png\" alt=\"image-20240319231917272\" style=\"zoom:67%;\" />\n\n最后将分支推送到Github之上：\n\n<img src=\"https://s2.loli.net/2024/03/19/CbuW9apGqoK5VHj.png\" alt=\"image-20240319232010779\" style=\"zoom:67%;\" />\n\npull request，是将你修改好的代码推送到审核人员那里，在审核人员将你实现的功能合并到主分支或者某一个分支之上。\n\n<img src=\"https://s2.loli.net/2024/03/19/NQGVcslxkqAomgY.png\" alt=\"image-20240319232103905\" style=\"zoom:67%;\" />\n\n跳转到网页进行申请处理\n\n<img src=\"https://s2.loli.net/2024/03/19/GfbUMrgaVCxk5O2.png\" alt=\"image-20240319232223793\" style=\"zoom: 80%;\" />\n\n审核人员审核之后也就是分支合并之后，可以选择删除你的开发分支，删除之后GIt上就剩下了一个分支。\n\n<img src=\"https://s2.loli.net/2024/03/19/6xujJ7V1TZhek8P.png\" alt=\"image-20240319232351124\" style=\"zoom: 80%;\" />","slug":"Git__Base(1)","published":1,"updated":"2024-10-21T16:50:43.862Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti06001uyjin788828b3","content":"<h1><span id=\"git关于git的一些补充1\">Git——关于Git的一些补充（1）</span></h1>\n<img src=\"https://s2.loli.net/2024/10/22/zrPTFChwRB1jf9g.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527526564\" style=\"zoom: 50%;\">\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\">\n<h2><span id=\"提示图床在国外且动图比较多的情况下需要时间加载\">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2>\n<h2><span id=\"目录\">目录：</span></h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#git%E5%9F%BA%E7%A1%80\">Git基础</a>\n<ul>\n<li><a href=\"#git%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">Git文件的生命周期</a></li>\n<li><a href=\"#git%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86\">Git文件的存储空间的划分</a></li>\n<li><a href=\"#git%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E\">Git安装过程补充说明</a></li>\n<li><a href=\"#git%E7%9A%84%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C\">Git的撤销操作</a>\n<ul>\n<li><a href=\"#%E4%BF%AE%E6%AD%A3%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E6%8F%90%E4%BA%A4\">修正上一次的提交</a></li>\n<li><a href=\"#%E6%92%A4%E9%94%80%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6\">撤销暂存区的文件</a></li>\n</ul>\n</li>\n<li><a href=\"#git%E7%9A%84rm%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85\">Git的rm命令补充</a></li>\n<li><a href=\"#git%E7%9A%84diff%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85\">Git的diff命令补充</a>\n<ul>\n<li><a href=\"#git-diff-%E8%A7%A3%E6%9E%90\">Git diff 解析</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#git%E7%9A%84mv%E5%91%BD%E4%BB%A4\">Git的mv命令</a></li>\n<li><a href=\"#github-windows-version-install\">Github Windows Version Install</a></li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2><span id=\"git基础\">Git基础</span></h2>\n<p>基础内容请参考<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰Git教程</a>，这里只做一点概念的补充，来方便理解。</p>\n<h3><span id=\"git文件的生命周期\">Git文件的生命周期</span></h3>\n<p>此部分补充上述教程中<strong>创建版本库</strong>的部分内容</p>\n<p>Git所管理的文件可以处于以下五种状态：</p>\n<p>未跟踪（untracked）、未修改（clean）、已修改（modified）、已暂存（staged）、已提交（committed）</p>\n<pre class=\"mermaid\">sequenceDiagram\nparticipant untracked\nclean -&gt;&gt; untracked:(rm)\nclean  --&gt;&gt; modified:(edit data or code)\nuntracked --&gt;&gt; staged:(add)\nmodified --&gt;&gt; staged: (add)\nstaged --&gt;&gt; +committed:(commit)\ncommitted -&gt;&gt;-clean: (committed)</pre>\n<p>上图中（浏览器右侧有切换到浅色主题的按钮，使用之后看的更清楚），线上的命令代表了在各个状态变化中使用的命令名称，状态clean和其翻译并对不上，其原因是clean代表的是刚刚完成克隆或者刚刚提交完成之后的仓库状态，详细状态切换及使用的命令的参数可以参考廖雪峰的教程。其中committed部分指的是每次提交完成之后工作区的代码又返回了clean状态，即没有变化，更改的意思，并没有其对应的命令。</p>\n<p>由此五种状态的转变可以引出——什么是<strong>仓库</strong>?</p>\n<p>Git是如何在存储空间中划分的?</p>\n<p>是如何将的代码在各个状态中进行保存的？</p>\n<h3><span id=\"git文件的存储空间的划分\">Git文件的存储空间的划分</span></h3>\n<ul>\n<li>**工作目录(Working Directory)：**工作目录实际上是项目中某一个版本的单次检出（check out）。这些文件是从Git目录下的压缩数据库内被提取出，放置在磁盘上以供使用和修改。也就是你能看到的项目内容。</li>\n<li><strong>暂存区(Stage/Index)：暂存区是一个文件，一般位于Git目录中</strong>，保存了下次提交内容的相关信息。有时候也被称之为<strong>索引</strong>。</li>\n<li><strong>Git目录(Repository)：</strong>：Git目录是保存项目元数据和对象数据库的地方。这是Git最重要的部分，也是其他计算机中克隆仓库时复制的内容。</li>\n</ul>\n<p>在你使用命令之后整个工作流程 上划分如下：</p>\n<pre class=\"mermaid\">sequenceDiagram\nbox rgb(\t30,144,255, .5) Working Directory\nparticipant untracked\nparticipant clean\nparticipant modified\nend\n\nbox rgb(0,255,255, .5) Index\nparticipant staged\nend\n\nbox rgb(255,65,81,.8) Repository\nparticipant committed\nend\n\nclean -&gt;&gt; untracked:(rm)\nclean  --&gt;&gt; modified:(edit data or code)\n\nuntracked --&gt;&gt; staged:(add)\nmodified --&gt;&gt; staged: (add)\n\n\nstaged --&gt;&gt; +committed:(commit)\ncommitted -&gt;&gt;-clean: (committed)</pre>\n<p>蓝色部分是你的工作区域，也就是你修改的或者使用的代码皆是存在于此的,其中比较重要的是add和commit命令，使用这两个命令或者操作会将文件拉入Index区或者Repository区。受限于mermaid画图无法嵌套，实际上Index应是Repository区的一部分。</p>\n<h3><span id=\"git安装过程补充说明\">Git安装过程补充说明</span></h3>\n<img src=\"https://s2.loli.net/2024/03/20/Az8EiRo5dcKFJyU.png\" alt=\"git_pull\" style=\"zoom: 80%;\">\n<p>在安装过程中，git会让你选择pull操作的逻辑：</p>\n<p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p>\n<pre class=\"mermaid\">sequenceDiagram\n  main --&gt;&gt; orgin/main : pull</pre>\n<p>main节点落后于服务器上的main（以后都称之为origin/main），此时执行Fast-forward操作就是将当把服务器的远程分支合并到main之上，也就是执行merge操作，此时main指针会向前走一个，这样的操作就是Fast-forward。</p>\n<p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p>\n<pre class=\"mermaid\">graph LR\n\nFirst_commit--&gt;Second_commit\nFirst_commit --&gt; Remote_commit\nSecond_commit --&gt;merge_commit\nRemote_commit --&gt;merge_commit</pre>\n<p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p>\n<p>Rebase操作指的是在上述情况之上直接将Remote_commit修改，再合并到Second_commit之上：</p>\n<pre class=\"mermaid\">graph LR\n\nFirst_commit--&gt;Second_commit\nSecond_commit --&gt;Remote_commit_changed</pre>\n<p>这里选择默认即可。当然git pull --rebase操作不仅仅能实现这种效果，更多内容请参考下一篇，关于分支管理的内容。</p>\n<h3><span id=\"git的撤销操作\">Git的撤销操作</span></h3>\n<h4><span id=\"修正上一次的提交\">修正上一次的提交</span></h4>\n<p>撤销上一次的提交指的是上一次的提交会被这次新的提交所覆盖，假设你的commit信息在上次输入错误了，我们就可以使用：</p>\n<pre><code class=\"language-bash\">git commit --amend\n</code></pre>\n<p>来再次进行提交，这次提交还是会打开输入信息框，修改后信息就会更新，且上一次提交就被覆盖了或者说应该是被修正了。</p>\n<p>第一次提交：</p>\n<img src=\"https://s2.loli.net/2024/05/04/aiWVk9C2Pxw6l7N.png\" alt=\"image-20240504170607739\" style=\"zoom: 80%;\">\n<p>第二次提交：</p>\n<img src=\"https://s2.loli.net/2024/05/04/C2itf4nJyqeI58h.png\" alt=\"image-20240504170440919\" style=\"zoom:80%;\">\n<h4><span id=\"撤销暂存区的文件\">撤销暂存区的文件</span></h4>\n<p>如果你不小心提交了不该提交的内容到index区，我们可以使用：</p>\n<pre><code class=\"language-bash\">git reset HEAD filename\n</code></pre>\n<p>来将其从暂存区中删除，记得不要使用rm，rm同时也会把其从工作区一起删除，这是二者的区别。</p>\n<h3><span id=\"git的rm命令补充\">Git的rm命令补充</span></h3>\n<p>要从版本管理系统中移除某一个文件，你需要把它先从已跟踪文件列表里面删除，然后再提交修改才可以，这里就要使用rm命令来实现，如果没有使用git rm，而是简单的直接从文件列表删除，就会产生如下后果：</p>\n<p>我们将copy结尾的文件删除，其已经被修改后提交：</p>\n<img src=\"https://s2.loli.net/2024/05/04/qAQYlBJtoOypmdi.png\" alt=\"image-20240504161643586\" style=\"zoom: 80%;\">\n<p>我们将其手动删除，查看git的状态。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/wcDiKaIsxWnbSTq.png\" alt=\"image-20240504162813549\"></p>\n<p>这里就会提示你有一个删除操作没有提交到暂存区，你需要手动使用</p>\n<pre><code class=\"language-bash\">git add .\n</code></pre>\n<p>来将删除操作暂存，并用commit命令提交到committed区。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/CiKJpLdIoen9gDO.png\" alt=\"image-20240504163209617\"></p>\n<p>这样的操作略显麻烦，不过问题不大，我们可以直接使用rm命令来进行操作。<strong>rm命令会将文件从暂存区和工作区直接删除</strong>，这样提交的时候就不会有未跟踪的文件提示了。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/vlLWsxwRzoQd31B.png\" alt=\"image-20240504163329446\"></p>\n<h3><span id=\"git的diff命令补充\">Git的diff命令补充</span></h3>\n<p>在安装完成之后，我们使用git bash 来查看 diff，在diff查看之前我们应该有一个已经committed的版本，方便我们来查看不同之处，这里使用的就是本篇文章的存储库来查看，</p>\n<p>写到这里，我们使用命令：</p>\n<pre><code class=\"language-bash\">git diff\n</code></pre>\n<p>效果如下：</p>\n<img src=\"https://s2.loli.net/2024/05/04/Cda3xO4zrnKjIMQ.png\" alt=\"image-20240504065415466\" style=\"zoom:67%;\">\n<p>上图红红绿绿的部分，就是代表了修改的内容，这个表格是用来查看你相对于索引（index）（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。，我们从头开始，解析这一段代表的是什么意思。</p>\n<h4><span id=\"git-diff-解析\">Git diff 解析</span></h4>\n<p>git所使用的diff是1990年，GNU diff率先推出了\"合并格式\"的diff，将需要比较文件的上下文合并在一起显示的一种diff格式、不同的diff格式不同，目前比较多的是GNU diff格式，git在此基础上添加了一些信息，用来显示一些内容。</p>\n<p>第一部分实际上是文件的基本信息，用来显示git的对象：</p>\n<p>一般格式如下：</p>\n<pre><code class=\"language-bash\">　　diff --git a/f1 b/f1\n</code></pre>\n<p>进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。</p>\n<p>由于我的文件包含中文，所以中文被解析成了对应的字符，仔细看实际上是能发现对应的内容的：</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/h21MAUDnIKNGZci.png\" alt=\"image-20240504071327934\"></p>\n<p>然后一行显示的是两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）</p>\n<pre><code class=\"language-bash\">index a7a1862..fcf1525 100644\n</code></pre>\n<p>第三行表示进行比较的两个文件。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/rx3Rhn2KuSql5sJ.png\" alt=\"image-20240504071546670\"></p>\n<p>\"—“表示变动前的版本，”+++\"表示变动后的版本。</p>\n<p>第二部分，变动的位置用两个@作为起首和结束。</p>\n<pre><code class=\"language-bash\">@@ -33,14 +33,18 @@\n</code></pre>\n<p><code>-33</code>中<code>-</code>代表第一个文件也就是上一个版本的文件，33代表第33行，<code>14</code>代表连续14行，合在一起意思就是从33行起连续14行，同样的，<code>+</code>代表变动后的文件，从33行开始一直到18行。</p>\n<p>第三部分，就是具体的修改内容了：</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/NDy3dtEzwSjgGiC.png\" alt=\"image-20240504160151147\"></p>\n<p>文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。图片中的<code>+- --</code> 均为文档自身包含一个-号，与git无关。</p>\n<p>参考：<a href=\"https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html\">读懂diff - 阮一峰的网络日志 (ruanyifeng.com)</a></p>\n<h2><span id=\"git的mv命令\">Git的mv命令</span></h2>\n<p>git并不会显式的跟踪文件的移动，如果你在文件管理系统中，直接重名了文件，git并不能发觉，会将其认为是一个新的文件，如此这般我们就需要将文件重新加入到跟踪队列，实际上我们可以说使用git mv命令来实现更快捷的操作：</p>\n<p>如图我们直接修改文件夹中的README.md文件为README，此时git会发觉到：</p>\n<p><img src=\"https://s2.loli.net/2024/05/05/8WlI4OXQTgKF6zB.png\" alt=\"image-20240505201754780\"></p>\n<p>不过问题不大我们可以直接用mv来修改，这样git就会自动将其加入到追踪文件中：</p>\n<pre><code class=\"language-bash\">git mv README.md README\n</code></pre>\n<p>此时可以看到对应的文件被变成了这个样子：</p>\n<p><img src=\"https://s2.loli.net/2024/05/05/XiM13yEHIQYtPhj.png\" alt=\"image-20240505201925068\"></p>\n<p>我们直接提交修改即可。需要注意的是，这一个操作相当于将其改名之后，并将其提交到stage区域，如果你想改回来，就需要将暂存区的内容清空使用上文的reset命令，最后再手动将名字修改回来。</p>\n<h2><span id=\"github-windows-version-install\">Github Windows Version Install</span></h2>\n<p>很多人上来就要安装Git for windows项目，我是不推荐的，Github针对Git开发了更方便的Github Desktop软件，主要包含GUI和操作，同时也针对了PowerShell做了兼容，这一点非常好。便于跨平台的使用。(这是比较老的说法了，实际上他们放弃了维护CLI部分，专注使用GUI部分，详见：<a href=\"https://stackoverflow.com/questions/34565238/where-does-github-desktop-install-command-line-version-of-git\">Where does Github desktop install command line version of Git - Stack Overflow</a>)，但对新手来说GUI更适合一点，虽然无法使用全部的Git命令，但GUI已经足够了。</p>\n<p>下载地址如下：<a href=\"https://desktop.github.com/\">GitHub Desktop | Simple collaboration from your desktop</a></p>\n<p>下载后注册账号登陆即可：</p>\n<img src=\"https://s2.loli.net/2024/03/19/KMDWurV9LT4BEks.png\" alt=\"image-20240319230316232\" style=\"zoom:67%;\">\n<p>设置本地Git信息也是易如反掌，我的建议是对于工具类不需要太过深入了解，但是要有求知的心，建议看完Git for Windows项目的教程之后再来看这个会更加理解，本人入门的时候也是用的Git for Windows来进行配置的，整个过程受益颇多。</p>\n<img src=\"https://s2.loli.net/2024/03/19/dP9IvSoFAfQ6gLR.png\" alt=\"image-20240319231027438\" style=\"zoom:67%;\">\n<p>我们可以简单过一遍教程：</p>\n<img src=\"https://s2.loli.net/2024/03/19/X7RhIFyA136Gv95.png\" alt=\"image-20240319231115582\" style=\"zoom:67%;\">\n<p>这里省略了几个验证的细节，只需要点点就可以了，来到正式的界面：</p>\n<img src=\"https://s2.loli.net/2024/03/19/eCDZ7wXPvxYk5RL.png\" alt=\"image-20240319231404949\" style=\"zoom:67%;\">\n<p>右侧写了教程的步骤，这里要我们创建一个新的分支，分支的含义在这里已经详细阐述了，简单来说就是可以允许不同版本的代码同时在相同仓库下进行开发。点击创建新的分支之后：</p>\n<img src=\"https://s2.loli.net/2024/03/19/62jQlzivfNc5npk.png\" alt=\"image-20240319231619311\" style=\"zoom:67%;\">\n<img src=\"https://s2.loli.net/2024/03/19/g3HRmj8wDQfIlAi.png\" alt=\"image-20240319231712553\" style=\"zoom: 80%;\">\n<p>会使用系统默认的编辑器打开对应文本文件：</p>\n<img src=\"https://s2.loli.net/2024/03/19/d6F8ScXOKLpyTIP.png\" alt=\"image-20240319231807726\" style=\"zoom:67%;\">\n<p>在下方添加以下总结信息，这对参与项目者十分重要，来标识你干了什么。</p>\n<img src=\"https://s2.loli.net/2024/03/19/AeWmqkO4jX2CQrs.png\" alt=\"image-20240319231917272\" style=\"zoom:67%;\">\n<p>最后将分支推送到Github之上：</p>\n<img src=\"https://s2.loli.net/2024/03/19/CbuW9apGqoK5VHj.png\" alt=\"image-20240319232010779\" style=\"zoom:67%;\">\n<p>pull request，是将你修改好的代码推送到审核人员那里，在审核人员将你实现的功能合并到主分支或者某一个分支之上。</p>\n<img src=\"https://s2.loli.net/2024/03/19/NQGVcslxkqAomgY.png\" alt=\"image-20240319232103905\" style=\"zoom:67%;\">\n<p>跳转到网页进行申请处理</p>\n<img src=\"https://s2.loli.net/2024/03/19/GfbUMrgaVCxk5O2.png\" alt=\"image-20240319232223793\" style=\"zoom: 80%;\">\n<p>审核人员审核之后也就是分支合并之后，可以选择删除你的开发分支，删除之后GIt上就剩下了一个分支。</p>\n<img src=\"https://s2.loli.net/2024/03/19/6xujJ7V1TZhek8P.png\" alt=\"image-20240319232351124\" style=\"zoom: 80%;\">","more":"<h1>Git——关于Git的一些补充（1）</h1>\n<img src=\"https://s2.loli.net/2024/10/22/zrPTFChwRB1jf9g.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527526564\" style=\"zoom: 50%;\" />\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n<h2 id=\"提示：图床在国外且动图比较多的情况下，需要时间加载。\">提示：图床在国外且动图比较多的情况下，需要时间加载。</h2>\n<h2 id=\"目录：\">目录：</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#git%E5%9F%BA%E7%A1%80\">Git基础</a>\n<ul>\n<li><a href=\"#git%E6%96%87%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\">Git文件的生命周期</a></li>\n<li><a href=\"#git%E6%96%87%E4%BB%B6%E7%9A%84%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%92%E5%88%86\">Git文件的存储空间的划分</a></li>\n<li><a href=\"#git%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E\">Git安装过程补充说明</a></li>\n<li><a href=\"#git%E7%9A%84%E6%92%A4%E9%94%80%E6%93%8D%E4%BD%9C\">Git的撤销操作</a>\n<ul>\n<li><a href=\"#%E4%BF%AE%E6%AD%A3%E4%B8%8A%E4%B8%80%E6%AC%A1%E7%9A%84%E6%8F%90%E4%BA%A4\">修正上一次的提交</a></li>\n<li><a href=\"#%E6%92%A4%E9%94%80%E6%9A%82%E5%AD%98%E5%8C%BA%E7%9A%84%E6%96%87%E4%BB%B6\">撤销暂存区的文件</a></li>\n</ul>\n</li>\n<li><a href=\"#git%E7%9A%84rm%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85\">Git的rm命令补充</a></li>\n<li><a href=\"#git%E7%9A%84diff%E5%91%BD%E4%BB%A4%E8%A1%A5%E5%85%85\">Git的diff命令补充</a>\n<ul>\n<li><a href=\"#git-diff-%E8%A7%A3%E6%9E%90\">Git diff 解析</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"#git%E7%9A%84mv%E5%91%BD%E4%BB%A4\">Git的mv命令</a></li>\n<li><a href=\"#github-windows-version-install\">Github Windows Version Install</a></li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2 id=\"Git基础\">Git基础</h2>\n<p>基础内容请参考<a href=\"https://www.liaoxuefeng.com/wiki/896043488029600\">廖雪峰Git教程</a>，这里只做一点概念的补充，来方便理解。</p>\n<h3 id=\"Git文件的生命周期\">Git文件的生命周期</h3>\n<p>此部分补充上述教程中<strong>创建版本库</strong>的部分内容</p>\n<p>Git所管理的文件可以处于以下五种状态：</p>\n<p>未跟踪（untracked）、未修改（clean）、已修改（modified）、已暂存（staged）、已提交（committed）</p>\n<pre class=\"mermaid\">sequenceDiagram\nparticipant untracked\nclean ->> untracked:(rm)\nclean  -->> modified:(edit data or code)\nuntracked -->> staged:(add)\nmodified -->> staged: (add)\nstaged -->> +committed:(commit)\ncommitted ->>-clean: (committed)</pre>\n<p>上图中（浏览器右侧有切换到浅色主题的按钮，使用之后看的更清楚），线上的命令代表了在各个状态变化中使用的命令名称，状态clean和其翻译并对不上，其原因是clean代表的是刚刚完成克隆或者刚刚提交完成之后的仓库状态，详细状态切换及使用的命令的参数可以参考廖雪峰的教程。其中committed部分指的是每次提交完成之后工作区的代码又返回了clean状态，即没有变化，更改的意思，并没有其对应的命令。</p>\n<p>由此五种状态的转变可以引出——什么是<strong>仓库</strong>?</p>\n<p>Git是如何在存储空间中划分的?</p>\n<p>是如何将的代码在各个状态中进行保存的？</p>\n<h3 id=\"Git文件的存储空间的划分\">Git文件的存储空间的划分</h3>\n<ul>\n<li>**工作目录(Working Directory)：**工作目录实际上是项目中某一个版本的单次检出（check out）。这些文件是从Git目录下的压缩数据库内被提取出，放置在磁盘上以供使用和修改。也就是你能看到的项目内容。</li>\n<li><strong>暂存区(Stage/Index)：暂存区是一个文件，一般位于Git目录中</strong>，保存了下次提交内容的相关信息。有时候也被称之为<strong>索引</strong>。</li>\n<li><strong>Git目录(Repository)：</strong>：Git目录是保存项目元数据和对象数据库的地方。这是Git最重要的部分，也是其他计算机中克隆仓库时复制的内容。</li>\n</ul>\n<p>在你使用命令之后整个工作流程 上划分如下：</p>\n<pre class=\"mermaid\">sequenceDiagram\nbox rgb(\t30,144,255, .5) Working Directory\nparticipant untracked\nparticipant clean\nparticipant modified\nend\n\nbox rgb(0,255,255, .5) Index\nparticipant staged\nend\n\nbox rgb(255,65,81,.8) Repository\nparticipant committed\nend\n\nclean ->> untracked:(rm)\nclean  -->> modified:(edit data or code)\n\nuntracked -->> staged:(add)\nmodified -->> staged: (add)\n\n\nstaged -->> +committed:(commit)\ncommitted ->>-clean: (committed)</pre>\n<p>蓝色部分是你的工作区域，也就是你修改的或者使用的代码皆是存在于此的,其中比较重要的是add和commit命令，使用这两个命令或者操作会将文件拉入Index区或者Repository区。受限于mermaid画图无法嵌套，实际上Index应是Repository区的一部分。</p>\n<h3 id=\"Git安装过程补充说明\">Git安装过程补充说明</h3>\n<img src=\"https://s2.loli.net/2024/03/20/Az8EiRo5dcKFJyU.png\" alt=\"git_pull\" style=\"zoom: 80%;\" />\n<p>在安装过程中，git会让你选择pull操作的逻辑：</p>\n<p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p>\n<pre class=\"mermaid\">sequenceDiagram\n  main -->> orgin/main : pull</pre>\n<p>main节点落后于服务器上的main（以后都称之为origin/main），此时执行Fast-forward操作就是将当把服务器的远程分支合并到main之上，也就是执行merge操作，此时main指针会向前走一个，这样的操作就是Fast-forward。</p>\n<p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p>\n<pre class=\"mermaid\">graph LR\n\nFirst_commit-->Second_commit\nFirst_commit --> Remote_commit\nSecond_commit -->merge_commit\nRemote_commit -->merge_commit</pre>\n<p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p>\n<p>Rebase操作指的是在上述情况之上直接将Remote_commit修改，再合并到Second_commit之上：</p>\n<pre class=\"mermaid\">graph LR\n\nFirst_commit-->Second_commit\nSecond_commit -->Remote_commit_changed</pre>\n<p>这里选择默认即可。当然git pull --rebase操作不仅仅能实现这种效果，更多内容请参考下一篇，关于分支管理的内容。</p>\n<h3 id=\"Git的撤销操作\">Git的撤销操作</h3>\n<h4 id=\"修正上一次的提交\">修正上一次的提交</h4>\n<p>撤销上一次的提交指的是上一次的提交会被这次新的提交所覆盖，假设你的commit信息在上次输入错误了，我们就可以使用：</p>\n<pre><code class=\"language-bash\">git commit --amend\n</code></pre>\n<p>来再次进行提交，这次提交还是会打开输入信息框，修改后信息就会更新，且上一次提交就被覆盖了或者说应该是被修正了。</p>\n<p>第一次提交：</p>\n<img src=\"https://s2.loli.net/2024/05/04/aiWVk9C2Pxw6l7N.png\" alt=\"image-20240504170607739\" style=\"zoom: 80%;\" />\n<p>第二次提交：</p>\n<img src=\"https://s2.loli.net/2024/05/04/C2itf4nJyqeI58h.png\" alt=\"image-20240504170440919\" style=\"zoom:80%;\" />\n<h4 id=\"撤销暂存区的文件\">撤销暂存区的文件</h4>\n<p>如果你不小心提交了不该提交的内容到index区，我们可以使用：</p>\n<pre><code class=\"language-bash\">git reset HEAD filename\n</code></pre>\n<p>来将其从暂存区中删除，记得不要使用rm，rm同时也会把其从工作区一起删除，这是二者的区别。</p>\n<h3 id=\"Git的rm命令补充\">Git的rm命令补充</h3>\n<p>要从版本管理系统中移除某一个文件，你需要把它先从已跟踪文件列表里面删除，然后再提交修改才可以，这里就要使用rm命令来实现，如果没有使用git rm，而是简单的直接从文件列表删除，就会产生如下后果：</p>\n<p>我们将copy结尾的文件删除，其已经被修改后提交：</p>\n<img src=\"https://s2.loli.net/2024/05/04/qAQYlBJtoOypmdi.png\" alt=\"image-20240504161643586\" style=\"zoom: 80%;\" />\n<p>我们将其手动删除，查看git的状态。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/wcDiKaIsxWnbSTq.png\" alt=\"image-20240504162813549\"></p>\n<p>这里就会提示你有一个删除操作没有提交到暂存区，你需要手动使用</p>\n<pre><code class=\"language-bash\">git add .\n</code></pre>\n<p>来将删除操作暂存，并用commit命令提交到committed区。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/CiKJpLdIoen9gDO.png\" alt=\"image-20240504163209617\"></p>\n<p>这样的操作略显麻烦，不过问题不大，我们可以直接使用rm命令来进行操作。<strong>rm命令会将文件从暂存区和工作区直接删除</strong>，这样提交的时候就不会有未跟踪的文件提示了。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/vlLWsxwRzoQd31B.png\" alt=\"image-20240504163329446\"></p>\n<h3 id=\"Git的diff命令补充\">Git的diff命令补充</h3>\n<p>在安装完成之后，我们使用git bash 来查看 diff，在diff查看之前我们应该有一个已经committed的版本，方便我们来查看不同之处，这里使用的就是本篇文章的存储库来查看，</p>\n<p>写到这里，我们使用命令：</p>\n<pre><code class=\"language-bash\">git diff\n</code></pre>\n<p>效果如下：</p>\n<img src=\"https://s2.loli.net/2024/05/04/Cda3xO4zrnKjIMQ.png\" alt=\"image-20240504065415466\" style=\"zoom:67%;\" />\n<p>上图红红绿绿的部分，就是代表了修改的内容，这个表格是用来查看你相对于索引（index）（下次提交的暂存区域）所做的修改。 换句话说，这些差异是你_可以告诉 Git 进一步添加到索引中，但你仍然没有。，我们从头开始，解析这一段代表的是什么意思。</p>\n<h4 id=\"Git-diff-解析\">Git diff 解析</h4>\n<p>git所使用的diff是1990年，GNU diff率先推出了&quot;合并格式&quot;的diff，将需要比较文件的上下文合并在一起显示的一种diff格式、不同的diff格式不同，目前比较多的是GNU diff格式，git在此基础上添加了一些信息，用来显示一些内容。</p>\n<p>第一部分实际上是文件的基本信息，用来显示git的对象：</p>\n<p>一般格式如下：</p>\n<pre><code class=\"language-bash\">　　diff --git a/f1 b/f1\n</code></pre>\n<p>进行比较的是，a版本的f1（即变动前）和b版本的f1（即变动后）。</p>\n<p>由于我的文件包含中文，所以中文被解析成了对应的字符，仔细看实际上是能发现对应的内容的：</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/h21MAUDnIKNGZci.png\" alt=\"image-20240504071327934\"></p>\n<p>然后一行显示的是两个版本的git哈希值（index区域的6f8a38c对象，与工作目录区域的449b072对象进行比较），最后的六位数字是对象的模式（普通文件，644权限）</p>\n<pre><code class=\"language-bash\">index a7a1862..fcf1525 100644\n</code></pre>\n<p>第三行表示进行比较的两个文件。</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/rx3Rhn2KuSql5sJ.png\" alt=\"image-20240504071546670\"></p>\n<p>&quot;—“表示变动前的版本，”+++&quot;表示变动后的版本。</p>\n<p>第二部分，变动的位置用两个@作为起首和结束。</p>\n<pre><code class=\"language-bash\">@@ -33,14 +33,18 @@\n</code></pre>\n<p><code>-33</code>中<code>-</code>代表第一个文件也就是上一个版本的文件，33代表第33行，<code>14</code>代表连续14行，合在一起意思就是从33行起连续14行，同样的，<code>+</code>代表变动后的文件，从33行开始一直到18行。</p>\n<p>第三部分，就是具体的修改内容了：</p>\n<p><img src=\"https://s2.loli.net/2024/05/04/NDy3dtEzwSjgGiC.png\" alt=\"image-20240504160151147\"></p>\n<p>文件内容的每一行最前面，还有一个标记位。如果为空，表示该行无变化；如果是感叹号（!），表示该行有改动；如果是减号（-），表示该行被删除；如果是加号（+），表示该行为新增。图片中的<code>+- --</code> 均为文档自身包含一个-号，与git无关。</p>\n<p>参考：<a href=\"https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html\">读懂diff - 阮一峰的网络日志 (ruanyifeng.com)</a></p>\n<h2 id=\"Git的mv命令\">Git的mv命令</h2>\n<p>git并不会显式的跟踪文件的移动，如果你在文件管理系统中，直接重名了文件，git并不能发觉，会将其认为是一个新的文件，如此这般我们就需要将文件重新加入到跟踪队列，实际上我们可以说使用git mv命令来实现更快捷的操作：</p>\n<p>如图我们直接修改文件夹中的README.md文件为README，此时git会发觉到：</p>\n<p><img src=\"https://s2.loli.net/2024/05/05/8WlI4OXQTgKF6zB.png\" alt=\"image-20240505201754780\"></p>\n<p>不过问题不大我们可以直接用mv来修改，这样git就会自动将其加入到追踪文件中：</p>\n<pre><code class=\"language-bash\">git mv README.md README\n</code></pre>\n<p>此时可以看到对应的文件被变成了这个样子：</p>\n<p><img src=\"https://s2.loli.net/2024/05/05/XiM13yEHIQYtPhj.png\" alt=\"image-20240505201925068\"></p>\n<p>我们直接提交修改即可。需要注意的是，这一个操作相当于将其改名之后，并将其提交到stage区域，如果你想改回来，就需要将暂存区的内容清空使用上文的reset命令，最后再手动将名字修改回来。</p>\n<h2 id=\"Github-Windows-Version-Install\">Github Windows Version Install</h2>\n<p>很多人上来就要安装Git for windows项目，我是不推荐的，Github针对Git开发了更方便的Github Desktop软件，主要包含GUI和操作，同时也针对了PowerShell做了兼容，这一点非常好。便于跨平台的使用。(这是比较老的说法了，实际上他们放弃了维护CLI部分，专注使用GUI部分，详见：<a href=\"https://stackoverflow.com/questions/34565238/where-does-github-desktop-install-command-line-version-of-git\">Where does Github desktop install command line version of Git - Stack Overflow</a>)，但对新手来说GUI更适合一点，虽然无法使用全部的Git命令，但GUI已经足够了。</p>\n<p>下载地址如下：<a href=\"https://desktop.github.com/\">GitHub Desktop | Simple collaboration from your desktop</a></p>\n<p>下载后注册账号登陆即可：</p>\n<img src=\"https://s2.loli.net/2024/03/19/KMDWurV9LT4BEks.png\" alt=\"image-20240319230316232\" style=\"zoom:67%;\" />\n<p>设置本地Git信息也是易如反掌，我的建议是对于工具类不需要太过深入了解，但是要有求知的心，建议看完Git for Windows项目的教程之后再来看这个会更加理解，本人入门的时候也是用的Git for Windows来进行配置的，整个过程受益颇多。</p>\n<img src=\"https://s2.loli.net/2024/03/19/dP9IvSoFAfQ6gLR.png\" alt=\"image-20240319231027438\" style=\"zoom:67%;\" />\n<p>我们可以简单过一遍教程：</p>\n<img src=\"https://s2.loli.net/2024/03/19/X7RhIFyA136Gv95.png\" alt=\"image-20240319231115582\" style=\"zoom:67%;\" />\n<p>这里省略了几个验证的细节，只需要点点就可以了，来到正式的界面：</p>\n<img src=\"https://s2.loli.net/2024/03/19/eCDZ7wXPvxYk5RL.png\" alt=\"image-20240319231404949\" style=\"zoom:67%;\" />\n<p>右侧写了教程的步骤，这里要我们创建一个新的分支，分支的含义在这里已经详细阐述了，简单来说就是可以允许不同版本的代码同时在相同仓库下进行开发。点击创建新的分支之后：</p>\n<img src=\"https://s2.loli.net/2024/03/19/62jQlzivfNc5npk.png\" alt=\"image-20240319231619311\" style=\"zoom:67%;\" />\n<img src=\"https://s2.loli.net/2024/03/19/g3HRmj8wDQfIlAi.png\" alt=\"image-20240319231712553\" style=\"zoom: 80%;\" />\n<p>会使用系统默认的编辑器打开对应文本文件：</p>\n<img src=\"https://s2.loli.net/2024/03/19/d6F8ScXOKLpyTIP.png\" alt=\"image-20240319231807726\" style=\"zoom:67%;\" />\n<p>在下方添加以下总结信息，这对参与项目者十分重要，来标识你干了什么。</p>\n<img src=\"https://s2.loli.net/2024/03/19/AeWmqkO4jX2CQrs.png\" alt=\"image-20240319231917272\" style=\"zoom:67%;\" />\n<p>最后将分支推送到Github之上：</p>\n<img src=\"https://s2.loli.net/2024/03/19/CbuW9apGqoK5VHj.png\" alt=\"image-20240319232010779\" style=\"zoom:67%;\" />\n<p>pull request，是将你修改好的代码推送到审核人员那里，在审核人员将你实现的功能合并到主分支或者某一个分支之上。</p>\n<img src=\"https://s2.loli.net/2024/03/19/NQGVcslxkqAomgY.png\" alt=\"image-20240319232103905\" style=\"zoom:67%;\" />\n<p>跳转到网页进行申请处理</p>\n<img src=\"https://s2.loli.net/2024/03/19/GfbUMrgaVCxk5O2.png\" alt=\"image-20240319232223793\" style=\"zoom: 80%;\" />\n<p>审核人员审核之后也就是分支合并之后，可以选择删除你的开发分支，删除之后GIt上就剩下了一个分支。</p>\n<img src=\"https://s2.loli.net/2024/03/19/6xujJ7V1TZhek8P.png\" alt=\"image-20240319232351124\" style=\"zoom: 80%;\" />"},{"title":"Git(2)","excerpt":"关于Git的分支管理","date":"2024-10-21T16:40:01.000Z","_content":"\n# Git——分支管理（2）\n\n\n\n<img src=\"https://s2.loli.net/2024/10/22/zFJb9U6fiaprvdR.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527720427\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom:50%;\" />\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n\n\n## Git基础\n\n关于Git的基础请参考上一篇基础的教程，这里主要是关于Git的分支管理的内容，在讲解完成之后会以实战的形式让各位更好的理解如何使用Git这一个强大的工具。\n\n### Git的分支与HEAD\n\n#### Git的存储机制\n\n当你发起提交的时候，Git存储的是提交对象，其中包含了指向暂存区快照的指针。\n\nGit在仓库区一般会这样保存对象：\n\n```mermaid\ngraph LR\nA(\"提交对象\") --> C(\"Tree对象\") -->B(\"Blob1对象\")\nC-->D(\"Blob2对象\")\n\n```\n\n- 提交对象，一次提交包含着元数据以及指向项目根目录的树对象的指针，以便需要的时候重新创建这次快照。\n\n  <img src=\"https://pic4.zhimg.com/80/v2-b8b7d634df1cf8a9d079c762fc2781b3_720w.webp\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n- Blob 对象，只用于存储单个文件内容，一般都是二进制的数据文件，不包含任何其他文件信息，比如不包含文件名和其他元数据,可以同时有多个。\n\n- Tree 对象，对应文件系统的目录结构，里面主要有：子目录 (tree)，文件列表 (blob)，文件类型以及一些数据文件权限模型等。\n\nGit将文件的快照存储为对象，每个对象都有一个唯一的哈希值。当文件发生变化时，Git会计算新文件的哈希值，并将其作为新对象存储在对象数据库中。当Git检测到两个文件版本相似时，它会计算差异（即两个版本之间的不同之处），并将这些差异作为一个新的对象存储。这个差异对象会引用原始文件的哈希值，以便可以重构原始文件的内容。\n\n#### Git的分支指针\n\nGit的分支只不过是一个指向某次提交的轻量级的可以移动指针，Git默认的分支名是master,当你发起提交的时候就有了一个指向最后一次提交的master分支。每次提交时他都会自己向前移动。\n\n举个例子：\n\n```mermaid\ngraph LR\n\tH(\"HEAD\")  -->G\n\tG(\"master\") ==> Commit_C\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     \n     \n```\n\n也就是说分支其实就是指针，指针指向某一次提交。其中比较特殊的是HEAD指针，是用来指向当前分支指针的指针，表示当前在master分支上。\n\n### Git的远程仓库\n\n远程分支是指远程仓库的分支指针，这些指针存在于本地且无法被移动，当你与服务器进行网络通信的时候，他会自动更新，也就是使用pull等命令的时候，远程分支有点像书签，会提示你上一次连接服务器时远程仓库中每个分支的位置。\n\n```mermaid\ngraph LR\n\tG(\"master\") ==> Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"remote\") ==> Commit_C\n```\n\nremote指针同master指针一样，都是一个指针而已。\n\n### Git的远程分支管理\n\n合并冲突\n\nFast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\nmain节点落后于服务器上的main（以后都称之为origin/main），**此时执行Fast-forward操作就是把本地分支main合并到orgin/main之上**，此时main指针会向前走一个，这样的操作就是Fast-forward。\n\n合并之后结果如下：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\nmerge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_A --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\n在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。\n\n```mermaid\ngraph LR\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n     \n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     \n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     \n    \n     \n     subgraph merge_commit\n        direction TB\n        G(\"提交对象C\") --> H(\"文件对象C\")\n     end\n     \n     Commit_A --> Commit_B\n     Commit_A --> Commit_C\n     Commit_C --> merge_commit\n     Commit_B --> merge_commit\n     merge_commit --> J(\"orgin/main\")\n     merge_commit --> I(\"main\")\n     \n```\n\nRebase操作指的是在上述情况之上直接将某个分支之上所有提交的更改在另一个分支上重现一遍。\n\n为了Rebase需要先找到两个要整合的分支的共同祖先，然后取得当前所在分支的每次提交引入的变更，并把这些变更保存成文件，这之后将当前分支重置为要整合到的分支，然后在该分支上依次引入之前保存的每个更改。\n\n在合并之前分支已成这个样子：\n\n\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_A --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\n当我们想把远程分支的内容整合到main分支之上（就是将orgin/main rebase到 main）的话就会有如下情况，合并之后：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C+\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C+\n     H(\"orgin/main\") ==> Commit_C+\n```\n\n可以看到这里实际上变化成了Fast-forward所处理的情况，再次执行Fast-forward（merge）即可完成操作。\n\n## 远程分支和本地仓库的冲突处理\n\n### 查看当前分支情况\n\n查看当前分支信息：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git branch\n* main\n  test\n```\n\n加上参数v可以显示当前每个分支的最新提交和其的提交信息，加上a则会包括当前的远程分支：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -> origin/main\n  remotes/origin/main e5d18d7 del copy\n```\n\n`*`代表了HEAD指针所处位置，也就是当前所在的分支。 `update git rm pycharm`就是对应的提交信息。`e5d18d7`就是提交对象的散列值。\n\n如果要查看已并入当前的分支的所有分支信息可以使用：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av --merged\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -> origin/main\n  remotes/origin/main e5d18d7 del copy\n```\n\n相反的，显示没有并入分支的命令可以使用（注意这里和上文并不是一个仓库，你可以看到对应的路径不同）：\n\n```bash\n(base) neo@NeoNeuxs:~/Desktop/Essays$ git branch -av --no-merged\n  remotes/origin/HEAD -> origin/main\n  remotes/origin/main e5d18d7 del copy\n```\n\n但是以上的方式都不够明显展示分支的变化及历史，所以推荐还是使用如下命令：\n\n```bash\ngit log --graph --decorate --oneline --all\n```\n\n如图展示了两个本地的仓库，其中二者的远程仓库是保持一致的，也就是说二者都有一样的远程信息，但是本地却差别很大，我们的工作就是尽量合并二者的内容并优化分支结构。\n\n<img src=\"https://s2.loli.net/2024/05/06/lrENoDWkt92Fd36.png\" alt=\"image-20240506012058410\" style=\"zoom:67%;\" />\n\n在看到二者的分支图的时候我们就能看到：\n\n图中的领先指的是领先远程仓库的意思。\n\n<img src=\"https://s2.loli.net/2024/05/06/zuK2aUAx384oBr6.png\" alt=\"image-20240506012643030\" style=\"zoom: 67%;\" />\n\n简单来说我们的解决方案如下\n\n首先rebase仓库A,将仓库A的main分支rebase到远程上然后push到服务器。\n\n然后将远程新的内容pull到仓库B，再进行一次rebase然后将内容push到服务器。最终再pull，仓库A、仓库B、服务器三者就可以实现同步。\n\n```bash\n(base) neo@NeoNeuxs:~/Desktop/Essays$ git rebase origin/main\nSuccessfully rebased and updated refs/heads/main.\n```\n\nreabase之后：\n\n<img src=\"https://s2.loli.net/2024/05/06/v1zQSXFucd45ROx.png\" alt=\"image-20240506020430611\" style=\"zoom:67%;\" />\n\n由于仓库B还有部分内容没有提交，这里就再提交一次：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git commit -a -m \"finished git 1\"\n[main e2fdc30] finished git 1\n 1 file changed, 61 insertions(+), 6 deletions(-)\n```\n\n提交之后分支如下,本次提交并不影响合并方案，只是单纯多加了一次提交而已。\n\n<img src=\"https://s2.loli.net/2024/05/06/ixv7hQX3VoBcWlN.png\" alt=\"image-20240506020817574\" style=\"zoom:67%;\" />\n\n```bash\ngit pull --rebase\n# 等价于：\ngit fetch origin/main\ngit rebase origin/main\n```\n\n<img src=\"https://s2.loli.net/2024/05/06/Dy1olHPMKZExYLT.png\" alt=\"image-20240506023005761\" style=\"zoom:67%;\" />\n\n其中的分支变化如下：\n\n<img src=\"https://s2.loli.net/2024/05/06/6XujLS5UyvFc4pf.png\" alt=\"image-20240506032249539\"  />\n\n关于rebase的变化的解释：\n\n根据精通Git（第二版）的内容，其变基按照如下的方式：\n\n- 判断出分支上那些工作是本地独有的（245d、8ea、dd02、e2fdc）。\n- 判断出哪些提交不是合并提交（245d、8ea、e2fdc）。\n- 判断出哪些提交并没有被重写到基分支上（orgin/master）（245d、8ea、e2fdc）。\n- 把筛选出来的分支重写到基分支上\n\nGit会将合并提交的更改拆分成多个单独的提交，并将它们重新应用在远程分支的顶部。这意味着原始的合并提交（在这个例子中是 `dd0258f`）不再存在于变基后的分支历史中。\n\n245df5e提交和e5d18提交完全一致，并不是有效提交，所以被舍弃。\n\n![image-20240506025758663](https://s2.loli.net/2024/05/06/AXrHNwx89vnEa2I.png)\n\n需要注意的是，没有手动推送上图中test分支，服务器上实际上是没有245df5e,8eafb31的信息的。\n\n参考：精通Git（第二版）\n","source":"_posts/Git__Base(2).md","raw":"---\ntitle: Git(2)\ncategories:\n  - git\ntags:\n  - branch\n  - base\nexcerpt: \"关于Git的分支管理\"\ndate: 2024/10/22 00:40:01\n---\n\n# Git——分支管理（2）\n\n\n\n<img src=\"https://s2.loli.net/2024/10/22/zFJb9U6fiaprvdR.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527720427\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom:50%;\" />\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n\n\n## Git基础\n\n关于Git的基础请参考上一篇基础的教程，这里主要是关于Git的分支管理的内容，在讲解完成之后会以实战的形式让各位更好的理解如何使用Git这一个强大的工具。\n\n### Git的分支与HEAD\n\n#### Git的存储机制\n\n当你发起提交的时候，Git存储的是提交对象，其中包含了指向暂存区快照的指针。\n\nGit在仓库区一般会这样保存对象：\n\n```mermaid\ngraph LR\nA(\"提交对象\") --> C(\"Tree对象\") -->B(\"Blob1对象\")\nC-->D(\"Blob2对象\")\n\n```\n\n- 提交对象，一次提交包含着元数据以及指向项目根目录的树对象的指针，以便需要的时候重新创建这次快照。\n\n  <img src=\"https://pic4.zhimg.com/80/v2-b8b7d634df1cf8a9d079c762fc2781b3_720w.webp\" alt=\"image.png\" style=\"zoom:80%;\" />\n\n- Blob 对象，只用于存储单个文件内容，一般都是二进制的数据文件，不包含任何其他文件信息，比如不包含文件名和其他元数据,可以同时有多个。\n\n- Tree 对象，对应文件系统的目录结构，里面主要有：子目录 (tree)，文件列表 (blob)，文件类型以及一些数据文件权限模型等。\n\nGit将文件的快照存储为对象，每个对象都有一个唯一的哈希值。当文件发生变化时，Git会计算新文件的哈希值，并将其作为新对象存储在对象数据库中。当Git检测到两个文件版本相似时，它会计算差异（即两个版本之间的不同之处），并将这些差异作为一个新的对象存储。这个差异对象会引用原始文件的哈希值，以便可以重构原始文件的内容。\n\n#### Git的分支指针\n\nGit的分支只不过是一个指向某次提交的轻量级的可以移动指针，Git默认的分支名是master,当你发起提交的时候就有了一个指向最后一次提交的master分支。每次提交时他都会自己向前移动。\n\n举个例子：\n\n```mermaid\ngraph LR\n\tH(\"HEAD\")  -->G\n\tG(\"master\") ==> Commit_C\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     \n     \n```\n\n也就是说分支其实就是指针，指针指向某一次提交。其中比较特殊的是HEAD指针，是用来指向当前分支指针的指针，表示当前在master分支上。\n\n### Git的远程仓库\n\n远程分支是指远程仓库的分支指针，这些指针存在于本地且无法被移动，当你与服务器进行网络通信的时候，他会自动更新，也就是使用pull等命令的时候，远程分支有点像书签，会提示你上一次连接服务器时远程仓库中每个分支的位置。\n\n```mermaid\ngraph LR\n\tG(\"master\") ==> Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"remote\") ==> Commit_C\n```\n\nremote指针同master指针一样，都是一个指针而已。\n\n### Git的远程分支管理\n\n合并冲突\n\nFast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\nmain节点落后于服务器上的main（以后都称之为origin/main），**此时执行Fast-forward操作就是把本地分支main合并到orgin/main之上**，此时main指针会向前走一个，这样的操作就是Fast-forward。\n\n合并之后结果如下：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\nmerge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_A --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\n在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。\n\n```mermaid\ngraph LR\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n     \n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     \n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     \n    \n     \n     subgraph merge_commit\n        direction TB\n        G(\"提交对象C\") --> H(\"文件对象C\")\n     end\n     \n     Commit_A --> Commit_B\n     Commit_A --> Commit_C\n     Commit_C --> merge_commit\n     Commit_B --> merge_commit\n     merge_commit --> J(\"orgin/main\")\n     merge_commit --> I(\"main\")\n     \n```\n\nRebase操作指的是在上述情况之上直接将某个分支之上所有提交的更改在另一个分支上重现一遍。\n\n为了Rebase需要先找到两个要整合的分支的共同祖先，然后取得当前所在分支的每次提交引入的变更，并把这些变更保存成文件，这之后将当前分支重置为要整合到的分支，然后在该分支上依次引入之前保存的每个更改。\n\n在合并之前分支已成这个样子：\n\n\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_A --> Commit_C\n     H(\"orgin/main\") ==> Commit_C\n```\n\n当我们想把远程分支的内容整合到main分支之上（就是将orgin/main rebase到 main）的话就会有如下情况，合并之后：\n\n```mermaid\ngraph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C+\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C+\n     H(\"orgin/main\") ==> Commit_C+\n```\n\n可以看到这里实际上变化成了Fast-forward所处理的情况，再次执行Fast-forward（merge）即可完成操作。\n\n## 远程分支和本地仓库的冲突处理\n\n### 查看当前分支情况\n\n查看当前分支信息：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git branch\n* main\n  test\n```\n\n加上参数v可以显示当前每个分支的最新提交和其的提交信息，加上a则会包括当前的远程分支：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -> origin/main\n  remotes/origin/main e5d18d7 del copy\n```\n\n`*`代表了HEAD指针所处位置，也就是当前所在的分支。 `update git rm pycharm`就是对应的提交信息。`e5d18d7`就是提交对象的散列值。\n\n如果要查看已并入当前的分支的所有分支信息可以使用：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av --merged\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -> origin/main\n  remotes/origin/main e5d18d7 del copy\n```\n\n相反的，显示没有并入分支的命令可以使用（注意这里和上文并不是一个仓库，你可以看到对应的路径不同）：\n\n```bash\n(base) neo@NeoNeuxs:~/Desktop/Essays$ git branch -av --no-merged\n  remotes/origin/HEAD -> origin/main\n  remotes/origin/main e5d18d7 del copy\n```\n\n但是以上的方式都不够明显展示分支的变化及历史，所以推荐还是使用如下命令：\n\n```bash\ngit log --graph --decorate --oneline --all\n```\n\n如图展示了两个本地的仓库，其中二者的远程仓库是保持一致的，也就是说二者都有一样的远程信息，但是本地却差别很大，我们的工作就是尽量合并二者的内容并优化分支结构。\n\n<img src=\"https://s2.loli.net/2024/05/06/lrENoDWkt92Fd36.png\" alt=\"image-20240506012058410\" style=\"zoom:67%;\" />\n\n在看到二者的分支图的时候我们就能看到：\n\n图中的领先指的是领先远程仓库的意思。\n\n<img src=\"https://s2.loli.net/2024/05/06/zuK2aUAx384oBr6.png\" alt=\"image-20240506012643030\" style=\"zoom: 67%;\" />\n\n简单来说我们的解决方案如下\n\n首先rebase仓库A,将仓库A的main分支rebase到远程上然后push到服务器。\n\n然后将远程新的内容pull到仓库B，再进行一次rebase然后将内容push到服务器。最终再pull，仓库A、仓库B、服务器三者就可以实现同步。\n\n```bash\n(base) neo@NeoNeuxs:~/Desktop/Essays$ git rebase origin/main\nSuccessfully rebased and updated refs/heads/main.\n```\n\nreabase之后：\n\n<img src=\"https://s2.loli.net/2024/05/06/v1zQSXFucd45ROx.png\" alt=\"image-20240506020430611\" style=\"zoom:67%;\" />\n\n由于仓库B还有部分内容没有提交，这里就再提交一次：\n\n```bash\n(base) neo@NeoNeuxs:~/git_test/Essays$ git commit -a -m \"finished git 1\"\n[main e2fdc30] finished git 1\n 1 file changed, 61 insertions(+), 6 deletions(-)\n```\n\n提交之后分支如下,本次提交并不影响合并方案，只是单纯多加了一次提交而已。\n\n<img src=\"https://s2.loli.net/2024/05/06/ixv7hQX3VoBcWlN.png\" alt=\"image-20240506020817574\" style=\"zoom:67%;\" />\n\n```bash\ngit pull --rebase\n# 等价于：\ngit fetch origin/main\ngit rebase origin/main\n```\n\n<img src=\"https://s2.loli.net/2024/05/06/Dy1olHPMKZExYLT.png\" alt=\"image-20240506023005761\" style=\"zoom:67%;\" />\n\n其中的分支变化如下：\n\n<img src=\"https://s2.loli.net/2024/05/06/6XujLS5UyvFc4pf.png\" alt=\"image-20240506032249539\"  />\n\n关于rebase的变化的解释：\n\n根据精通Git（第二版）的内容，其变基按照如下的方式：\n\n- 判断出分支上那些工作是本地独有的（245d、8ea、dd02、e2fdc）。\n- 判断出哪些提交不是合并提交（245d、8ea、e2fdc）。\n- 判断出哪些提交并没有被重写到基分支上（orgin/master）（245d、8ea、e2fdc）。\n- 把筛选出来的分支重写到基分支上\n\nGit会将合并提交的更改拆分成多个单独的提交，并将它们重新应用在远程分支的顶部。这意味着原始的合并提交（在这个例子中是 `dd0258f`）不再存在于变基后的分支历史中。\n\n245df5e提交和e5d18提交完全一致，并不是有效提交，所以被舍弃。\n\n![image-20240506025758663](https://s2.loli.net/2024/05/06/AXrHNwx89vnEa2I.png)\n\n需要注意的是，没有手动推送上图中test分支，服务器上实际上是没有245df5e,8eafb31的信息的。\n\n参考：精通Git（第二版）\n","slug":"Git__Base(2)","published":1,"updated":"2024-10-21T16:50:48.784Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti07001xyjingc4na1pn","content":"<h1><span id=\"git分支管理2\">Git——分支管理（2）</span></h1>\n<img src=\"https://s2.loli.net/2024/10/22/zFJb9U6fiaprvdR.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527720427\" style=\"zoom:50%;\">\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom:50%;\">\n<h2><span id=\"提示图床在国外且动图比较多的情况下需要时间加载\">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2>\n<h2><span id=\"目录\">目录：</span></h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#git%E5%9F%BA%E7%A1%80\">Git基础</a>\n<ul>\n<li><a href=\"#git%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8Ehead\">Git的分支与HEAD</a>\n<ul>\n<li><a href=\"#git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6\">Git的存储机制</a></li>\n<li><a href=\"#git%E7%9A%84%E5%88%86%E6%94%AF%E6%8C%87%E9%92%88\">Git的分支指针</a></li>\n</ul>\n</li>\n<li><a href=\"#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93\">Git的远程仓库</a></li>\n<li><a href=\"#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86\">Git的远程分支管理</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86\">远程分支和本地仓库的冲突处理</a>\n<ul>\n<li><a href=\"#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E6%83%85%E5%86%B5\">查看当前分支情况</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2><span id=\"git基础\">Git基础</span></h2>\n<p>关于Git的基础请参考上一篇基础的教程，这里主要是关于Git的分支管理的内容，在讲解完成之后会以实战的形式让各位更好的理解如何使用Git这一个强大的工具。</p>\n<h3><span id=\"git的分支与head\">Git的分支与HEAD</span></h3>\n<h4><span id=\"git的存储机制\">Git的存储机制</span></h4>\n<p>当你发起提交的时候，Git存储的是提交对象，其中包含了指向暂存区快照的指针。</p>\n<p>Git在仓库区一般会这样保存对象：</p>\n<pre class=\"mermaid\">graph LR\nA(\"提交对象\") --&gt; C(\"Tree对象\") --&gt;B(\"Blob1对象\")\nC--&gt;D(\"Blob2对象\")</pre>\n<ul>\n<li>\n<p>提交对象，一次提交包含着元数据以及指向项目根目录的树对象的指针，以便需要的时候重新创建这次快照。</p>\n<img src=\"https://pic4.zhimg.com/80/v2-b8b7d634df1cf8a9d079c762fc2781b3_720w.webp\" alt=\"image.png\" style=\"zoom:80%;\">\n</li>\n<li>\n<p>Blob 对象，只用于存储单个文件内容，一般都是二进制的数据文件，不包含任何其他文件信息，比如不包含文件名和其他元数据,可以同时有多个。</p>\n</li>\n<li>\n<p>Tree 对象，对应文件系统的目录结构，里面主要有：子目录 (tree)，文件列表 (blob)，文件类型以及一些数据文件权限模型等。</p>\n</li>\n</ul>\n<p>Git将文件的快照存储为对象，每个对象都有一个唯一的哈希值。当文件发生变化时，Git会计算新文件的哈希值，并将其作为新对象存储在对象数据库中。当Git检测到两个文件版本相似时，它会计算差异（即两个版本之间的不同之处），并将这些差异作为一个新的对象存储。这个差异对象会引用原始文件的哈希值，以便可以重构原始文件的内容。</p>\n<h4><span id=\"git的分支指针\">Git的分支指针</span></h4>\n<p>Git的分支只不过是一个指向某次提交的轻量级的可以移动指针，Git默认的分支名是master,当你发起提交的时候就有了一个指向最后一次提交的master分支。每次提交时他都会自己向前移动。</p>\n<p>举个例子：</p>\n<pre class=\"mermaid\">graph LR\n\tH(\"HEAD\")  --&gt;G\n\tG(\"master\") ==&gt; Commit_C\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     Commit_A --&gt; Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     Commit_B --&gt; Commit_C</pre>\n<p>也就是说分支其实就是指针，指针指向某一次提交。其中比较特殊的是HEAD指针，是用来指向当前分支指针的指针，表示当前在master分支上。</p>\n<h3><span id=\"git的远程仓库\">Git的远程仓库</span></h3>\n<p>远程分支是指远程仓库的分支指针，这些指针存在于本地且无法被移动，当你与服务器进行网络通信的时候，他会自动更新，也就是使用pull等命令的时候，远程分支有点像书签，会提示你上一次连接服务器时远程仓库中每个分支的位置。</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"master\") ==&gt; Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     Commit_A --&gt; Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     Commit_B --&gt; Commit_C\n     H(\"remote\") ==&gt; Commit_C</pre>\n<p>remote指针同master指针一样，都是一个指针而已。</p>\n<h3><span id=\"git的远程分支管理\">Git的远程分支管理</span></h3>\n<p>合并冲突</p>\n<p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==&gt; Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     Commit_A --&gt; Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     Commit_B --&gt; Commit_C\n     H(\"orgin/main\") ==&gt; Commit_C</pre>\n<p>main节点落后于服务器上的main（以后都称之为origin/main），<strong>此时执行Fast-forward操作就是把本地分支main合并到orgin/main之上</strong>，此时main指针会向前走一个，这样的操作就是Fast-forward。</p>\n<p>合并之后结果如下：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==&gt; Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     Commit_A --&gt; Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     Commit_B --&gt; Commit_C\n     H(\"orgin/main\") ==&gt; Commit_C</pre>\n<p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==&gt; Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     Commit_A --&gt; Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     Commit_A --&gt; Commit_C\n     H(\"orgin/main\") ==&gt; Commit_C</pre>\n<p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p>\n<pre class=\"mermaid\">graph LR\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n     \n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     \n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     \n    \n     \n     subgraph merge_commit\n        direction TB\n        G(\"提交对象C\") --&gt; H(\"文件对象C\")\n     end\n     \n     Commit_A --&gt; Commit_B\n     Commit_A --&gt; Commit_C\n     Commit_C --&gt; merge_commit\n     Commit_B --&gt; merge_commit\n     merge_commit --&gt; J(\"orgin/main\")\n     merge_commit --&gt; I(\"main\")</pre>\n<p>Rebase操作指的是在上述情况之上直接将某个分支之上所有提交的更改在另一个分支上重现一遍。</p>\n<p>为了Rebase需要先找到两个要整合的分支的共同祖先，然后取得当前所在分支的每次提交引入的变更，并把这些变更保存成文件，这之后将当前分支重置为要整合到的分支，然后在该分支上依次引入之前保存的每个更改。</p>\n<p>在合并之前分支已成这个样子：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==&gt; Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     Commit_A --&gt; Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     Commit_A --&gt; Commit_C\n     H(\"orgin/main\") ==&gt; Commit_C</pre>\n<p>当我们想把远程分支的内容整合到main分支之上（就是将orgin/main rebase到 main）的话就会有如下情况，合并之后：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==&gt; Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --&gt; B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --&gt; D(\"文件对象B\")\n     end\n     Commit_A --&gt; Commit_B\n    subgraph Commit_C+\n        direction TB\n        E(\"提交对象C\") --&gt; F(\"文件对象C\")\n     end\n     Commit_B --&gt; Commit_C+\n     H(\"orgin/main\") ==&gt; Commit_C+</pre>\n<p>可以看到这里实际上变化成了Fast-forward所处理的情况，再次执行Fast-forward（merge）即可完成操作。</p>\n<h2><span id=\"远程分支和本地仓库的冲突处理\">远程分支和本地仓库的冲突处理</span></h2>\n<h3><span id=\"查看当前分支情况\">查看当前分支情况</span></h3>\n<p>查看当前分支信息：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch\n* main\n  test\n</code></pre>\n<p>加上参数v可以显示当前每个分支的最新提交和其的提交信息，加上a则会包括当前的远程分支：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -&gt; origin/main\n  remotes/origin/main e5d18d7 del copy\n</code></pre>\n<p><code>*</code>代表了HEAD指针所处位置，也就是当前所在的分支。 <code>update git rm pycharm</code>就是对应的提交信息。<code>e5d18d7</code>就是提交对象的散列值。</p>\n<p>如果要查看已并入当前的分支的所有分支信息可以使用：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av --merged\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -&gt; origin/main\n  remotes/origin/main e5d18d7 del copy\n</code></pre>\n<p>相反的，显示没有并入分支的命令可以使用（注意这里和上文并不是一个仓库，你可以看到对应的路径不同）：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/Desktop/Essays$ git branch -av --no-merged\n  remotes/origin/HEAD -&gt; origin/main\n  remotes/origin/main e5d18d7 del copy\n</code></pre>\n<p>但是以上的方式都不够明显展示分支的变化及历史，所以推荐还是使用如下命令：</p>\n<pre><code class=\"language-bash\">git log --graph --decorate --oneline --all\n</code></pre>\n<p>如图展示了两个本地的仓库，其中二者的远程仓库是保持一致的，也就是说二者都有一样的远程信息，但是本地却差别很大，我们的工作就是尽量合并二者的内容并优化分支结构。</p>\n<img src=\"https://s2.loli.net/2024/05/06/lrENoDWkt92Fd36.png\" alt=\"image-20240506012058410\" style=\"zoom:67%;\">\n<p>在看到二者的分支图的时候我们就能看到：</p>\n<p>图中的领先指的是领先远程仓库的意思。</p>\n<img src=\"https://s2.loli.net/2024/05/06/zuK2aUAx384oBr6.png\" alt=\"image-20240506012643030\" style=\"zoom: 67%;\">\n<p>简单来说我们的解决方案如下</p>\n<p>首先rebase仓库A,将仓库A的main分支rebase到远程上然后push到服务器。</p>\n<p>然后将远程新的内容pull到仓库B，再进行一次rebase然后将内容push到服务器。最终再pull，仓库A、仓库B、服务器三者就可以实现同步。</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/Desktop/Essays$ git rebase origin/main\nSuccessfully rebased and updated refs/heads/main.\n</code></pre>\n<p>reabase之后：</p>\n<img src=\"https://s2.loli.net/2024/05/06/v1zQSXFucd45ROx.png\" alt=\"image-20240506020430611\" style=\"zoom:67%;\">\n<p>由于仓库B还有部分内容没有提交，这里就再提交一次：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git commit -a -m \"finished git 1\"\n[main e2fdc30] finished git 1\n 1 file changed, 61 insertions(+), 6 deletions(-)\n</code></pre>\n<p>提交之后分支如下,本次提交并不影响合并方案，只是单纯多加了一次提交而已。</p>\n<img src=\"https://s2.loli.net/2024/05/06/ixv7hQX3VoBcWlN.png\" alt=\"image-20240506020817574\" style=\"zoom:67%;\">\n<pre><code class=\"language-bash\">git pull --rebase\n# 等价于：\ngit fetch origin/main\ngit rebase origin/main\n</code></pre>\n<img src=\"https://s2.loli.net/2024/05/06/Dy1olHPMKZExYLT.png\" alt=\"image-20240506023005761\" style=\"zoom:67%;\">\n<p>其中的分支变化如下：</p>\n<img src=\"https://s2.loli.net/2024/05/06/6XujLS5UyvFc4pf.png\" alt=\"image-20240506032249539\">\n<p>关于rebase的变化的解释：</p>\n<p>根据精通Git（第二版）的内容，其变基按照如下的方式：</p>\n<ul>\n<li>判断出分支上那些工作是本地独有的（245d、8ea、dd02、e2fdc）。</li>\n<li>判断出哪些提交不是合并提交（245d、8ea、e2fdc）。</li>\n<li>判断出哪些提交并没有被重写到基分支上（orgin/master）（245d、8ea、e2fdc）。</li>\n<li>把筛选出来的分支重写到基分支上</li>\n</ul>\n<p>Git会将合并提交的更改拆分成多个单独的提交，并将它们重新应用在远程分支的顶部。这意味着原始的合并提交（在这个例子中是 <code>dd0258f</code>）不再存在于变基后的分支历史中。</p>\n<p>245df5e提交和e5d18提交完全一致，并不是有效提交，所以被舍弃。</p>\n<p><img src=\"https://s2.loli.net/2024/05/06/AXrHNwx89vnEa2I.png\" alt=\"image-20240506025758663\"></p>\n<p>需要注意的是，没有手动推送上图中test分支，服务器上实际上是没有245df5e,8eafb31的信息的。</p>\n<p>参考：精通Git（第二版）</p>\n","more":"<h1>Git——分支管理（2）</h1>\n<img src=\"https://s2.loli.net/2024/10/22/zFJb9U6fiaprvdR.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1729527720427\" style=\"zoom:50%;\" />\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom:50%;\" />\n<h2 id=\"提示：图床在国外且动图比较多的情况下，需要时间加载。\">提示：图床在国外且动图比较多的情况下，需要时间加载。</h2>\n<h2 id=\"目录：\">目录：</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#git%E5%9F%BA%E7%A1%80\">Git基础</a>\n<ul>\n<li><a href=\"#git%E7%9A%84%E5%88%86%E6%94%AF%E4%B8%8Ehead\">Git的分支与HEAD</a>\n<ul>\n<li><a href=\"#git%E7%9A%84%E5%AD%98%E5%82%A8%E6%9C%BA%E5%88%B6\">Git的存储机制</a></li>\n<li><a href=\"#git%E7%9A%84%E5%88%86%E6%94%AF%E6%8C%87%E9%92%88\">Git的分支指针</a></li>\n</ul>\n</li>\n<li><a href=\"#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93\">Git的远程仓库</a></li>\n<li><a href=\"#git%E7%9A%84%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86\">Git的远程分支管理</a></li>\n</ul>\n</li>\n<li><a href=\"#%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E5%92%8C%E6%9C%AC%E5%9C%B0%E4%BB%93%E5%BA%93%E7%9A%84%E5%86%B2%E7%AA%81%E5%A4%84%E7%90%86\">远程分支和本地仓库的冲突处理</a>\n<ul>\n<li><a href=\"#%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E5%88%86%E6%94%AF%E6%83%85%E5%86%B5\">查看当前分支情况</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2 id=\"Git基础\">Git基础</h2>\n<p>关于Git的基础请参考上一篇基础的教程，这里主要是关于Git的分支管理的内容，在讲解完成之后会以实战的形式让各位更好的理解如何使用Git这一个强大的工具。</p>\n<h3 id=\"Git的分支与HEAD\">Git的分支与HEAD</h3>\n<h4 id=\"Git的存储机制\">Git的存储机制</h4>\n<p>当你发起提交的时候，Git存储的是提交对象，其中包含了指向暂存区快照的指针。</p>\n<p>Git在仓库区一般会这样保存对象：</p>\n<pre class=\"mermaid\">graph LR\nA(\"提交对象\") --> C(\"Tree对象\") -->B(\"Blob1对象\")\nC-->D(\"Blob2对象\")</pre>\n<ul>\n<li>\n<p>提交对象，一次提交包含着元数据以及指向项目根目录的树对象的指针，以便需要的时候重新创建这次快照。</p>\n<img src=\"https://pic4.zhimg.com/80/v2-b8b7d634df1cf8a9d079c762fc2781b3_720w.webp\" alt=\"image.png\" style=\"zoom:80%;\" />\n</li>\n<li>\n<p>Blob 对象，只用于存储单个文件内容，一般都是二进制的数据文件，不包含任何其他文件信息，比如不包含文件名和其他元数据,可以同时有多个。</p>\n</li>\n<li>\n<p>Tree 对象，对应文件系统的目录结构，里面主要有：子目录 (tree)，文件列表 (blob)，文件类型以及一些数据文件权限模型等。</p>\n</li>\n</ul>\n<p>Git将文件的快照存储为对象，每个对象都有一个唯一的哈希值。当文件发生变化时，Git会计算新文件的哈希值，并将其作为新对象存储在对象数据库中。当Git检测到两个文件版本相似时，它会计算差异（即两个版本之间的不同之处），并将这些差异作为一个新的对象存储。这个差异对象会引用原始文件的哈希值，以便可以重构原始文件的内容。</p>\n<h4 id=\"Git的分支指针\">Git的分支指针</h4>\n<p>Git的分支只不过是一个指向某次提交的轻量级的可以移动指针，Git默认的分支名是master,当你发起提交的时候就有了一个指向最后一次提交的master分支。每次提交时他都会自己向前移动。</p>\n<p>举个例子：</p>\n<pre class=\"mermaid\">graph LR\n\tH(\"HEAD\")  -->G\n\tG(\"master\") ==> Commit_C\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C</pre>\n<p>也就是说分支其实就是指针，指针指向某一次提交。其中比较特殊的是HEAD指针，是用来指向当前分支指针的指针，表示当前在master分支上。</p>\n<h3 id=\"Git的远程仓库\">Git的远程仓库</h3>\n<p>远程分支是指远程仓库的分支指针，这些指针存在于本地且无法被移动，当你与服务器进行网络通信的时候，他会自动更新，也就是使用pull等命令的时候，远程分支有点像书签，会提示你上一次连接服务器时远程仓库中每个分支的位置。</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"master\") ==> Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"remote\") ==> Commit_C</pre>\n<p>remote指针同master指针一样，都是一个指针而已。</p>\n<h3 id=\"Git的远程分支管理\">Git的远程分支管理</h3>\n<p>合并冲突</p>\n<p>Fast-forward操作指的是当前分支所在位置是在已有要合并分支的后面，打个比方：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"orgin/main\") ==> Commit_C</pre>\n<p>main节点落后于服务器上的main（以后都称之为origin/main），<strong>此时执行Fast-forward操作就是把本地分支main合并到orgin/main之上</strong>，此时main指针会向前走一个，这样的操作就是Fast-forward。</p>\n<p>合并之后结果如下：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==> Commit_C\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C\n     H(\"orgin/main\") ==> Commit_C</pre>\n<p>merge操作指的是在本地分支和远程分支在同一个基点产生分歧的时候如下图所示：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_A --> Commit_C\n     H(\"orgin/main\") ==> Commit_C</pre>\n<p>在你的第一次提交之后本地已有个第二次提交，远程也有一个基于第一次提交的远程提交，此时就需要merge将两次提交合并成新的提交：merge_commit，来进行合并。</p>\n<pre class=\"mermaid\">graph LR\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n     \n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     \n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     \n    \n     \n     subgraph merge_commit\n        direction TB\n        G(\"提交对象C\") --> H(\"文件对象C\")\n     end\n     \n     Commit_A --> Commit_B\n     Commit_A --> Commit_C\n     Commit_C --> merge_commit\n     Commit_B --> merge_commit\n     merge_commit --> J(\"orgin/main\")\n     merge_commit --> I(\"main\")</pre>\n<p>Rebase操作指的是在上述情况之上直接将某个分支之上所有提交的更改在另一个分支上重现一遍。</p>\n<p>为了Rebase需要先找到两个要整合的分支的共同祖先，然后取得当前所在分支的每次提交引入的变更，并把这些变更保存成文件，这之后将当前分支重置为要整合到的分支，然后在该分支上依次引入之前保存的每个更改。</p>\n<p>在合并之前分支已成这个样子：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_A --> Commit_C\n     H(\"orgin/main\") ==> Commit_C</pre>\n<p>当我们想把远程分支的内容整合到main分支之上（就是将orgin/main rebase到 main）的话就会有如下情况，合并之后：</p>\n<pre class=\"mermaid\">graph LR\n\tG(\"main\") ==> Commit_B\n\t\n    direction LR\n    subgraph Commit_A\n        direction TB\n        A(\"提交对象A\") --> B(\"文件对象A\")\n     end\n    subgraph Commit_B\n        direction TB\n        C(\"提交对象B\") --> D(\"文件对象B\")\n     end\n     Commit_A --> Commit_B\n    subgraph Commit_C+\n        direction TB\n        E(\"提交对象C\") --> F(\"文件对象C\")\n     end\n     Commit_B --> Commit_C+\n     H(\"orgin/main\") ==> Commit_C+</pre>\n<p>可以看到这里实际上变化成了Fast-forward所处理的情况，再次执行Fast-forward（merge）即可完成操作。</p>\n<h2 id=\"远程分支和本地仓库的冲突处理\">远程分支和本地仓库的冲突处理</h2>\n<h3 id=\"查看当前分支情况\">查看当前分支情况</h3>\n<p>查看当前分支信息：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch\n* main\n  test\n</code></pre>\n<p>加上参数v可以显示当前每个分支的最新提交和其的提交信息，加上a则会包括当前的远程分支：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -&gt; origin/main\n  remotes/origin/main e5d18d7 del copy\n</code></pre>\n<p><code>*</code>代表了HEAD指针所处位置，也就是当前所在的分支。 <code>update git rm pycharm</code>就是对应的提交信息。<code>e5d18d7</code>就是提交对象的散列值。</p>\n<p>如果要查看已并入当前的分支的所有分支信息可以使用：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git branch -av --merged\n* main                dd0258f [ahead 3] Merge branch 'test'\n  test                8eafb31 update git rm pycharm\n  remotes/origin/HEAD -&gt; origin/main\n  remotes/origin/main e5d18d7 del copy\n</code></pre>\n<p>相反的，显示没有并入分支的命令可以使用（注意这里和上文并不是一个仓库，你可以看到对应的路径不同）：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/Desktop/Essays$ git branch -av --no-merged\n  remotes/origin/HEAD -&gt; origin/main\n  remotes/origin/main e5d18d7 del copy\n</code></pre>\n<p>但是以上的方式都不够明显展示分支的变化及历史，所以推荐还是使用如下命令：</p>\n<pre><code class=\"language-bash\">git log --graph --decorate --oneline --all\n</code></pre>\n<p>如图展示了两个本地的仓库，其中二者的远程仓库是保持一致的，也就是说二者都有一样的远程信息，但是本地却差别很大，我们的工作就是尽量合并二者的内容并优化分支结构。</p>\n<img src=\"https://s2.loli.net/2024/05/06/lrENoDWkt92Fd36.png\" alt=\"image-20240506012058410\" style=\"zoom:67%;\" />\n<p>在看到二者的分支图的时候我们就能看到：</p>\n<p>图中的领先指的是领先远程仓库的意思。</p>\n<img src=\"https://s2.loli.net/2024/05/06/zuK2aUAx384oBr6.png\" alt=\"image-20240506012643030\" style=\"zoom: 67%;\" />\n<p>简单来说我们的解决方案如下</p>\n<p>首先rebase仓库A,将仓库A的main分支rebase到远程上然后push到服务器。</p>\n<p>然后将远程新的内容pull到仓库B，再进行一次rebase然后将内容push到服务器。最终再pull，仓库A、仓库B、服务器三者就可以实现同步。</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/Desktop/Essays$ git rebase origin/main\nSuccessfully rebased and updated refs/heads/main.\n</code></pre>\n<p>reabase之后：</p>\n<img src=\"https://s2.loli.net/2024/05/06/v1zQSXFucd45ROx.png\" alt=\"image-20240506020430611\" style=\"zoom:67%;\" />\n<p>由于仓库B还有部分内容没有提交，这里就再提交一次：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~/git_test/Essays$ git commit -a -m &quot;finished git 1&quot;\n[main e2fdc30] finished git 1\n 1 file changed, 61 insertions(+), 6 deletions(-)\n</code></pre>\n<p>提交之后分支如下,本次提交并不影响合并方案，只是单纯多加了一次提交而已。</p>\n<img src=\"https://s2.loli.net/2024/05/06/ixv7hQX3VoBcWlN.png\" alt=\"image-20240506020817574\" style=\"zoom:67%;\" />\n<pre><code class=\"language-bash\">git pull --rebase\n# 等价于：\ngit fetch origin/main\ngit rebase origin/main\n</code></pre>\n<img src=\"https://s2.loli.net/2024/05/06/Dy1olHPMKZExYLT.png\" alt=\"image-20240506023005761\" style=\"zoom:67%;\" />\n<p>其中的分支变化如下：</p>\n<img src=\"https://s2.loli.net/2024/05/06/6XujLS5UyvFc4pf.png\" alt=\"image-20240506032249539\"  />\n<p>关于rebase的变化的解释：</p>\n<p>根据精通Git（第二版）的内容，其变基按照如下的方式：</p>\n<ul>\n<li>判断出分支上那些工作是本地独有的（245d、8ea、dd02、e2fdc）。</li>\n<li>判断出哪些提交不是合并提交（245d、8ea、e2fdc）。</li>\n<li>判断出哪些提交并没有被重写到基分支上（orgin/master）（245d、8ea、e2fdc）。</li>\n<li>把筛选出来的分支重写到基分支上</li>\n</ul>\n<p>Git会将合并提交的更改拆分成多个单独的提交，并将它们重新应用在远程分支的顶部。这意味着原始的合并提交（在这个例子中是 <code>dd0258f</code>）不再存在于变基后的分支历史中。</p>\n<p>245df5e提交和e5d18提交完全一致，并不是有效提交，所以被舍弃。</p>\n<p><img src=\"https://s2.loli.net/2024/05/06/AXrHNwx89vnEa2I.png\" alt=\"image-20240506025758663\"></p>\n<p>需要注意的是，没有手动推送上图中test分支，服务器上实际上是没有245df5e,8eafb31的信息的。</p>\n<p>参考：精通Git（第二版）</p>\n"},{"title":"Hexo+github+Markdown博客搭建","date":"2024-09-21T12:46:25.000Z","_content":"\n# Hexo+github+Markdown博客搭建\n\n\n\n<img src=\"https://s2.loli.net/2024/09/29/6Xo9VwZBhLIJ8Yk.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727549184424\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\n<!-- toc -->\n\n[TOC]\n\n\n\n### 特性：\n\n- build工具链支持跨平台使用：linux & windows\n- 部署支持多平台：linux(32&64)&windows&github&docker\n- 一次部署即可使用，支持markdown,mermaid,math公式，TOC目录等markdown特性。\n\n### 工具：\n\nmarkdown工具：Typora\n\n跨平台后端：Nginx\n\n部署平台：orangepi R1 cortex-A7架构 32位双核 & github.io\n\n## Hexo工具链配置\n\nhexo工具包含npm，这里以linux系统为示例，其他系统操作类似：\n\nhttps://nodejs.org/zh-cn/download/package-manager\n\n```\n# installs nvm (Node Version Manager)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash\n\n# download and install Node.js (you may need to restart the terminal)\nnvm install 20\n\n# verifies the right Node.js version is in the environment\nnode -v # should print `v20.17.0`\n\n# verifies the right npm version is in the environment\nnpm -v # should print `10.8.2`\n```\n\n在curl导出环境变量之后记得重新打开命令行，执行下面的命令，安装效果如下：\n\n<img src=\"https://s2.loli.net/2024/09/28/nzrdGvXhjfElPOV.png\" alt=\"image-20240928200056062\" style=\"zoom:80%;\" />\n\n安装hexo：\n\n```bash\nnpm install hexo-cli -g\n```\n\n安装过程很慢，而且没有任何提示。安装完成之后效果如下：\n\n```bash\n(base) neo@NeoNeuxs:~$ npm install hexo-cli -g\n\nadded 53 packages in 6s\n\n14 packages are looking for funding\n  run `npm fund` for details\n```\n\n安装对应主题的插件，这里使用的是claudia,根据其文档效果如下：\n\nhexo官方针对主题使用的文档：https://hexo.io/zh-cn/docs/themes  理解theme需要先看看，后边不会太详细介绍。\n\n我们需要将对应的主题clone到theme文件夹，然后再修改对应的`_config.yml`，包含项目的`_config.yml`和主题的`_config.yml`两者不一样，修改的时候要注意。\n\n这里使用的cluadia主题在：https://github.com/Haojen/hexo-theme-Claudia\n\n根据主题要求安装包，效果如下：\n\n```bash\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-pug \n\nadded 52 packages in 7s\n\n13 packages are looking for funding\n  run `npm fund` for details\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-dartsass\n\nadded 6 packages, and audited 59 packages in 4s\n\n15 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-generator-feed\n\nadded 43 packages, and audited 102 packages in 5s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-filter-flowchart     \n\nadded 3 packages, and audited 105 packages in 3s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-mathjax\nnpm warn deprecated ejs@1.0.0: Critical security bugs fixed in 2.5.5\n\nadded 2 packages, and audited 107 packages in 4s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\n2 critical severity vulnerabilities\n\nSome issues need review, and may require choosing\na different dependency.\n\nRun `npm audit` for details.\n\n```\n\n安装完成后，修改项目的配置文件，这里贴一下我自己的：\n\n```bash\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Hexo\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: NeoNexus\nlanguage: chinese\ntimezone: ''\n\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: http://neonexusx.github.io\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link:\n  enable: true # Open external links in new tab\n  field: site # Apply to the whole site\n  exclude: ''\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nsyntax_highlighter: highlight.js\nhighlight:\n  line_number: false\n  auto_detect: false\n  tab_replace: ''\n  wrap: false\n  hljs: false\nprismjs:\n  preprocess: false\n  line_number: false\n  tab_replace: ''\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Metadata elements\n## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\nmeta_generator: true\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:\nexclude:\nignore:\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: claudia\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repository: git@github.com:######/#########github.io.git\n  branch: main\n # mermaid chart\nmermaid: ## mermaid url https://github.com/knsv/mermaid\n  enable: true  # default true\n  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js\n    #startOnload: true  // default true\n```\n\n主要关闭了代码高亮，添加了mermaid支持，修改主题为claudia，添加了一些信息，同时添加了部署的git信息，还有在对应的服务器上部署的文件信息，这样部署的时候只需要一条命令就能完成多平台的部署。\n\n```bash\n# main menu navigation\nmenu:\n  Home: /\n  About: /about\n  Archive: /archives\n\nwidgets:\n  - tag\n  - archive\n  - recent_posts\n  - category\n  - profile\n\n# social config\nsocial:\n  zhihu:\n  twitter: /\n  facebook: /\n  instagram: /\n  github: https://github.com/NeoNexusX\n\nuser:\n  name: NeoNexus\n  avatar:\n  location: XiaMen\n  description: YOU CAN REDO\n  footnotes: # footnotes\n\n# documents: https://github.com/utterance/utterances\n# API config: https://utteranc.es/\ncomment_utteranc:\n  enable: true\n  repo: Haojen/Claudia-theme-blog # your blog repo\n\n\n# documents: https://valine.js.org/quickstart.html\ncomment_valine:\n  enable: true\n  appId: ############\n  appKey: #########\n\ncomment_disqus:\n    enable: false\n    url:  # the url of your website main domain like this https://xxx.xxx/\n    name: # the short name in disqus\n\n# dark\n# light\n# user-can-set\nappearance: dark # Default value is auto\n\n# Miscellaneous\nfavicon: images/favicon.ico\n\nfriend_links:\n  - title: Google\n    link: https://www.google.com/\n  - title: Github\n    link: https://www.github.com/\n\n# Google Analytics\nga_track_id:\nga_domain:\n\n# Baidu Analytics\nba_track_id:\n\n# picture of about page\nabout_pic: about.png\n\nimage_zoom:\n  enable: true\n \n```\n\n主题的设置文件隐藏了一些关键信息，所以没办法直接使用，主要修改在评论系统引入，一些关键信息修改。\n\n## mermaid添加支持\n\nmermaid是常见的markdown流程图绘制语言，为了添加支持，我们的思路如下：\n\n首先添加对应的npm包支持，然后引入对应的mermaid渲染js代码，调用对应的mermiad初始化函数，引入mermaid支持。\n\n网上的教程思路都是大致如下，但是都是基于不同的主题来实现的，这里使用的claudia使用的模板语言和网上介绍的不一样，我们需要修改一下对应的的代码：\n\n在此路经下`/blog_dev/themes/claudia/layout`存放着如下关于布局的文件内容：\n\n![image-20240928213131729](https://s2.loli.net/2024/09/28/cmNFy6QgAXV8jC9.png)\n\npug后缀代表着对应的模板语言，我们需要在对应的地方插入对应的js代码，同时还需要满足pug的语法要求。考虑到需要在所有内容初始化完成之后使用CDN将mermaid引入，我们选择比较靠后的布局文件，防止影响到其他部分的初始化，这里挑选post部分，添加代码如下：\n\n```pug\n    script(src=`https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js` onload=\"initMermaid()\")\n    script.\n      function initMermaid() {\n       console.log(\"fuck you\");\n        if (window.mermaid) {\n          console.log(\"fuck you\");\n          mermaid.initialize({ theme: 'forest' });\n        }\n      }\n```\n\n其中版本部分本应该使用confiog文件的对象来获取，但是本人不是专业前端，这里引用不到对应的theme对象，没办法只能写死到这里。\n\n添加之后，我们就可以使用了。\n\n使用命令：\n\n```bash\n(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo generate\nINFO  Validating config\nINFO  Start processing\nINFO  Files loaded in 238 ms\nINFO  Generated: 2024/09/27/hello-world/index.html\nINFO  Generated: archives/2024/index.html\nINFO  Generated: atom.xml\nINFO  Generated: archives/2024/09/index.html\nINFO  Generated: 2024/09/28/Bionet-Server01使用说明/index.html\nINFO  Generated: archives/index.html\nINFO  Generated: index.html\nINFO  7 files generated in 14 ms\n```\n\n构建成功之后使用：\n\n```bash\nhexo s\n```\n\n开启测试服务器。\n\n```bash\n(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo s\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n```\n\n## 部署在cortex-A7之上\n\ncortex-A7是一个很老的arm架构了，32位的性能很差，但是我有一个orangepi_r1没有用处，所以拿来部署在内网，关于部署到github.io的文章很多，这里不再赘述，主要关键点在于如何将两个平台的内容进行同步更新，这样方便后续内容的更新与维护。\n\n首先我们要在ubuntu16.04上部署一个nginx服务器，没错H2+跑的是对应已经做好的镜像，这里我也不再赘述，每一个厂家都有做好的镜像来使用。\n\n```bash\nsudo apt update\nsudo apt install nginx\n```\n\n使用命令：\n\n```bash\nsudo systemctl status nginx\n```\n\n如果没有报错，那说明成功了：\n\n```bash\norangepi@orangepir1:~$ sudo systemctl status nginx\n● nginx.service - A high performance web server and a reverse proxy server\n   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)\n   Active: active (running) since Fri 2021-04-02 07:51:53 UTC; 2h 54min ago\n  Process: 1192 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0\n  Process: 1101 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited,\n Main PID: 1203 (nginx)\n   CGroup: /system.slice/nginx.service\n           ├─1203 nginx: master process /usr/sbin/nginx -g daemon on; master_process on\n           ├─1204 nginx: worker process                           \n           ├─1205 nginx: worker process                           \n           ├─1206 nginx: worker process                           \n           └─1207 nginx: worker process                           \n```\n\n接下来我们需要将博客发布到这台服务器上，就需要修改nginx配置，然后转移到我们对应的文件夹，作为nginx的起始目录。\n\n使用命令：\n\n```bash\ncd /etc/nginx/sites-available/\n```\n\n在这里我们修改default文件：\n\n```clike\nserver {\n        listen 80 default_server;\n        listen [::]:80 default_server;\n\n        root /home/orangepi/blogs;\n\n        # Add index.php to the list if you are using PHP\n        index index.html index.htm index.nginx-debian.html;\n        server_name blogs;\n\n        location / {\n                # First attempt to serve request as file, then\n                # as directory, then fall back to displaying a 404.\n                try_files $uri $uri/ =404;\n        }\n}\n\n```\n\n每个修改的对象是什么意思我不再赘述，只需要知道修改了，根目录，location管理部分，其他没有修改。\n\n然后我们重启nginx，让其重新载入设置;\n\n```bash\nsudo systemctl reload nginx\nsudo systemctl restart nginx\n```\n\n当然这里设置的blogs文件夹，需要你提前创建好，同时这个文件夹，在你本地电脑推送到服务器的时候也是要有一定的权限的，所以不要使用sudo来创建。\n\n重启之后我们应该看见，这样一个博客就创建完成了～\n\n<img src=\"https://s2.loli.net/2024/09/28/PJL5cakTy9GQ6rK.png\" alt=\"image-20240928225345569\" style=\"zoom:67%;\" />\n\n## 完成多平台同步推送\n\n多平台同步推送依赖于hexo的deploy功能，根据官方文档，我需要向git和一台服务器进行推送，为了满足这个要求，我们将项目的配置文件修改为如下形式：\n\n```yml\ndeploy:\n  - type: git\n    repository: git@github.com:NeoNexusX/NeoNexusX.github.io.git\n    branch: main\n  - type: rsync\n    host: 你的服务器ip\n    user: 你服务器user\n    root: /home/orangepi/blogs\n    port: 22\n    delete: true\n    verbose: true\n    ignore_errors: false\n  \n```\n\n然后使用命令：\n\n```bash\nhexo deploy\n```\n\n实现推送，效果如下：\n\n<img src=\"https://s2.loli.net/2024/09/28/UrhAX79sebBWauf.png\" alt=\"image-20240928231857713\" style=\"zoom:67%;\" />\n\n## 添加Math公式支持\n\n依据博客修改：\n\nhttps://pku-zyf.github.io/formula/\n\n将上文post.pug添加如下脚本内容：\n\n```pug\n    if theme.mathjax.enable\n      script(type=\"text/x-mathjax-config\").\n        MathJax.Hub.Config({\n          tex2jax: {\n            inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n            processEscapes: true,\n            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n          }\n        });\n        MathJax.Hub.Queue(function() {\n          var all = MathJax.Hub.getAllJax(), i;\n          for(i=0; i < all.length; i += 1) {\n            all[i].SourceElement().parentNode.className += ' has-jax';\n          }\n        });\n      script(type=\"text/javascript\", src=theme.mathjax.cdn)\n```\n\n注意缩进和空格，剩下完全和博客内容一致，不再赘述，只不过不需要打开MathJax开关部分内容。","source":"_posts/Hexo+github+Markdown博客搭建.md","raw":"---\ntitle: Hexo+github+Markdown博客搭建\ncategories:\n  - Bionet\ntags:\n  - Bionet\n  - blog\n  - hexo\ndate: \"2024/09/21 20:46:25\"\n---\n\n# Hexo+github+Markdown博客搭建\n\n\n\n<img src=\"https://s2.loli.net/2024/09/29/6Xo9VwZBhLIJ8Yk.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727549184424\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\n<!-- toc -->\n\n[TOC]\n\n\n\n### 特性：\n\n- build工具链支持跨平台使用：linux & windows\n- 部署支持多平台：linux(32&64)&windows&github&docker\n- 一次部署即可使用，支持markdown,mermaid,math公式，TOC目录等markdown特性。\n\n### 工具：\n\nmarkdown工具：Typora\n\n跨平台后端：Nginx\n\n部署平台：orangepi R1 cortex-A7架构 32位双核 & github.io\n\n## Hexo工具链配置\n\nhexo工具包含npm，这里以linux系统为示例，其他系统操作类似：\n\nhttps://nodejs.org/zh-cn/download/package-manager\n\n```\n# installs nvm (Node Version Manager)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash\n\n# download and install Node.js (you may need to restart the terminal)\nnvm install 20\n\n# verifies the right Node.js version is in the environment\nnode -v # should print `v20.17.0`\n\n# verifies the right npm version is in the environment\nnpm -v # should print `10.8.2`\n```\n\n在curl导出环境变量之后记得重新打开命令行，执行下面的命令，安装效果如下：\n\n<img src=\"https://s2.loli.net/2024/09/28/nzrdGvXhjfElPOV.png\" alt=\"image-20240928200056062\" style=\"zoom:80%;\" />\n\n安装hexo：\n\n```bash\nnpm install hexo-cli -g\n```\n\n安装过程很慢，而且没有任何提示。安装完成之后效果如下：\n\n```bash\n(base) neo@NeoNeuxs:~$ npm install hexo-cli -g\n\nadded 53 packages in 6s\n\n14 packages are looking for funding\n  run `npm fund` for details\n```\n\n安装对应主题的插件，这里使用的是claudia,根据其文档效果如下：\n\nhexo官方针对主题使用的文档：https://hexo.io/zh-cn/docs/themes  理解theme需要先看看，后边不会太详细介绍。\n\n我们需要将对应的主题clone到theme文件夹，然后再修改对应的`_config.yml`，包含项目的`_config.yml`和主题的`_config.yml`两者不一样，修改的时候要注意。\n\n这里使用的cluadia主题在：https://github.com/Haojen/hexo-theme-Claudia\n\n根据主题要求安装包，效果如下：\n\n```bash\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-pug \n\nadded 52 packages in 7s\n\n13 packages are looking for funding\n  run `npm fund` for details\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-dartsass\n\nadded 6 packages, and audited 59 packages in 4s\n\n15 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-generator-feed\n\nadded 43 packages, and audited 102 packages in 5s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-filter-flowchart     \n\nadded 3 packages, and audited 105 packages in 3s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-mathjax\nnpm warn deprecated ejs@1.0.0: Critical security bugs fixed in 2.5.5\n\nadded 2 packages, and audited 107 packages in 4s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\n2 critical severity vulnerabilities\n\nSome issues need review, and may require choosing\na different dependency.\n\nRun `npm audit` for details.\n\n```\n\n安装完成后，修改项目的配置文件，这里贴一下我自己的：\n\n```bash\n# Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Hexo\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: NeoNexus\nlanguage: chinese\ntimezone: ''\n\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: http://neonexusx.github.io\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link:\n  enable: true # Open external links in new tab\n  field: site # Apply to the whole site\n  exclude: ''\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nsyntax_highlighter: highlight.js\nhighlight:\n  line_number: false\n  auto_detect: false\n  tab_replace: ''\n  wrap: false\n  hljs: false\nprismjs:\n  preprocess: false\n  line_number: false\n  tab_replace: ''\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category & Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Metadata elements\n## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\nmeta_generator: true\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:\nexclude:\nignore:\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: claudia\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repository: git@github.com:######/#########github.io.git\n  branch: main\n # mermaid chart\nmermaid: ## mermaid url https://github.com/knsv/mermaid\n  enable: true  # default true\n  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js\n    #startOnload: true  // default true\n```\n\n主要关闭了代码高亮，添加了mermaid支持，修改主题为claudia，添加了一些信息，同时添加了部署的git信息，还有在对应的服务器上部署的文件信息，这样部署的时候只需要一条命令就能完成多平台的部署。\n\n```bash\n# main menu navigation\nmenu:\n  Home: /\n  About: /about\n  Archive: /archives\n\nwidgets:\n  - tag\n  - archive\n  - recent_posts\n  - category\n  - profile\n\n# social config\nsocial:\n  zhihu:\n  twitter: /\n  facebook: /\n  instagram: /\n  github: https://github.com/NeoNexusX\n\nuser:\n  name: NeoNexus\n  avatar:\n  location: XiaMen\n  description: YOU CAN REDO\n  footnotes: # footnotes\n\n# documents: https://github.com/utterance/utterances\n# API config: https://utteranc.es/\ncomment_utteranc:\n  enable: true\n  repo: Haojen/Claudia-theme-blog # your blog repo\n\n\n# documents: https://valine.js.org/quickstart.html\ncomment_valine:\n  enable: true\n  appId: ############\n  appKey: #########\n\ncomment_disqus:\n    enable: false\n    url:  # the url of your website main domain like this https://xxx.xxx/\n    name: # the short name in disqus\n\n# dark\n# light\n# user-can-set\nappearance: dark # Default value is auto\n\n# Miscellaneous\nfavicon: images/favicon.ico\n\nfriend_links:\n  - title: Google\n    link: https://www.google.com/\n  - title: Github\n    link: https://www.github.com/\n\n# Google Analytics\nga_track_id:\nga_domain:\n\n# Baidu Analytics\nba_track_id:\n\n# picture of about page\nabout_pic: about.png\n\nimage_zoom:\n  enable: true\n \n```\n\n主题的设置文件隐藏了一些关键信息，所以没办法直接使用，主要修改在评论系统引入，一些关键信息修改。\n\n## mermaid添加支持\n\nmermaid是常见的markdown流程图绘制语言，为了添加支持，我们的思路如下：\n\n首先添加对应的npm包支持，然后引入对应的mermaid渲染js代码，调用对应的mermiad初始化函数，引入mermaid支持。\n\n网上的教程思路都是大致如下，但是都是基于不同的主题来实现的，这里使用的claudia使用的模板语言和网上介绍的不一样，我们需要修改一下对应的的代码：\n\n在此路经下`/blog_dev/themes/claudia/layout`存放着如下关于布局的文件内容：\n\n![image-20240928213131729](https://s2.loli.net/2024/09/28/cmNFy6QgAXV8jC9.png)\n\npug后缀代表着对应的模板语言，我们需要在对应的地方插入对应的js代码，同时还需要满足pug的语法要求。考虑到需要在所有内容初始化完成之后使用CDN将mermaid引入，我们选择比较靠后的布局文件，防止影响到其他部分的初始化，这里挑选post部分，添加代码如下：\n\n```pug\n    script(src=`https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js` onload=\"initMermaid()\")\n    script.\n      function initMermaid() {\n       console.log(\"fuck you\");\n        if (window.mermaid) {\n          console.log(\"fuck you\");\n          mermaid.initialize({ theme: 'forest' });\n        }\n      }\n```\n\n其中版本部分本应该使用confiog文件的对象来获取，但是本人不是专业前端，这里引用不到对应的theme对象，没办法只能写死到这里。\n\n添加之后，我们就可以使用了。\n\n使用命令：\n\n```bash\n(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo generate\nINFO  Validating config\nINFO  Start processing\nINFO  Files loaded in 238 ms\nINFO  Generated: 2024/09/27/hello-world/index.html\nINFO  Generated: archives/2024/index.html\nINFO  Generated: atom.xml\nINFO  Generated: archives/2024/09/index.html\nINFO  Generated: 2024/09/28/Bionet-Server01使用说明/index.html\nINFO  Generated: archives/index.html\nINFO  Generated: index.html\nINFO  7 files generated in 14 ms\n```\n\n构建成功之后使用：\n\n```bash\nhexo s\n```\n\n开启测试服务器。\n\n```bash\n(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo s\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n```\n\n## 部署在cortex-A7之上\n\ncortex-A7是一个很老的arm架构了，32位的性能很差，但是我有一个orangepi_r1没有用处，所以拿来部署在内网，关于部署到github.io的文章很多，这里不再赘述，主要关键点在于如何将两个平台的内容进行同步更新，这样方便后续内容的更新与维护。\n\n首先我们要在ubuntu16.04上部署一个nginx服务器，没错H2+跑的是对应已经做好的镜像，这里我也不再赘述，每一个厂家都有做好的镜像来使用。\n\n```bash\nsudo apt update\nsudo apt install nginx\n```\n\n使用命令：\n\n```bash\nsudo systemctl status nginx\n```\n\n如果没有报错，那说明成功了：\n\n```bash\norangepi@orangepir1:~$ sudo systemctl status nginx\n● nginx.service - A high performance web server and a reverse proxy server\n   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)\n   Active: active (running) since Fri 2021-04-02 07:51:53 UTC; 2h 54min ago\n  Process: 1192 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0\n  Process: 1101 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited,\n Main PID: 1203 (nginx)\n   CGroup: /system.slice/nginx.service\n           ├─1203 nginx: master process /usr/sbin/nginx -g daemon on; master_process on\n           ├─1204 nginx: worker process                           \n           ├─1205 nginx: worker process                           \n           ├─1206 nginx: worker process                           \n           └─1207 nginx: worker process                           \n```\n\n接下来我们需要将博客发布到这台服务器上，就需要修改nginx配置，然后转移到我们对应的文件夹，作为nginx的起始目录。\n\n使用命令：\n\n```bash\ncd /etc/nginx/sites-available/\n```\n\n在这里我们修改default文件：\n\n```clike\nserver {\n        listen 80 default_server;\n        listen [::]:80 default_server;\n\n        root /home/orangepi/blogs;\n\n        # Add index.php to the list if you are using PHP\n        index index.html index.htm index.nginx-debian.html;\n        server_name blogs;\n\n        location / {\n                # First attempt to serve request as file, then\n                # as directory, then fall back to displaying a 404.\n                try_files $uri $uri/ =404;\n        }\n}\n\n```\n\n每个修改的对象是什么意思我不再赘述，只需要知道修改了，根目录，location管理部分，其他没有修改。\n\n然后我们重启nginx，让其重新载入设置;\n\n```bash\nsudo systemctl reload nginx\nsudo systemctl restart nginx\n```\n\n当然这里设置的blogs文件夹，需要你提前创建好，同时这个文件夹，在你本地电脑推送到服务器的时候也是要有一定的权限的，所以不要使用sudo来创建。\n\n重启之后我们应该看见，这样一个博客就创建完成了～\n\n<img src=\"https://s2.loli.net/2024/09/28/PJL5cakTy9GQ6rK.png\" alt=\"image-20240928225345569\" style=\"zoom:67%;\" />\n\n## 完成多平台同步推送\n\n多平台同步推送依赖于hexo的deploy功能，根据官方文档，我需要向git和一台服务器进行推送，为了满足这个要求，我们将项目的配置文件修改为如下形式：\n\n```yml\ndeploy:\n  - type: git\n    repository: git@github.com:NeoNexusX/NeoNexusX.github.io.git\n    branch: main\n  - type: rsync\n    host: 你的服务器ip\n    user: 你服务器user\n    root: /home/orangepi/blogs\n    port: 22\n    delete: true\n    verbose: true\n    ignore_errors: false\n  \n```\n\n然后使用命令：\n\n```bash\nhexo deploy\n```\n\n实现推送，效果如下：\n\n<img src=\"https://s2.loli.net/2024/09/28/UrhAX79sebBWauf.png\" alt=\"image-20240928231857713\" style=\"zoom:67%;\" />\n\n## 添加Math公式支持\n\n依据博客修改：\n\nhttps://pku-zyf.github.io/formula/\n\n将上文post.pug添加如下脚本内容：\n\n```pug\n    if theme.mathjax.enable\n      script(type=\"text/x-mathjax-config\").\n        MathJax.Hub.Config({\n          tex2jax: {\n            inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n            processEscapes: true,\n            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n          }\n        });\n        MathJax.Hub.Queue(function() {\n          var all = MathJax.Hub.getAllJax(), i;\n          for(i=0; i < all.length; i += 1) {\n            all[i].SourceElement().parentNode.className += ' has-jax';\n          }\n        });\n      script(type=\"text/javascript\", src=theme.mathjax.cdn)\n```\n\n注意缩进和空格，剩下完全和博客内容一致，不再赘述，只不过不需要打开MathJax开关部分内容。","slug":"Hexo+github+Markdown博客搭建","published":1,"updated":"2024-11-27T03:55:57.801Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti070022yjinbhzxf5lj","content":"<h1><span id=\"hexogithubmarkdown博客搭建\">Hexo+github+Markdown博客搭建</span></h1>\n<img src=\"https://s2.loli.net/2024/09/29/6Xo9VwZBhLIJ8Yk.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727549184424\" style=\"zoom:50%;\">\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\">\n<!-- toc -->\n<ul>\n<li><a href=\"#%E7%89%B9%E6%80%A7\">特性：</a></li>\n<li><a href=\"#%E5%B7%A5%E5%85%B7\">工具：</a></li>\n</ul>\n<ul>\n<li><a href=\"#hexo%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE\">Hexo工具链配置</a></li>\n<li><a href=\"#mermaid%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81\">mermaid添加支持</a></li>\n<li><a href=\"#%E9%83%A8%E7%BD%B2%E5%9C%A8cortex-a7%E4%B9%8B%E4%B8%8A\">部署在cortex-A7之上</a></li>\n<li><a href=\"#%E5%AE%8C%E6%88%90%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5%E6%8E%A8%E9%80%81\">完成多平台同步推送</a></li>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0math%E5%85%AC%E5%BC%8F%E6%94%AF%E6%8C%81\">添加Math公式支持</a></li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h3><span id=\"特性\">特性：</span></h3>\n<ul>\n<li>build工具链支持跨平台使用：linux &amp; windows</li>\n<li>部署支持多平台：linux(32&amp;64)&amp;windows&amp;github&amp;docker</li>\n<li>一次部署即可使用，支持markdown,mermaid,math公式，TOC目录等markdown特性。</li>\n</ul>\n<h3><span id=\"工具\">工具：</span></h3>\n<p>markdown工具：Typora</p>\n<p>跨平台后端：Nginx</p>\n<p>部署平台：orangepi R1 cortex-A7架构 32位双核 &amp; <a href=\"http://github.io\">github.io</a></p>\n<h2><span id=\"hexo工具链配置\">Hexo工具链配置</span></h2>\n<p>hexo工具包含npm，这里以linux系统为示例，其他系统操作类似：</p>\n<p><a href=\"https://nodejs.org/zh-cn/download/package-manager\">https://nodejs.org/zh-cn/download/package-manager</a></p>\n<pre><code># installs nvm (Node Version Manager)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash\n\n# download and install Node.js (you may need to restart the terminal)\nnvm install 20\n\n# verifies the right Node.js version is in the environment\nnode -v # should print `v20.17.0`\n\n# verifies the right npm version is in the environment\nnpm -v # should print `10.8.2`\n</code></pre>\n<p>在curl导出环境变量之后记得重新打开命令行，执行下面的命令，安装效果如下：</p>\n<img src=\"https://s2.loli.net/2024/09/28/nzrdGvXhjfElPOV.png\" alt=\"image-20240928200056062\" style=\"zoom:80%;\">\n<p>安装hexo：</p>\n<pre><code class=\"language-bash\">npm install hexo-cli -g\n</code></pre>\n<p>安装过程很慢，而且没有任何提示。安装完成之后效果如下：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~$ npm install hexo-cli -g\n\nadded 53 packages in 6s\n\n14 packages are looking for funding\n  run `npm fund` for details\n</code></pre>\n<p>安装对应主题的插件，这里使用的是claudia,根据其文档效果如下：</p>\n<p>hexo官方针对主题使用的文档：<a href=\"https://hexo.io/zh-cn/docs/themes\">https://hexo.io/zh-cn/docs/themes</a>  理解theme需要先看看，后边不会太详细介绍。</p>\n<p>我们需要将对应的主题clone到theme文件夹，然后再修改对应的<code>_config.yml</code>，包含项目的<code>_config.yml</code>和主题的<code>_config.yml</code>两者不一样，修改的时候要注意。</p>\n<p>这里使用的cluadia主题在：<a href=\"https://github.com/Haojen/hexo-theme-Claudia\">https://github.com/Haojen/hexo-theme-Claudia</a></p>\n<p>根据主题要求安装包，效果如下：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~$ npm install hexo-renderer-pug \n\nadded 52 packages in 7s\n\n13 packages are looking for funding\n  run `npm fund` for details\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-dartsass\n\nadded 6 packages, and audited 59 packages in 4s\n\n15 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-generator-feed\n\nadded 43 packages, and audited 102 packages in 5s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-filter-flowchart     \n\nadded 3 packages, and audited 105 packages in 3s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-mathjax\nnpm warn deprecated ejs@1.0.0: Critical security bugs fixed in 2.5.5\n\nadded 2 packages, and audited 107 packages in 4s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\n2 critical severity vulnerabilities\n\nSome issues need review, and may require choosing\na different dependency.\n\nRun `npm audit` for details.\n\n</code></pre>\n<p>安装完成后，修改项目的配置文件，这里贴一下我自己的：</p>\n<pre><code class=\"language-bash\"># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Hexo\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: NeoNexus\nlanguage: chinese\ntimezone: ''\n\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: http://neonexusx.github.io\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link:\n  enable: true # Open external links in new tab\n  field: site # Apply to the whole site\n  exclude: ''\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nsyntax_highlighter: highlight.js\nhighlight:\n  line_number: false\n  auto_detect: false\n  tab_replace: ''\n  wrap: false\n  hljs: false\nprismjs:\n  preprocess: false\n  line_number: false\n  tab_replace: ''\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category &amp; Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Metadata elements\n## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\nmeta_generator: true\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:\nexclude:\nignore:\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: claudia\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repository: git@github.com:######/#########github.io.git\n  branch: main\n # mermaid chart\nmermaid: ## mermaid url https://github.com/knsv/mermaid\n  enable: true  # default true\n  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js\n    #startOnload: true  // default true\n</code></pre>\n<p>主要关闭了代码高亮，添加了mermaid支持，修改主题为claudia，添加了一些信息，同时添加了部署的git信息，还有在对应的服务器上部署的文件信息，这样部署的时候只需要一条命令就能完成多平台的部署。</p>\n<pre><code class=\"language-bash\"># main menu navigation\nmenu:\n  Home: /\n  About: /about\n  Archive: /archives\n\nwidgets:\n  - tag\n  - archive\n  - recent_posts\n  - category\n  - profile\n\n# social config\nsocial:\n  zhihu:\n  twitter: /\n  facebook: /\n  instagram: /\n  github: https://github.com/NeoNexusX\n\nuser:\n  name: NeoNexus\n  avatar:\n  location: XiaMen\n  description: YOU CAN REDO\n  footnotes: # footnotes\n\n# documents: https://github.com/utterance/utterances\n# API config: https://utteranc.es/\ncomment_utteranc:\n  enable: true\n  repo: Haojen/Claudia-theme-blog # your blog repo\n\n\n# documents: https://valine.js.org/quickstart.html\ncomment_valine:\n  enable: true\n  appId: ############\n  appKey: #########\n\ncomment_disqus:\n    enable: false\n    url:  # the url of your website main domain like this https://xxx.xxx/\n    name: # the short name in disqus\n\n# dark\n# light\n# user-can-set\nappearance: dark # Default value is auto\n\n# Miscellaneous\nfavicon: images/favicon.ico\n\nfriend_links:\n  - title: Google\n    link: https://www.google.com/\n  - title: Github\n    link: https://www.github.com/\n\n# Google Analytics\nga_track_id:\nga_domain:\n\n# Baidu Analytics\nba_track_id:\n\n# picture of about page\nabout_pic: about.png\n\nimage_zoom:\n  enable: true\n \n</code></pre>\n<p>主题的设置文件隐藏了一些关键信息，所以没办法直接使用，主要修改在评论系统引入，一些关键信息修改。</p>\n<h2><span id=\"mermaid添加支持\">mermaid添加支持</span></h2>\n<p>mermaid是常见的markdown流程图绘制语言，为了添加支持，我们的思路如下：</p>\n<p>首先添加对应的npm包支持，然后引入对应的mermaid渲染js代码，调用对应的mermiad初始化函数，引入mermaid支持。</p>\n<p>网上的教程思路都是大致如下，但是都是基于不同的主题来实现的，这里使用的claudia使用的模板语言和网上介绍的不一样，我们需要修改一下对应的的代码：</p>\n<p>在此路经下<code>/blog_dev/themes/claudia/layout</code>存放着如下关于布局的文件内容：</p>\n<p><img src=\"https://s2.loli.net/2024/09/28/cmNFy6QgAXV8jC9.png\" alt=\"image-20240928213131729\"></p>\n<p>pug后缀代表着对应的模板语言，我们需要在对应的地方插入对应的js代码，同时还需要满足pug的语法要求。考虑到需要在所有内容初始化完成之后使用CDN将mermaid引入，我们选择比较靠后的布局文件，防止影响到其他部分的初始化，这里挑选post部分，添加代码如下：</p>\n<pre><code class=\"language-pug\">    script(src=`https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js` onload=\"initMermaid()\")\n    script.\n      function initMermaid() {\n       console.log(\"fuck you\");\n        if (window.mermaid) {\n          console.log(\"fuck you\");\n          mermaid.initialize({ theme: 'forest' });\n        }\n      }\n</code></pre>\n<p>其中版本部分本应该使用confiog文件的对象来获取，但是本人不是专业前端，这里引用不到对应的theme对象，没办法只能写死到这里。</p>\n<p>添加之后，我们就可以使用了。</p>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo generate\nINFO  Validating config\nINFO  Start processing\nINFO  Files loaded in 238 ms\nINFO  Generated: 2024/09/27/hello-world/index.html\nINFO  Generated: archives/2024/index.html\nINFO  Generated: atom.xml\nINFO  Generated: archives/2024/09/index.html\nINFO  Generated: 2024/09/28/Bionet-Server01使用说明/index.html\nINFO  Generated: archives/index.html\nINFO  Generated: index.html\nINFO  7 files generated in 14 ms\n</code></pre>\n<p>构建成功之后使用：</p>\n<pre><code class=\"language-bash\">hexo s\n</code></pre>\n<p>开启测试服务器。</p>\n<pre><code class=\"language-bash\">(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo s\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n</code></pre>\n<h2><span id=\"部署在cortex-a7之上\">部署在cortex-A7之上</span></h2>\n<p>cortex-A7是一个很老的arm架构了，32位的性能很差，但是我有一个orangepi_r1没有用处，所以拿来部署在内网，关于部署到github.io的文章很多，这里不再赘述，主要关键点在于如何将两个平台的内容进行同步更新，这样方便后续内容的更新与维护。</p>\n<p>首先我们要在ubuntu16.04上部署一个nginx服务器，没错H2+跑的是对应已经做好的镜像，这里我也不再赘述，每一个厂家都有做好的镜像来使用。</p>\n<pre><code class=\"language-bash\">sudo apt update\nsudo apt install nginx\n</code></pre>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">sudo systemctl status nginx\n</code></pre>\n<p>如果没有报错，那说明成功了：</p>\n<pre><code class=\"language-bash\">orangepi@orangepir1:~$ sudo systemctl status nginx\n● nginx.service - A high performance web server and a reverse proxy server\n   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)\n   Active: active (running) since Fri 2021-04-02 07:51:53 UTC; 2h 54min ago\n  Process: 1192 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0\n  Process: 1101 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited,\n Main PID: 1203 (nginx)\n   CGroup: /system.slice/nginx.service\n           ├─1203 nginx: master process /usr/sbin/nginx -g daemon on; master_process on\n           ├─1204 nginx: worker process                           \n           ├─1205 nginx: worker process                           \n           ├─1206 nginx: worker process                           \n           └─1207 nginx: worker process                           \n</code></pre>\n<p>接下来我们需要将博客发布到这台服务器上，就需要修改nginx配置，然后转移到我们对应的文件夹，作为nginx的起始目录。</p>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">cd /etc/nginx/sites-available/\n</code></pre>\n<p>在这里我们修改default文件：</p>\n<pre><code class=\"language-clike\">server {\n        listen 80 default_server;\n        listen [::]:80 default_server;\n\n        root /home/orangepi/blogs;\n\n        # Add index.php to the list if you are using PHP\n        index index.html index.htm index.nginx-debian.html;\n        server_name blogs;\n\n        location / {\n                # First attempt to serve request as file, then\n                # as directory, then fall back to displaying a 404.\n                try_files $uri $uri/ =404;\n        }\n}\n\n</code></pre>\n<p>每个修改的对象是什么意思我不再赘述，只需要知道修改了，根目录，location管理部分，其他没有修改。</p>\n<p>然后我们重启nginx，让其重新载入设置;</p>\n<pre><code class=\"language-bash\">sudo systemctl reload nginx\nsudo systemctl restart nginx\n</code></pre>\n<p>当然这里设置的blogs文件夹，需要你提前创建好，同时这个文件夹，在你本地电脑推送到服务器的时候也是要有一定的权限的，所以不要使用sudo来创建。</p>\n<p>重启之后我们应该看见，这样一个博客就创建完成了～</p>\n<img src=\"https://s2.loli.net/2024/09/28/PJL5cakTy9GQ6rK.png\" alt=\"image-20240928225345569\" style=\"zoom:67%;\">\n<h2><span id=\"完成多平台同步推送\">完成多平台同步推送</span></h2>\n<p>多平台同步推送依赖于hexo的deploy功能，根据官方文档，我需要向git和一台服务器进行推送，为了满足这个要求，我们将项目的配置文件修改为如下形式：</p>\n<pre><code class=\"language-yml\">deploy:\n  - type: git\n    repository: git@github.com:NeoNexusX/NeoNexusX.github.io.git\n    branch: main\n  - type: rsync\n    host: 你的服务器ip\n    user: 你服务器user\n    root: /home/orangepi/blogs\n    port: 22\n    delete: true\n    verbose: true\n    ignore_errors: false\n  \n</code></pre>\n<p>然后使用命令：</p>\n<pre><code class=\"language-bash\">hexo deploy\n</code></pre>\n<p>实现推送，效果如下：</p>\n<img src=\"https://s2.loli.net/2024/09/28/UrhAX79sebBWauf.png\" alt=\"image-20240928231857713\" style=\"zoom:67%;\">\n<h2><span id=\"添加math公式支持\">添加Math公式支持</span></h2>\n<p>依据博客修改：</p>\n<p><a href=\"https://pku-zyf.github.io/formula/\">https://pku-zyf.github.io/formula/</a></p>\n<p>将上文post.pug添加如下脚本内容：</p>\n<pre><code class=\"language-pug\">    if theme.mathjax.enable\n      script(type=\"text/x-mathjax-config\").\n        MathJax.Hub.Config({\n          tex2jax: {\n            inlineMath: [ ['$','$'], [\"\\\\(\",\"\\\\)\"] ],\n            processEscapes: true,\n            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n          }\n        });\n        MathJax.Hub.Queue(function() {\n          var all = MathJax.Hub.getAllJax(), i;\n          for(i=0; i &lt; all.length; i += 1) {\n            all[i].SourceElement().parentNode.className += ' has-jax';\n          }\n        });\n      script(type=\"text/javascript\", src=theme.mathjax.cdn)\n</code></pre>\n<p>注意缩进和空格，剩下完全和博客内容一致，不再赘述，只不过不需要打开MathJax开关部分内容。</p>\n","excerpt":"","more":"<h1>Hexo+github+Markdown博客搭建</h1>\n<img src=\"https://s2.loli.net/2024/09/29/6Xo9VwZBhLIJ8Yk.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727549184424\" style=\"zoom:50%;\" />\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n<!-- toc -->\n<ul>\n<li><a href=\"#%E7%89%B9%E6%80%A7\">特性：</a></li>\n<li><a href=\"#%E5%B7%A5%E5%85%B7\">工具：</a></li>\n</ul>\n<ul>\n<li><a href=\"#hexo%E5%B7%A5%E5%85%B7%E9%93%BE%E9%85%8D%E7%BD%AE\">Hexo工具链配置</a></li>\n<li><a href=\"#mermaid%E6%B7%BB%E5%8A%A0%E6%94%AF%E6%8C%81\">mermaid添加支持</a></li>\n<li><a href=\"#%E9%83%A8%E7%BD%B2%E5%9C%A8cortex-a7%E4%B9%8B%E4%B8%8A\">部署在cortex-A7之上</a></li>\n<li><a href=\"#%E5%AE%8C%E6%88%90%E5%A4%9A%E5%B9%B3%E5%8F%B0%E5%90%8C%E6%AD%A5%E6%8E%A8%E9%80%81\">完成多平台同步推送</a></li>\n<li><a href=\"#%E6%B7%BB%E5%8A%A0math%E5%85%AC%E5%BC%8F%E6%94%AF%E6%8C%81\">添加Math公式支持</a></li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h3 id=\"特性：\">特性：</h3>\n<ul>\n<li>build工具链支持跨平台使用：linux &amp; windows</li>\n<li>部署支持多平台：linux(32&amp;64)&amp;windows&amp;github&amp;docker</li>\n<li>一次部署即可使用，支持markdown,mermaid,math公式，TOC目录等markdown特性。</li>\n</ul>\n<h3 id=\"工具：\">工具：</h3>\n<p>markdown工具：Typora</p>\n<p>跨平台后端：Nginx</p>\n<p>部署平台：orangepi R1 cortex-A7架构 32位双核 &amp; <a href=\"http://github.io\">github.io</a></p>\n<h2 id=\"Hexo工具链配置\">Hexo工具链配置</h2>\n<p>hexo工具包含npm，这里以linux系统为示例，其他系统操作类似：</p>\n<p><a href=\"https://nodejs.org/zh-cn/download/package-manager\">https://nodejs.org/zh-cn/download/package-manager</a></p>\n<pre><code># installs nvm (Node Version Manager)\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.0/install.sh | bash\n\n# download and install Node.js (you may need to restart the terminal)\nnvm install 20\n\n# verifies the right Node.js version is in the environment\nnode -v # should print `v20.17.0`\n\n# verifies the right npm version is in the environment\nnpm -v # should print `10.8.2`\n</code></pre>\n<p>在curl导出环境变量之后记得重新打开命令行，执行下面的命令，安装效果如下：</p>\n<img src=\"https://s2.loli.net/2024/09/28/nzrdGvXhjfElPOV.png\" alt=\"image-20240928200056062\" style=\"zoom:80%;\" />\n<p>安装hexo：</p>\n<pre><code class=\"language-bash\">npm install hexo-cli -g\n</code></pre>\n<p>安装过程很慢，而且没有任何提示。安装完成之后效果如下：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~$ npm install hexo-cli -g\n\nadded 53 packages in 6s\n\n14 packages are looking for funding\n  run `npm fund` for details\n</code></pre>\n<p>安装对应主题的插件，这里使用的是claudia,根据其文档效果如下：</p>\n<p>hexo官方针对主题使用的文档：<a href=\"https://hexo.io/zh-cn/docs/themes\">https://hexo.io/zh-cn/docs/themes</a>  理解theme需要先看看，后边不会太详细介绍。</p>\n<p>我们需要将对应的主题clone到theme文件夹，然后再修改对应的<code>_config.yml</code>，包含项目的<code>_config.yml</code>和主题的<code>_config.yml</code>两者不一样，修改的时候要注意。</p>\n<p>这里使用的cluadia主题在：<a href=\"https://github.com/Haojen/hexo-theme-Claudia\">https://github.com/Haojen/hexo-theme-Claudia</a></p>\n<p>根据主题要求安装包，效果如下：</p>\n<pre><code class=\"language-bash\">(base) neo@NeoNeuxs:~$ npm install hexo-renderer-pug \n\nadded 52 packages in 7s\n\n13 packages are looking for funding\n  run `npm fund` for details\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-dartsass\n\nadded 6 packages, and audited 59 packages in 4s\n\n15 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-generator-feed\n\nadded 43 packages, and audited 102 packages in 5s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-filter-flowchart     \n\nadded 3 packages, and audited 105 packages in 3s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\nfound 0 vulnerabilities\n(base) neo@NeoNeuxs:~$ npm install hexo-renderer-mathjax\nnpm warn deprecated ejs@1.0.0: Critical security bugs fixed in 2.5.5\n\nadded 2 packages, and audited 107 packages in 4s\n\n25 packages are looking for funding\n  run `npm fund` for details\n\n2 critical severity vulnerabilities\n\nSome issues need review, and may require choosing\na different dependency.\n\nRun `npm audit` for details.\n\n</code></pre>\n<p>安装完成后，修改项目的配置文件，这里贴一下我自己的：</p>\n<pre><code class=\"language-bash\"># Hexo Configuration\n## Docs: https://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n\n# Site\ntitle: Hexo\nsubtitle: ''\ndescription: ''\nkeywords:\nauthor: NeoNexus\nlanguage: chinese\ntimezone: ''\n\n# URL\n## Set your site url here. For example, if you use GitHub Page, set url as 'https://username.github.io/project'\nurl: http://neonexusx.github.io\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from permalinks\n\n# Directory\nsource_dir: source\npublic_dir: public\ntag_dir: tags\narchive_dir: archives\ncategory_dir: categories\ncode_dir: downloads/code\ni18n_dir: :lang\nskip_render:\n\n# Writing\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\ntitlecase: false # Transform title into titlecase\nexternal_link:\n  enable: true # Open external links in new tab\n  field: site # Apply to the whole site\n  exclude: ''\nfilename_case: 0\nrender_drafts: false\npost_asset_folder: false\nrelative_link: false\nfuture: true\nsyntax_highlighter: highlight.js\nhighlight:\n  line_number: false\n  auto_detect: false\n  tab_replace: ''\n  wrap: false\n  hljs: false\nprismjs:\n  preprocess: false\n  line_number: false\n  tab_replace: ''\n\n# Home page setting\n# path: Root path for your blogs index page. (default = '')\n# per_page: Posts displayed per page. (0 = disable pagination)\n# order_by: Posts order. (Order by date descending by default)\nindex_generator:\n  path: ''\n  per_page: 10\n  order_by: -date\n\n# Category &amp; Tag\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n\n# Metadata elements\n## https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta\nmeta_generator: true\n\n# Date / Time format\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: YYYY-MM-DD\ntime_format: HH:mm:ss\n## updated_option supports 'mtime', 'date', 'empty'\nupdated_option: 'mtime'\n\n# Pagination\n## Set per_page to 0 to disable pagination\nper_page: 10\npagination_dir: page\n\n# Include / Exclude file(s)\n## include:/exclude: options only apply to the 'source/' folder\ninclude:\nexclude:\nignore:\n\n# Extensions\n## Plugins: https://hexo.io/plugins/\n## Themes: https://hexo.io/themes/\ntheme: claudia\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repository: git@github.com:######/#########github.io.git\n  branch: main\n # mermaid chart\nmermaid: ## mermaid url https://github.com/knsv/mermaid\n  enable: true  # default true\n  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js\n    #startOnload: true  // default true\n</code></pre>\n<p>主要关闭了代码高亮，添加了mermaid支持，修改主题为claudia，添加了一些信息，同时添加了部署的git信息，还有在对应的服务器上部署的文件信息，这样部署的时候只需要一条命令就能完成多平台的部署。</p>\n<pre><code class=\"language-bash\"># main menu navigation\nmenu:\n  Home: /\n  About: /about\n  Archive: /archives\n\nwidgets:\n  - tag\n  - archive\n  - recent_posts\n  - category\n  - profile\n\n# social config\nsocial:\n  zhihu:\n  twitter: /\n  facebook: /\n  instagram: /\n  github: https://github.com/NeoNexusX\n\nuser:\n  name: NeoNexus\n  avatar:\n  location: XiaMen\n  description: YOU CAN REDO\n  footnotes: # footnotes\n\n# documents: https://github.com/utterance/utterances\n# API config: https://utteranc.es/\ncomment_utteranc:\n  enable: true\n  repo: Haojen/Claudia-theme-blog # your blog repo\n\n\n# documents: https://valine.js.org/quickstart.html\ncomment_valine:\n  enable: true\n  appId: ############\n  appKey: #########\n\ncomment_disqus:\n    enable: false\n    url:  # the url of your website main domain like this https://xxx.xxx/\n    name: # the short name in disqus\n\n# dark\n# light\n# user-can-set\nappearance: dark # Default value is auto\n\n# Miscellaneous\nfavicon: images/favicon.ico\n\nfriend_links:\n  - title: Google\n    link: https://www.google.com/\n  - title: Github\n    link: https://www.github.com/\n\n# Google Analytics\nga_track_id:\nga_domain:\n\n# Baidu Analytics\nba_track_id:\n\n# picture of about page\nabout_pic: about.png\n\nimage_zoom:\n  enable: true\n \n</code></pre>\n<p>主题的设置文件隐藏了一些关键信息，所以没办法直接使用，主要修改在评论系统引入，一些关键信息修改。</p>\n<h2 id=\"mermaid添加支持\">mermaid添加支持</h2>\n<p>mermaid是常见的markdown流程图绘制语言，为了添加支持，我们的思路如下：</p>\n<p>首先添加对应的npm包支持，然后引入对应的mermaid渲染js代码，调用对应的mermiad初始化函数，引入mermaid支持。</p>\n<p>网上的教程思路都是大致如下，但是都是基于不同的主题来实现的，这里使用的claudia使用的模板语言和网上介绍的不一样，我们需要修改一下对应的的代码：</p>\n<p>在此路经下<code>/blog_dev/themes/claudia/layout</code>存放着如下关于布局的文件内容：</p>\n<p><img src=\"https://s2.loli.net/2024/09/28/cmNFy6QgAXV8jC9.png\" alt=\"image-20240928213131729\"></p>\n<p>pug后缀代表着对应的模板语言，我们需要在对应的地方插入对应的js代码，同时还需要满足pug的语法要求。考虑到需要在所有内容初始化完成之后使用CDN将mermaid引入，我们选择比较靠后的布局文件，防止影响到其他部分的初始化，这里挑选post部分，添加代码如下：</p>\n<pre><code class=\"language-pug\">    script(src=`https://unpkg.com/mermaid@10.6.1/dist/mermaid.min.js` onload=&quot;initMermaid()&quot;)\n    script.\n      function initMermaid() &#123;\n       console.log(&quot;fuck you&quot;);\n        if (window.mermaid) &#123;\n          console.log(&quot;fuck you&quot;);\n          mermaid.initialize(&#123; theme: 'forest' &#125;);\n        &#125;\n      &#125;\n</code></pre>\n<p>其中版本部分本应该使用confiog文件的对象来获取，但是本人不是专业前端，这里引用不到对应的theme对象，没办法只能写死到这里。</p>\n<p>添加之后，我们就可以使用了。</p>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo generate\nINFO  Validating config\nINFO  Start processing\nINFO  Files loaded in 238 ms\nINFO  Generated: 2024/09/27/hello-world/index.html\nINFO  Generated: archives/2024/index.html\nINFO  Generated: atom.xml\nINFO  Generated: archives/2024/09/index.html\nINFO  Generated: 2024/09/28/Bionet-Server01使用说明/index.html\nINFO  Generated: archives/index.html\nINFO  Generated: index.html\nINFO  7 files generated in 14 ms\n</code></pre>\n<p>构建成功之后使用：</p>\n<pre><code class=\"language-bash\">hexo s\n</code></pre>\n<p>开启测试服务器。</p>\n<pre><code class=\"language-bash\">(base) neo@Mark06-U:~/Desktop/blog_dev$ hexo s\nINFO  Validating config\nINFO  Start processing\nINFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.\n</code></pre>\n<h2 id=\"部署在cortex-A7之上\">部署在cortex-A7之上</h2>\n<p>cortex-A7是一个很老的arm架构了，32位的性能很差，但是我有一个orangepi_r1没有用处，所以拿来部署在内网，关于部署到github.io的文章很多，这里不再赘述，主要关键点在于如何将两个平台的内容进行同步更新，这样方便后续内容的更新与维护。</p>\n<p>首先我们要在ubuntu16.04上部署一个nginx服务器，没错H2+跑的是对应已经做好的镜像，这里我也不再赘述，每一个厂家都有做好的镜像来使用。</p>\n<pre><code class=\"language-bash\">sudo apt update\nsudo apt install nginx\n</code></pre>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">sudo systemctl status nginx\n</code></pre>\n<p>如果没有报错，那说明成功了：</p>\n<pre><code class=\"language-bash\">orangepi@orangepir1:~$ sudo systemctl status nginx\n● nginx.service - A high performance web server and a reverse proxy server\n   Loaded: loaded (/lib/systemd/system/nginx.service; enabled; vendor preset: enabled)\n   Active: active (running) since Fri 2021-04-02 07:51:53 UTC; 2h 54min ago\n  Process: 1192 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0\n  Process: 1101 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited,\n Main PID: 1203 (nginx)\n   CGroup: /system.slice/nginx.service\n           ├─1203 nginx: master process /usr/sbin/nginx -g daemon on; master_process on\n           ├─1204 nginx: worker process                           \n           ├─1205 nginx: worker process                           \n           ├─1206 nginx: worker process                           \n           └─1207 nginx: worker process                           \n</code></pre>\n<p>接下来我们需要将博客发布到这台服务器上，就需要修改nginx配置，然后转移到我们对应的文件夹，作为nginx的起始目录。</p>\n<p>使用命令：</p>\n<pre><code class=\"language-bash\">cd /etc/nginx/sites-available/\n</code></pre>\n<p>在这里我们修改default文件：</p>\n<pre><code class=\"language-clike\">server &#123;\n        listen 80 default_server;\n        listen [::]:80 default_server;\n\n        root /home/orangepi/blogs;\n\n        # Add index.php to the list if you are using PHP\n        index index.html index.htm index.nginx-debian.html;\n        server_name blogs;\n\n        location / &#123;\n                # First attempt to serve request as file, then\n                # as directory, then fall back to displaying a 404.\n                try_files $uri $uri/ =404;\n        &#125;\n&#125;\n\n</code></pre>\n<p>每个修改的对象是什么意思我不再赘述，只需要知道修改了，根目录，location管理部分，其他没有修改。</p>\n<p>然后我们重启nginx，让其重新载入设置;</p>\n<pre><code class=\"language-bash\">sudo systemctl reload nginx\nsudo systemctl restart nginx\n</code></pre>\n<p>当然这里设置的blogs文件夹，需要你提前创建好，同时这个文件夹，在你本地电脑推送到服务器的时候也是要有一定的权限的，所以不要使用sudo来创建。</p>\n<p>重启之后我们应该看见，这样一个博客就创建完成了～</p>\n<img src=\"https://s2.loli.net/2024/09/28/PJL5cakTy9GQ6rK.png\" alt=\"image-20240928225345569\" style=\"zoom:67%;\" />\n<h2 id=\"完成多平台同步推送\">完成多平台同步推送</h2>\n<p>多平台同步推送依赖于hexo的deploy功能，根据官方文档，我需要向git和一台服务器进行推送，为了满足这个要求，我们将项目的配置文件修改为如下形式：</p>\n<pre><code class=\"language-yml\">deploy:\n  - type: git\n    repository: git@github.com:NeoNexusX/NeoNexusX.github.io.git\n    branch: main\n  - type: rsync\n    host: 你的服务器ip\n    user: 你服务器user\n    root: /home/orangepi/blogs\n    port: 22\n    delete: true\n    verbose: true\n    ignore_errors: false\n  \n</code></pre>\n<p>然后使用命令：</p>\n<pre><code class=\"language-bash\">hexo deploy\n</code></pre>\n<p>实现推送，效果如下：</p>\n<img src=\"https://s2.loli.net/2024/09/28/UrhAX79sebBWauf.png\" alt=\"image-20240928231857713\" style=\"zoom:67%;\" />\n<h2 id=\"添加Math公式支持\">添加Math公式支持</h2>\n<p>依据博客修改：</p>\n<p><a href=\"https://pku-zyf.github.io/formula/\">https://pku-zyf.github.io/formula/</a></p>\n<p>将上文post.pug添加如下脚本内容：</p>\n<pre><code class=\"language-pug\">    if theme.mathjax.enable\n      script(type=&quot;text/x-mathjax-config&quot;).\n        MathJax.Hub.Config(&#123;\n          tex2jax: &#123;\n            inlineMath: [ ['$','$'], [&quot;\\\\(&quot;,&quot;\\\\)&quot;] ],\n            processEscapes: true,\n            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']\n          &#125;\n        &#125;);\n        MathJax.Hub.Queue(function() &#123;\n          var all = MathJax.Hub.getAllJax(), i;\n          for(i=0; i &lt; all.length; i += 1) &#123;\n            all[i].SourceElement().parentNode.className += ' has-jax';\n          &#125;\n        &#125;);\n      script(type=&quot;text/javascript&quot;, src=theme.mathjax.cdn)\n</code></pre>\n<p>注意缩进和空格，剩下完全和博客内容一致，不再赘述，只不过不需要打开MathJax开关部分内容。</p>\n"},{"title":"NAS服务器使用说明","date":"2024-09-29T12:46:25.000Z","_content":"\n\n\n# NAS服务器使用说明\n\n<img src=\"https://s2.loli.net/2024/09/29/F4JzXvoRg5kuWin.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547916644\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.0\n\nDate: 2024.04.23\n\nAuthors：Tr，NeoNeuxs\n\n<!-- toc -->\n\n## 基本的网络要求\n\n网络要求需要在校园网中，在校园网外需要使用VPN来进行上传。上传文件的速度取决于你的链接速度，推荐使用网线上传。\n\n为什么我的网速很慢？打开校园网链接信息，网线连接的用户，一般不用考虑这个问题，此处可以跳过。\n\n<img src=\"https://s2.loli.net/2024/04/23/CWBdyLkx72UXKna.png\" alt=\"image-20240423215045985\" style=\"zoom:67%;\" />\n\n查看连接信息：\n\n<img src=\"https://s2.loli.net/2024/04/23/S2b6eO89k7hdFAH.png\" alt=\"image-20240423215142791\" style=\"zoom:80%;\" />\n\n应连接到5HZ频段，2.4Ghz频段速度较低，较慢的情况如下：\n\n<img src=\"https://s2.loli.net/2024/04/23/8G6U7LedFmag9z4.png\" alt=\"image-20240423215305320\" style=\"zoom:67%;\" />\n\n**72Mbps相当于10M左右的网速，如果上传100GB的数据那就需要100*1000/10 = 10000s，也就是2.78个小时才能完成上传。**所以使用的时候请注意。\n\n如何从2.4Ghz切换到5Ghz？首先电脑支持5Ghz频段才能使用，2.4Ghz频段切换方法如下：\n\n![image-20240423215639861](https://s2.loli.net/2024/04/23/j2pdsZQyIFPi7C8.png)\n\n点击**断开连接**后再次点击连接就能查看所连接的信息是否改变，没有改变的情况下，多次尝试即可。\n\n## 目录结构\n\n![image-20240424234753210](https://s2.loli.net/2024/04/24/9Yz6UONRdgisnwT.png)\n\n第一级目录存放了两个文件夹，分别是我个人的用户文件夹，**公用的数据文件夹Dataset**，一般要求如下：\n\n![image-20240424235033899](https://s2.loli.net/2024/04/24/T1PUYLxzKVSsNkl.png)\n\n## 如何建立映射来上传内容\n\n1.打开我的电脑，并在左侧右击“此电脑”，然后点击“映射网络驱动器”。\n\n![image-20240423202540683](https://s2.loli.net/2024/04/23/zVMEx1q9O4QJt2m.png)\n\n2.弹出弹窗，点击“连接到可用于存储文档和图片的网站”。\n\n![image-20240423203018882](https://s2.loli.net/2024/04/23/A1ihgnZuxBNJY97.png)\n\n3.点两次下一步。\n\n![image-20240423203100159](https://s2.loli.net/2024/04/23/QjiskIncw7T9E4G.png)\n\n![image-20240423203212778](https://s2.loli.net/2024/04/23/O1yt4lv8H95XdWn.png)\n\n4.输入Internet地址或网络地址：\n\n```\nftp://10.26.58.111\n```\n\n![image-20240423203455064](https://s2.loli.net/2024/04/23/s981hadbKNUWYJr.png)\n\n5.一定记得**取消匿名登录**！！输入用户名“bionet\"。\n\n![image-20240423203635552](https://s2.loli.net/2024/04/23/NnB3aCoSYVpLDzy.png)\n\n![image-20240423203732896](https://s2.loli.net/2024/04/23/heH3M2NxyAZXmUf.png)\n\n6.给你这个网络位置起一个名字，这里自己起一个方便自己标识的名字就行，这里我起名叫做bionet-tr。\n\n![image-20240423204219721](https://s2.loli.net/2024/04/23/rXPga2uA43iMG8W.png)\n\n7.输入密码之后，密码详见群内信息，完成。\n\n![image-20240423204302462](https://s2.loli.net/2024/04/23/GUFsW2z6jOCyVxH.png)\n\n8.使用。此时“我的电脑”会出现以下网络连接图标，点击图标进入。此时就可以通过拖拽进行数据上传了。\n\n![image-20240423204424138](https://s2.loli.net/2024/04/23/1DqclYEfFA2Jpia.png)\n\n![image-20240423204739094](https://s2.loli.net/2024/04/23/tnK86qs74ToNxZD.png)\n\n## 上传内容没有及时更新该怎么办？\n\n映射之后，我们打开：\n\n![image-20240423214856217](https://s2.loli.net/2024/04/23/THoBR5P9wdnQmK7.png)\n\n点击刷新即可：\n\n![image-20240423214906566](https://s2.loli.net/2024/04/23/3W4yhu2RpxQgZd7.png)\n\n## 一些使用规则\n\n由于FTP权限管理比较薄弱，各位拥有的权限都比较高，所以请将较大的数据集放入Dataset文件夹：\n\n再强调一遍！请将对应的数据放到Dataset文件夹，按照以下命名规则：\n\n`使用者姓名__数据集名__版本`。举个例子：\n\n![image-20240423220546039](https://s2.loli.net/2024/04/23/ySpLnWN9D3VewUu.png)\n\n**需要强调的是，v是小写，`_`是英文下划线，一个即可。**\n\n**创建之后没有及时显示，请刷新即可**。\n\n私人文件请放入上一层，以自己名字命名的文件夹下，请创建自己的文件夹如图所示：\n\n<img src=\"https://s2.loli.net/2024/04/23/x59UIvJ81hN7HmY.png\" alt=\"image-20240423220213345\" style=\"zoom:67%;\" />\n\n**创建之后没有及时显示，请刷新即可**。\n\n## 上传之后如何在服务器上使用\n\n该NAS服务器映射在原来服务器的/home/Data_NAS/路径下。进入该路径即可看到所有上传的数据。\n\n<img src=\"https://s2.loli.net/2024/04/23/ZcW8fD2J1u6gib5.png\" alt=\"image-20240423205229731\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/23/BARezykG3fYimQ2.png\" alt=\"image-20240423205433620\" style=\"zoom:80%;\" />\n\n## 最佳实践\n\n### 一些基础知识\n\n下图展示了存储配置的全部架构：\n\n```mermaid\ngraph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n    \n    \n    A--\"Datasets文件夹依赖于\"--->C\n    A--\"运行依赖于\"--->B\n    A--\"运行依赖于\"--->F\n    B--\"Datasets文件夹依赖于\"--->C\n    F--\"Datasets文件夹依赖于\"--->C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"--->B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==>C\n    D--\"连接运行\"--->A\n    E--\"数据\"-->D\n   \n```\n\n在这里再次对主机（服务器主机）上存在的文件解释一下：\n\n主机上的文件存储由这样的硬盘空间组成的,分为高速、中速、低速区。顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：\n\n`Data_NAS(Datasets) > Samsung 860evo 512G  > GLOWAY YCQ4TNVMe-M.2` \n\n其中每一条格式如下：[分区名、挂载路径、分区大小]\n\n```mermaid\ngraph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --> nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --> nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --> nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --> nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --> nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --> nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --> MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --> sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --> sda2[\"sda2,[/boot],1GB\"]\n  sda --> empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --> LowSpeed\n  subgraph LowSpeed\n  NAS --> NFS1(NFS,/home/Data_NAS,16T)\n  NAS --> NFS2(NFS,/home/Datasets,16T)\n  end\n```\n\n这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件\n\n![image-20240513230049068](https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png)\n\n一共包含五个文件夹：\n\n- Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：`上传者_数据集名称_上传日期`。\n  - 此文件夹使用详见：[NAS服务器使用说明](http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/)\n- Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。\n- PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】\n- NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改），其不被多个服务器所共享，**只保存在No1或者No2服务器上**。\n- Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。\n\n- SoftWares文件夹比较特殊：\n\n![image-20240401205431946](https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png)\n\n里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候只可读，部分情况下可以写入，如果报错则说明无法写入（处于权限和安全考虑这样设置的），需要通过桌面用户来写入文件。\n\nP代指python容器，R代指R语言容器的存储空间。\n\n### 最佳实践\n\n简化后的路径当中红色的路径为推荐的上传数据集的方式：\n\n<img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\" />\n\n代码等数据集合比较小的可以直接上传：\n\n![image-20241021234950722](https://s2.loli.net/2024/10/21/y6vCgVmNFjOHD4T.png)\n\n对于R容器，建议直接使用R_Share或者NCZone,可以考虑如下路径：\n\n![image-20241021235340468](https://s2.loli.net/2024/10/21/naqj2KiNpMvyzoP.png)\n\nMatlab使用路径同其他。","source":"_posts/NAS服务器使用说明.md","raw":"---\ntitle: NAS服务器使用说明\ncategories:\n  - Bionet\ntags:\n  - Bionet\n  - NAS\ndate: \"2024/09/29 20:46:25\"\n---\n\n\n\n# NAS服务器使用说明\n\n<img src=\"https://s2.loli.net/2024/09/29/F4JzXvoRg5kuWin.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547916644\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.0\n\nDate: 2024.04.23\n\nAuthors：Tr，NeoNeuxs\n\n<!-- toc -->\n\n## 基本的网络要求\n\n网络要求需要在校园网中，在校园网外需要使用VPN来进行上传。上传文件的速度取决于你的链接速度，推荐使用网线上传。\n\n为什么我的网速很慢？打开校园网链接信息，网线连接的用户，一般不用考虑这个问题，此处可以跳过。\n\n<img src=\"https://s2.loli.net/2024/04/23/CWBdyLkx72UXKna.png\" alt=\"image-20240423215045985\" style=\"zoom:67%;\" />\n\n查看连接信息：\n\n<img src=\"https://s2.loli.net/2024/04/23/S2b6eO89k7hdFAH.png\" alt=\"image-20240423215142791\" style=\"zoom:80%;\" />\n\n应连接到5HZ频段，2.4Ghz频段速度较低，较慢的情况如下：\n\n<img src=\"https://s2.loli.net/2024/04/23/8G6U7LedFmag9z4.png\" alt=\"image-20240423215305320\" style=\"zoom:67%;\" />\n\n**72Mbps相当于10M左右的网速，如果上传100GB的数据那就需要100*1000/10 = 10000s，也就是2.78个小时才能完成上传。**所以使用的时候请注意。\n\n如何从2.4Ghz切换到5Ghz？首先电脑支持5Ghz频段才能使用，2.4Ghz频段切换方法如下：\n\n![image-20240423215639861](https://s2.loli.net/2024/04/23/j2pdsZQyIFPi7C8.png)\n\n点击**断开连接**后再次点击连接就能查看所连接的信息是否改变，没有改变的情况下，多次尝试即可。\n\n## 目录结构\n\n![image-20240424234753210](https://s2.loli.net/2024/04/24/9Yz6UONRdgisnwT.png)\n\n第一级目录存放了两个文件夹，分别是我个人的用户文件夹，**公用的数据文件夹Dataset**，一般要求如下：\n\n![image-20240424235033899](https://s2.loli.net/2024/04/24/T1PUYLxzKVSsNkl.png)\n\n## 如何建立映射来上传内容\n\n1.打开我的电脑，并在左侧右击“此电脑”，然后点击“映射网络驱动器”。\n\n![image-20240423202540683](https://s2.loli.net/2024/04/23/zVMEx1q9O4QJt2m.png)\n\n2.弹出弹窗，点击“连接到可用于存储文档和图片的网站”。\n\n![image-20240423203018882](https://s2.loli.net/2024/04/23/A1ihgnZuxBNJY97.png)\n\n3.点两次下一步。\n\n![image-20240423203100159](https://s2.loli.net/2024/04/23/QjiskIncw7T9E4G.png)\n\n![image-20240423203212778](https://s2.loli.net/2024/04/23/O1yt4lv8H95XdWn.png)\n\n4.输入Internet地址或网络地址：\n\n```\nftp://10.26.58.111\n```\n\n![image-20240423203455064](https://s2.loli.net/2024/04/23/s981hadbKNUWYJr.png)\n\n5.一定记得**取消匿名登录**！！输入用户名“bionet\"。\n\n![image-20240423203635552](https://s2.loli.net/2024/04/23/NnB3aCoSYVpLDzy.png)\n\n![image-20240423203732896](https://s2.loli.net/2024/04/23/heH3M2NxyAZXmUf.png)\n\n6.给你这个网络位置起一个名字，这里自己起一个方便自己标识的名字就行，这里我起名叫做bionet-tr。\n\n![image-20240423204219721](https://s2.loli.net/2024/04/23/rXPga2uA43iMG8W.png)\n\n7.输入密码之后，密码详见群内信息，完成。\n\n![image-20240423204302462](https://s2.loli.net/2024/04/23/GUFsW2z6jOCyVxH.png)\n\n8.使用。此时“我的电脑”会出现以下网络连接图标，点击图标进入。此时就可以通过拖拽进行数据上传了。\n\n![image-20240423204424138](https://s2.loli.net/2024/04/23/1DqclYEfFA2Jpia.png)\n\n![image-20240423204739094](https://s2.loli.net/2024/04/23/tnK86qs74ToNxZD.png)\n\n## 上传内容没有及时更新该怎么办？\n\n映射之后，我们打开：\n\n![image-20240423214856217](https://s2.loli.net/2024/04/23/THoBR5P9wdnQmK7.png)\n\n点击刷新即可：\n\n![image-20240423214906566](https://s2.loli.net/2024/04/23/3W4yhu2RpxQgZd7.png)\n\n## 一些使用规则\n\n由于FTP权限管理比较薄弱，各位拥有的权限都比较高，所以请将较大的数据集放入Dataset文件夹：\n\n再强调一遍！请将对应的数据放到Dataset文件夹，按照以下命名规则：\n\n`使用者姓名__数据集名__版本`。举个例子：\n\n![image-20240423220546039](https://s2.loli.net/2024/04/23/ySpLnWN9D3VewUu.png)\n\n**需要强调的是，v是小写，`_`是英文下划线，一个即可。**\n\n**创建之后没有及时显示，请刷新即可**。\n\n私人文件请放入上一层，以自己名字命名的文件夹下，请创建自己的文件夹如图所示：\n\n<img src=\"https://s2.loli.net/2024/04/23/x59UIvJ81hN7HmY.png\" alt=\"image-20240423220213345\" style=\"zoom:67%;\" />\n\n**创建之后没有及时显示，请刷新即可**。\n\n## 上传之后如何在服务器上使用\n\n该NAS服务器映射在原来服务器的/home/Data_NAS/路径下。进入该路径即可看到所有上传的数据。\n\n<img src=\"https://s2.loli.net/2024/04/23/ZcW8fD2J1u6gib5.png\" alt=\"image-20240423205229731\" style=\"zoom:80%;\" />\n\n<img src=\"https://s2.loli.net/2024/04/23/BARezykG3fYimQ2.png\" alt=\"image-20240423205433620\" style=\"zoom:80%;\" />\n\n## 最佳实践\n\n### 一些基础知识\n\n下图展示了存储配置的全部架构：\n\n```mermaid\ngraph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n    \n    \n    A--\"Datasets文件夹依赖于\"--->C\n    A--\"运行依赖于\"--->B\n    A--\"运行依赖于\"--->F\n    B--\"Datasets文件夹依赖于\"--->C\n    F--\"Datasets文件夹依赖于\"--->C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"--->B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==>C\n    D--\"连接运行\"--->A\n    E--\"数据\"-->D\n   \n```\n\n在这里再次对主机（服务器主机）上存在的文件解释一下：\n\n主机上的文件存储由这样的硬盘空间组成的,分为高速、中速、低速区。顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：\n\n`Data_NAS(Datasets) > Samsung 860evo 512G  > GLOWAY YCQ4TNVMe-M.2` \n\n其中每一条格式如下：[分区名、挂载路径、分区大小]\n\n```mermaid\ngraph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --> nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --> nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --> nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --> nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --> nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --> nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --> MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --> sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --> sda2[\"sda2,[/boot],1GB\"]\n  sda --> empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --> LowSpeed\n  subgraph LowSpeed\n  NAS --> NFS1(NFS,/home/Data_NAS,16T)\n  NAS --> NFS2(NFS,/home/Datasets,16T)\n  end\n```\n\n这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件\n\n![image-20240513230049068](https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png)\n\n一共包含五个文件夹：\n\n- Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：`上传者_数据集名称_上传日期`。\n  - 此文件夹使用详见：[NAS服务器使用说明](http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/)\n- Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。\n- PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】\n- NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改），其不被多个服务器所共享，**只保存在No1或者No2服务器上**。\n- Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。\n\n- SoftWares文件夹比较特殊：\n\n![image-20240401205431946](https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png)\n\n里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候只可读，部分情况下可以写入，如果报错则说明无法写入（处于权限和安全考虑这样设置的），需要通过桌面用户来写入文件。\n\nP代指python容器，R代指R语言容器的存储空间。\n\n### 最佳实践\n\n简化后的路径当中红色的路径为推荐的上传数据集的方式：\n\n<img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\" />\n\n代码等数据集合比较小的可以直接上传：\n\n![image-20241021234950722](https://s2.loli.net/2024/10/21/y6vCgVmNFjOHD4T.png)\n\n对于R容器，建议直接使用R_Share或者NCZone,可以考虑如下路径：\n\n![image-20241021235340468](https://s2.loli.net/2024/10/21/naqj2KiNpMvyzoP.png)\n\nMatlab使用路径同其他。","slug":"NAS服务器使用说明","published":1,"updated":"2024-11-27T03:55:57.801Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti09002lyjin807ph2uw","content":"<h1><span id=\"nas服务器使用说明\">NAS服务器使用说明</span></h1>\n<img src=\"https://s2.loli.net/2024/09/29/F4JzXvoRg5kuWin.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547916644\" style=\"zoom:50%;\">\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\">\n<p>Version:1.0</p>\n<p>Date: 2024.04.23</p>\n<p>Authors：Tr，NeoNeuxs</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A6%81%E6%B1%82\">基本的网络要求</a></li>\n<li><a href=\"#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">目录结构</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E6%9D%A5%E4%B8%8A%E4%BC%A0%E5%86%85%E5%AE%B9\">如何建立映射来上传内容</a></li>\n<li><a href=\"#%E4%B8%8A%E4%BC%A0%E5%86%85%E5%AE%B9%E6%B2%A1%E6%9C%89%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E\">上传内容没有及时更新该怎么办？</a></li>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99\">一些使用规则</a></li>\n<li><a href=\"#%E4%B8%8A%E4%BC%A0%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8\">上传之后如何在服务器上使用</a></li>\n<li><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">最佳实践</a>\n<ul>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\">一些基础知识</a></li>\n<li><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1\">最佳实践</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2><span id=\"基本的网络要求\">基本的网络要求</span></h2>\n<p>网络要求需要在校园网中，在校园网外需要使用VPN来进行上传。上传文件的速度取决于你的链接速度，推荐使用网线上传。</p>\n<p>为什么我的网速很慢？打开校园网链接信息，网线连接的用户，一般不用考虑这个问题，此处可以跳过。</p>\n<img src=\"https://s2.loli.net/2024/04/23/CWBdyLkx72UXKna.png\" alt=\"image-20240423215045985\" style=\"zoom:67%;\">\n<p>查看连接信息：</p>\n<img src=\"https://s2.loli.net/2024/04/23/S2b6eO89k7hdFAH.png\" alt=\"image-20240423215142791\" style=\"zoom:80%;\">\n<p>应连接到5HZ频段，2.4Ghz频段速度较低，较慢的情况如下：</p>\n<img src=\"https://s2.loli.net/2024/04/23/8G6U7LedFmag9z4.png\" alt=\"image-20240423215305320\" style=\"zoom:67%;\">\n<p>**72Mbps相当于10M左右的网速，如果上传100GB的数据那就需要100*1000/10 = 10000s，也就是2.78个小时才能完成上传。**所以使用的时候请注意。</p>\n<p>如何从2.4Ghz切换到5Ghz？首先电脑支持5Ghz频段才能使用，2.4Ghz频段切换方法如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/j2pdsZQyIFPi7C8.png\" alt=\"image-20240423215639861\"></p>\n<p>点击<strong>断开连接</strong>后再次点击连接就能查看所连接的信息是否改变，没有改变的情况下，多次尝试即可。</p>\n<h2><span id=\"目录结构\">目录结构</span></h2>\n<p><img src=\"https://s2.loli.net/2024/04/24/9Yz6UONRdgisnwT.png\" alt=\"image-20240424234753210\"></p>\n<p>第一级目录存放了两个文件夹，分别是我个人的用户文件夹，<strong>公用的数据文件夹Dataset</strong>，一般要求如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/24/T1PUYLxzKVSsNkl.png\" alt=\"image-20240424235033899\"></p>\n<h2><span id=\"如何建立映射来上传内容\">如何建立映射来上传内容</span></h2>\n<p>1.打开我的电脑，并在左侧右击“此电脑”，然后点击“映射网络驱动器”。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/zVMEx1q9O4QJt2m.png\" alt=\"image-20240423202540683\"></p>\n<p>2.弹出弹窗，点击“连接到可用于存储文档和图片的网站”。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/A1ihgnZuxBNJY97.png\" alt=\"image-20240423203018882\"></p>\n<p>3.点两次下一步。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/QjiskIncw7T9E4G.png\" alt=\"image-20240423203100159\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/23/O1yt4lv8H95XdWn.png\" alt=\"image-20240423203212778\"></p>\n<p>4.输入Internet地址或网络地址：</p>\n<pre><code>ftp://10.26.58.111\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/23/s981hadbKNUWYJr.png\" alt=\"image-20240423203455064\"></p>\n<p>5.一定记得<strong>取消匿名登录</strong>！！输入用户名“bionet\"。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/NnB3aCoSYVpLDzy.png\" alt=\"image-20240423203635552\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/23/heH3M2NxyAZXmUf.png\" alt=\"image-20240423203732896\"></p>\n<p>6.给你这个网络位置起一个名字，这里自己起一个方便自己标识的名字就行，这里我起名叫做bionet-tr。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/rXPga2uA43iMG8W.png\" alt=\"image-20240423204219721\"></p>\n<p>7.输入密码之后，密码详见群内信息，完成。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/GUFsW2z6jOCyVxH.png\" alt=\"image-20240423204302462\"></p>\n<p>8.使用。此时“我的电脑”会出现以下网络连接图标，点击图标进入。此时就可以通过拖拽进行数据上传了。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/1DqclYEfFA2Jpia.png\" alt=\"image-20240423204424138\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/23/tnK86qs74ToNxZD.png\" alt=\"image-20240423204739094\"></p>\n<h2><span id=\"上传内容没有及时更新该怎么办\">上传内容没有及时更新该怎么办？</span></h2>\n<p>映射之后，我们打开：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/THoBR5P9wdnQmK7.png\" alt=\"image-20240423214856217\"></p>\n<p>点击刷新即可：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/3W4yhu2RpxQgZd7.png\" alt=\"image-20240423214906566\"></p>\n<h2><span id=\"一些使用规则\">一些使用规则</span></h2>\n<p>由于FTP权限管理比较薄弱，各位拥有的权限都比较高，所以请将较大的数据集放入Dataset文件夹：</p>\n<p>再强调一遍！请将对应的数据放到Dataset文件夹，按照以下命名规则：</p>\n<p><code>使用者姓名__数据集名__版本</code>。举个例子：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/ySpLnWN9D3VewUu.png\" alt=\"image-20240423220546039\"></p>\n<p><strong>需要强调的是，v是小写，<code>_</code>是英文下划线，一个即可。</strong></p>\n<p><strong>创建之后没有及时显示，请刷新即可</strong>。</p>\n<p>私人文件请放入上一层，以自己名字命名的文件夹下，请创建自己的文件夹如图所示：</p>\n<img src=\"https://s2.loli.net/2024/04/23/x59UIvJ81hN7HmY.png\" alt=\"image-20240423220213345\" style=\"zoom:67%;\">\n<p><strong>创建之后没有及时显示，请刷新即可</strong>。</p>\n<h2><span id=\"上传之后如何在服务器上使用\">上传之后如何在服务器上使用</span></h2>\n<p>该NAS服务器映射在原来服务器的/home/Data_NAS/路径下。进入该路径即可看到所有上传的数据。</p>\n<img src=\"https://s2.loli.net/2024/04/23/ZcW8fD2J1u6gib5.png\" alt=\"image-20240423205229731\" style=\"zoom:80%;\">\n<img src=\"https://s2.loli.net/2024/04/23/BARezykG3fYimQ2.png\" alt=\"image-20240423205433620\" style=\"zoom:80%;\">\n<h2><span id=\"最佳实践\">最佳实践</span></h2>\n<h3><span id=\"一些基础知识\">一些基础知识</span></h3>\n<p>下图展示了存储配置的全部架构：</p>\n<pre class=\"mermaid\">graph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n    \n    \n    A--\"Datasets文件夹依赖于\"---&gt;C\n    A--\"运行依赖于\"---&gt;B\n    A--\"运行依赖于\"---&gt;F\n    B--\"Datasets文件夹依赖于\"---&gt;C\n    F--\"Datasets文件夹依赖于\"---&gt;C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"---&gt;B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==&gt;C\n    D--\"连接运行\"---&gt;A\n    E--\"数据\"--&gt;D</pre>\n<p>在这里再次对主机（服务器主机）上存在的文件解释一下：</p>\n<p>主机上的文件存储由这样的硬盘空间组成的,分为高速、中速、低速区。顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：</p>\n<p><code>Data_NAS(Datasets) &gt; Samsung 860evo 512G  &gt; GLOWAY YCQ4TNVMe-M.2</code></p>\n<p>其中每一条格式如下：[分区名、挂载路径、分区大小]</p>\n<pre class=\"mermaid\">graph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --&gt; nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --&gt; nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --&gt; nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --&gt; nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --&gt; nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --&gt; nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --&gt; MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --&gt; sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --&gt; sda2[\"sda2,[/boot],1GB\"]\n  sda --&gt; empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --&gt; LowSpeed\n  subgraph LowSpeed\n  NAS --&gt; NFS1(NFS,/home/Data_NAS,16T)\n  NAS --&gt; NFS2(NFS,/home/Datasets,16T)\n  end</pre>\n<p>这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png\" alt=\"image-20240513230049068\"></p>\n<p>一共包含五个文件夹：</p>\n<ul>\n<li>\n<p>Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：<code>上传者_数据集名称_上传日期</code>。</p>\n<ul>\n<li>此文件夹使用详见：<a href=\"http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/\">NAS服务器使用说明</a></li>\n</ul>\n</li>\n<li>\n<p>Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。</p>\n</li>\n<li>\n<p>PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】</p>\n</li>\n<li>\n<p>NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改），其不被多个服务器所共享，<strong>只保存在No1或者No2服务器上</strong>。</p>\n</li>\n<li>\n<p>Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。</p>\n</li>\n<li>\n<p>SoftWares文件夹比较特殊：</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png\" alt=\"image-20240401205431946\"></p>\n<p>里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候只可读，部分情况下可以写入，如果报错则说明无法写入（处于权限和安全考虑这样设置的），需要通过桌面用户来写入文件。</p>\n<p>P代指python容器，R代指R语言容器的存储空间。</p>\n<h3><span id=\"最佳实践\">最佳实践</span></h3>\n<p>简化后的路径当中红色的路径为推荐的上传数据集的方式：</p>\n<img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\">\n<p>代码等数据集合比较小的可以直接上传：</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/y6vCgVmNFjOHD4T.png\" alt=\"image-20241021234950722\"></p>\n<p>对于R容器，建议直接使用R_Share或者NCZone,可以考虑如下路径：</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/naqj2KiNpMvyzoP.png\" alt=\"image-20241021235340468\"></p>\n<p>Matlab使用路径同其他。</p>\n","excerpt":"","more":"<h1>NAS服务器使用说明</h1>\n<img src=\"https://s2.loli.net/2024/09/29/F4JzXvoRg5kuWin.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547916644\" style=\"zoom:50%;\" />\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n<p>Version:1.0</p>\n<p>Date: 2024.04.23</p>\n<p>Authors：Tr，NeoNeuxs</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E5%9F%BA%E6%9C%AC%E7%9A%84%E7%BD%91%E7%BB%9C%E8%A6%81%E6%B1%82\">基本的网络要求</a></li>\n<li><a href=\"#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84\">目录结构</a></li>\n<li><a href=\"#%E5%A6%82%E4%BD%95%E5%BB%BA%E7%AB%8B%E6%98%A0%E5%B0%84%E6%9D%A5%E4%B8%8A%E4%BC%A0%E5%86%85%E5%AE%B9\">如何建立映射来上传内容</a></li>\n<li><a href=\"#%E4%B8%8A%E4%BC%A0%E5%86%85%E5%AE%B9%E6%B2%A1%E6%9C%89%E5%8F%8A%E6%97%B6%E6%9B%B4%E6%96%B0%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E\">上传内容没有及时更新该怎么办？</a></li>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99\">一些使用规则</a></li>\n<li><a href=\"#%E4%B8%8A%E4%BC%A0%E4%B9%8B%E5%90%8E%E5%A6%82%E4%BD%95%E5%9C%A8%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E4%BD%BF%E7%94%A8\">上传之后如何在服务器上使用</a></li>\n<li><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">最佳实践</a>\n<ul>\n<li><a href=\"#%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86\">一些基础知识</a></li>\n<li><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5-1\">最佳实践</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<h2 id=\"基本的网络要求\">基本的网络要求</h2>\n<p>网络要求需要在校园网中，在校园网外需要使用VPN来进行上传。上传文件的速度取决于你的链接速度，推荐使用网线上传。</p>\n<p>为什么我的网速很慢？打开校园网链接信息，网线连接的用户，一般不用考虑这个问题，此处可以跳过。</p>\n<img src=\"https://s2.loli.net/2024/04/23/CWBdyLkx72UXKna.png\" alt=\"image-20240423215045985\" style=\"zoom:67%;\" />\n<p>查看连接信息：</p>\n<img src=\"https://s2.loli.net/2024/04/23/S2b6eO89k7hdFAH.png\" alt=\"image-20240423215142791\" style=\"zoom:80%;\" />\n<p>应连接到5HZ频段，2.4Ghz频段速度较低，较慢的情况如下：</p>\n<img src=\"https://s2.loli.net/2024/04/23/8G6U7LedFmag9z4.png\" alt=\"image-20240423215305320\" style=\"zoom:67%;\" />\n<p>**72Mbps相当于10M左右的网速，如果上传100GB的数据那就需要100*1000/10 = 10000s，也就是2.78个小时才能完成上传。**所以使用的时候请注意。</p>\n<p>如何从2.4Ghz切换到5Ghz？首先电脑支持5Ghz频段才能使用，2.4Ghz频段切换方法如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/j2pdsZQyIFPi7C8.png\" alt=\"image-20240423215639861\"></p>\n<p>点击<strong>断开连接</strong>后再次点击连接就能查看所连接的信息是否改变，没有改变的情况下，多次尝试即可。</p>\n<h2 id=\"目录结构\">目录结构</h2>\n<p><img src=\"https://s2.loli.net/2024/04/24/9Yz6UONRdgisnwT.png\" alt=\"image-20240424234753210\"></p>\n<p>第一级目录存放了两个文件夹，分别是我个人的用户文件夹，<strong>公用的数据文件夹Dataset</strong>，一般要求如下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/24/T1PUYLxzKVSsNkl.png\" alt=\"image-20240424235033899\"></p>\n<h2 id=\"如何建立映射来上传内容\">如何建立映射来上传内容</h2>\n<p>1.打开我的电脑，并在左侧右击“此电脑”，然后点击“映射网络驱动器”。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/zVMEx1q9O4QJt2m.png\" alt=\"image-20240423202540683\"></p>\n<p>2.弹出弹窗，点击“连接到可用于存储文档和图片的网站”。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/A1ihgnZuxBNJY97.png\" alt=\"image-20240423203018882\"></p>\n<p>3.点两次下一步。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/QjiskIncw7T9E4G.png\" alt=\"image-20240423203100159\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/23/O1yt4lv8H95XdWn.png\" alt=\"image-20240423203212778\"></p>\n<p>4.输入Internet地址或网络地址：</p>\n<pre><code>ftp://10.26.58.111\n</code></pre>\n<p><img src=\"https://s2.loli.net/2024/04/23/s981hadbKNUWYJr.png\" alt=\"image-20240423203455064\"></p>\n<p>5.一定记得<strong>取消匿名登录</strong>！！输入用户名“bionet&quot;。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/NnB3aCoSYVpLDzy.png\" alt=\"image-20240423203635552\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/23/heH3M2NxyAZXmUf.png\" alt=\"image-20240423203732896\"></p>\n<p>6.给你这个网络位置起一个名字，这里自己起一个方便自己标识的名字就行，这里我起名叫做bionet-tr。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/rXPga2uA43iMG8W.png\" alt=\"image-20240423204219721\"></p>\n<p>7.输入密码之后，密码详见群内信息，完成。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/GUFsW2z6jOCyVxH.png\" alt=\"image-20240423204302462\"></p>\n<p>8.使用。此时“我的电脑”会出现以下网络连接图标，点击图标进入。此时就可以通过拖拽进行数据上传了。</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/1DqclYEfFA2Jpia.png\" alt=\"image-20240423204424138\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/23/tnK86qs74ToNxZD.png\" alt=\"image-20240423204739094\"></p>\n<h2 id=\"上传内容没有及时更新该怎么办？\">上传内容没有及时更新该怎么办？</h2>\n<p>映射之后，我们打开：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/THoBR5P9wdnQmK7.png\" alt=\"image-20240423214856217\"></p>\n<p>点击刷新即可：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/3W4yhu2RpxQgZd7.png\" alt=\"image-20240423214906566\"></p>\n<h2 id=\"一些使用规则\">一些使用规则</h2>\n<p>由于FTP权限管理比较薄弱，各位拥有的权限都比较高，所以请将较大的数据集放入Dataset文件夹：</p>\n<p>再强调一遍！请将对应的数据放到Dataset文件夹，按照以下命名规则：</p>\n<p><code>使用者姓名__数据集名__版本</code>。举个例子：</p>\n<p><img src=\"https://s2.loli.net/2024/04/23/ySpLnWN9D3VewUu.png\" alt=\"image-20240423220546039\"></p>\n<p><strong>需要强调的是，v是小写，<code>_</code>是英文下划线，一个即可。</strong></p>\n<p><strong>创建之后没有及时显示，请刷新即可</strong>。</p>\n<p>私人文件请放入上一层，以自己名字命名的文件夹下，请创建自己的文件夹如图所示：</p>\n<img src=\"https://s2.loli.net/2024/04/23/x59UIvJ81hN7HmY.png\" alt=\"image-20240423220213345\" style=\"zoom:67%;\" />\n<p><strong>创建之后没有及时显示，请刷新即可</strong>。</p>\n<h2 id=\"上传之后如何在服务器上使用\">上传之后如何在服务器上使用</h2>\n<p>该NAS服务器映射在原来服务器的/home/Data_NAS/路径下。进入该路径即可看到所有上传的数据。</p>\n<img src=\"https://s2.loli.net/2024/04/23/ZcW8fD2J1u6gib5.png\" alt=\"image-20240423205229731\" style=\"zoom:80%;\" />\n<img src=\"https://s2.loli.net/2024/04/23/BARezykG3fYimQ2.png\" alt=\"image-20240423205433620\" style=\"zoom:80%;\" />\n<h2 id=\"最佳实践\">最佳实践</h2>\n<h3 id=\"一些基础知识\">一些基础知识</h3>\n<p>下图展示了存储配置的全部架构：</p>\n<pre class=\"mermaid\">graph LR;\n    A[\"容器(最高权限)\"] \n    B[\"服务器主机A\"]\n    F[\"服务器主机B(待建设)\"]\n    C[\"NAS(网络附加存储)\"]\n    D[\"你的本地电脑\"]\n    E[\"外部网盘\"]\n    \n    \n    A--\"Datasets文件夹依赖于\"--->C\n    A--\"运行依赖于\"--->B\n    A--\"运行依赖于\"--->F\n    B--\"Datasets文件夹依赖于\"--->C\n    F--\"Datasets文件夹依赖于\"--->C\n    A--\"NCZone、R_Share、P_Share文件夹直接存在于\"--->B\n    D ==\"Bionet(Datasets)文件夹依赖于\"==>C\n    D--\"连接运行\"--->A\n    E--\"数据\"-->D</pre>\n<p>在这里再次对主机（服务器主机）上存在的文件解释一下：</p>\n<p>主机上的文件存储由这样的硬盘空间组成的,分为高速、中速、低速区。顾名思义，每个区域速度不同，速度不同的同时稳定性也存在一定的差异，稳定性和速度正好相反：</p>\n<p><code>Data_NAS(Datasets) &gt; Samsung 860evo 512G  &gt; GLOWAY YCQ4TNVMe-M.2</code></p>\n<p>其中每一条格式如下：[分区名、挂载路径、分区大小]</p>\n<pre class=\"mermaid\">graph TB;\n  subgraph HighSpeed\n  nvme0n1(\"nvme0n1:GLOWAY YCQ4TNVMe-M.2\")\n  nvme0n1 --> nvme0n1p1(\"nvme0n1p1,[/home],2.5T\")\n  nvme0n1 --> nvme0n1p2(\"nvme0n1p2,[/],1T\")\n  nvme0n1 --> nvme0n1p3(\"nvme0n1p3,[swap],256G\")\n  nvme0n1 --> nvme0n1p4(\"nvme0n1p4,[/var],128G\")\n  nvme0n1 --> nvme0n1p5(\"nvme0n1p5,[/opt],128G\")\n  nvme0n1 --> nvme0n1p6(\"nvme0n1p6,[/tmp],50G\")\n  end\n  HighSpeed --> MiddleSpeed\n  subgraph MiddleSpeed\n  sda(\"sda:Samsung 860evo 512G\")\n  sda --> sda1[\"sda1,[/boot/efi],500MB\"]\n  sda --> sda2[\"sda2,[/boot],1GB\"]\n  sda --> empty[\"docker lvm[/var/lib/docker] 400G\"]\n  end\n  MiddleSpeed --> LowSpeed\n  subgraph LowSpeed\n  NAS --> NFS1(NFS,/home/Data_NAS,16T)\n  NAS --> NFS2(NFS,/home/Datasets,16T)\n  end</pre>\n<p>这其中包含了共享文件夹和用户文件夹，如图共享文件夹使用红框标注，用来传递文件</p>\n<p><img src=\"https://s2.loli.net/2024/05/13/hMrBjZOIpcC5Fgv.png\" alt=\"image-20240513230049068\"></p>\n<p>一共包含五个文件夹：</p>\n<ul>\n<li>\n<p>Datasets文件夹是用来放置公用数据集的，其命名需要遵循以下方式：<code>上传者_数据集名称_上传日期</code>。</p>\n<ul>\n<li>此文件夹使用详见：<a href=\"http://10.26.58.109/2024/09/29/NAS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/\">NAS服务器使用说明</a></li>\n</ul>\n</li>\n<li>\n<p>Data_NAS是直接连接到NAS的文件夹，其目录内容与Datasets保持一致，但是二者物理通道不同（挂载在不同的IP），使用起来是一模一样的。</p>\n</li>\n<li>\n<p>PastData文件夹是过去硬盘中的所有数据，在三个月后将会自动删除，各位及时使用。【现在已经删除】</p>\n</li>\n<li>\n<p>NCZone文件夹是没有做任何保护的文件夹，用户随时可写可删除，使用的时候需要小心删除，并避免写冲突问题（多人对同一个文件修改），其不被多个服务器所共享，<strong>只保存在No1或者No2服务器上</strong>。</p>\n</li>\n<li>\n<p>Some_scripts文件夹使用分享一个shell脚本的，用来管理系统方便的，使用需要管理员权限。</p>\n</li>\n<li>\n<p>SoftWares文件夹比较特殊：</p>\n</li>\n</ul>\n<p><img src=\"https://s2.loli.net/2024/04/01/dXxH8ARVvPUEf6r.png\" alt=\"image-20240401205431946\"></p>\n<p>里面包含了P_Share和R_Share,分别挂载到了对应的容器用来分享文件，容器使用的时候只可读，部分情况下可以写入，如果报错则说明无法写入（处于权限和安全考虑这样设置的），需要通过桌面用户来写入文件。</p>\n<p>P代指python容器，R代指R语言容器的存储空间。</p>\n<h3 id=\"最佳实践-2\">最佳实践</h3>\n<p>简化后的路径当中红色的路径为推荐的上传数据集的方式：</p>\n<img src=\"https://s2.loli.net/2024/10/21/mZun6qNW3tvPTKB.png\" alt=\"image-20241021232145477\" style=\"zoom:80%;\" />\n<p>代码等数据集合比较小的可以直接上传：</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/y6vCgVmNFjOHD4T.png\" alt=\"image-20241021234950722\"></p>\n<p>对于R容器，建议直接使用R_Share或者NCZone,可以考虑如下路径：</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/naqj2KiNpMvyzoP.png\" alt=\"image-20241021235340468\"></p>\n<p>Matlab使用路径同其他。</p>\n"},{"title":"PyCharm使用技巧（1）——编辑基础部分","excerpt":"Pycharm编辑基础部分","date":"2023-10-20T16:00:00.000Z","_content":"# PyCharm使用技巧（1）——编辑基础部分\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n<img src=\"https://s2.loli.net/2023/10/23/UvSq4AxVNdbzeWC.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1698049838504\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\" />\n\n\n\n## 编辑基础\n\n### Context action (上下文联想动作)  KeyMap：ALT + ENTER\n\n你可以在几乎任何上下文中调用**Context action**。比如在下面代码中：\n\n```python\ndef method_with_unused_parameter(used, redundant):\n    print(\"It is used parameter: \" + str(used))\n\n\ndef intention_example(a, b):\n    if not (a and b):\n        return 1\n    return 2\n\n\nmethod_with_unused_parameter(\"first\", \"second\")\nmethod_with_unused_parameter(\"used\", \"unused\")\nintention_example(True, False)\n```\n\n针对上边的代码按下`ALT` + `ENTER`此时PyCharm会根据上下文环境来推测你想要的行动，<img src=\"https://s2.loli.net/2023/10/22/Wm1EDKLAzbFH4i2.png\" alt=\"image-20231022221515732\" style=\"zoom:150%;\" />\n\n这里就推测出第二个参数没有什么用会自动帮你移除第二个参数.\n\n可以看到整个代码部分对应的无用参数都被移除了：\n\n![image-20231022221913479](https://s2.loli.net/2023/10/22/tEnWoFUckKyagmA.png)\n\n同时Context action也能提供逻辑优化等操作：\n\n还是上边的代码，我们注重这一行：\n\n![image-20231022222939162](https://s2.loli.net/2023/10/22/cQ3byIvaHGo8fkB.png)\n\n我们在and这里使用快捷键`ALT` + `ENTER`：根据德摩根法则其可以优化成：\n\n![image-20231022222733594](https://s2.loli.net/2023/10/22/93obW4BqQEcOtRe.png)\n\n### Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W\n\n有如下代码：\n\n```python\ndef some_method(first, second, third):\n    print(first, second, third)\n\n\ndef example_method(condition):\n    if condition:\n        print(\"Begin of the work\")\n        some_method(\"first string\", \"This is a long string that you can select for refactoring\", \"third string\")\n        print(\"End of the work\")\n    print(\"The end\")\n\n```\n\n你想选择`that`单词，常规做法是双击，在这里你可以使用`CTRL + W`来实现操作：\n\n![image-20231022223705647](https://s2.loli.net/2023/10/22/68gRUyi2tFfehSV.png)\n\n效果如下：\n\n![image-20231022223859938](https://s2.loli.net/2023/10/23/K5Np9UElIOzZwYP.png)\n\n此时你需要选择整个字符串，无需动鼠标，`CTRL+W`即可实现对应操作：\n\n![image-20231022224043310](https://s2.loli.net/2023/10/22/oVF3ZNhwjx7QDMn.png)\n\n当然你连续按下三次`CTRL+W`，你就可选择整个引用内容，包含引号：\n\n![image-20231022231031499](https://s2.loli.net/2023/10/22/CEWYKtswjuA6Pcb.png)\n\n当然你连续按下四次`CTRL+W`，你就可选择整个调用内容：\n\n![image-20231022231548555](https://s2.loli.net/2023/10/22/KyXmx9pB3IZhACa.png)\n\n当然有时候会有不小心按错，使用快捷键`CTRL+Shift+W`就可以回退：\n\n![image-20231022232010023](https://s2.loli.net/2023/10/22/qO2Cj7UDyYV1cNv.png)\n\n在if后边，两次CTRL+W就可以选择整个if表达，十分快捷：\n\n![image-20231022232157648](https://s2.loli.net/2023/10/22/n81dtaj2uXmOQlW.png)\n\n### Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D\n\n当你想快速复制某一行代码的时候，如下所示：\n\n![image-20231022233258128](https://s2.loli.net/2023/10/22/hxuCcEXa7es9k5Z.png)\n\n将光标放在此处按下 CTRL+D，快速复制此行：\n\n![image-20231022233542868](https://s2.loli.net/2023/10/22/1lzJn3ySCUhR9NL.png)\n\n当你需要复制多行的时候：\n\n![image-20231022233522113](https://s2.loli.net/2023/10/22/fUzrZhDaXqdQVYW.png)\n\n完成复制：![image-20231022233701314](https://s2.loli.net/2023/10/22/i2AxcjtTroqQm61.png)\n\n快速删除行的时候使用`CTRL+Y`快捷键实现行删除。\n\n### Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆\n\n重新排序代码往往需要两个过程，剪切和粘贴，而通过Pycharm可以快速实现代码的重排序：\n\n如下代码片段，我们想将输出放到代码更新后：\n\n![2](https://s2.loli.net/2023/10/23/mxWQFl7pPgheBYA.gif)\n\n到这里你也许会感觉有点鸡肋，但是如果他能整个方法，整个结构一起移动呢？\n\n我们将光标放到方法名称前，然后按下快捷键`CTRL + Shift +  ⬆`，实现整个方法的迁移：\n\n![1](https://s2.loli.net/2023/10/23/LiNvx31OsGTWReQ.gif)\n\n### Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete\n\n通常对结构化的代码如`if`等，需要在外围添加`while`或者`trycatch`通常需要进行多步操作，通过环绕代码模板可以快速进行填充，同时也可以使用结构性抹除进行删减，如下面代码：\n\n![3](https://s2.loli.net/2023/10/23/GBq8xD9aFpMhiOW.gif)\n\n### Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J\n\n通常我们在使用Pycharm的时候也会有需求去处理HTML等非常标签化的语言，修改的时候需要前后标签一起修改，鼠标移动的话非正常不方便，Pycharm提供了较为方便的操作多重选择，多重选择后直接进入了编辑模式可以对多个对象同时编辑，见如下代码：\n\n![4](https://s2.loli.net/2023/10/23/MOfGU7n2ovBZayc.gif)\n\n","source":"_posts/PyCharm使用技巧（1）——编辑基础部分.md","raw":"---\ntitle: PyCharm使用技巧（1）——编辑基础部分\ncategories:\n  - Pycharm\ntags:\n  - Pycharm\nexcerpt: \"Pycharm编辑基础部分\"\ndate: 2023/10/21 00:00:00\n---\n# PyCharm使用技巧（1）——编辑基础部分\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n<img src=\"https://s2.loli.net/2023/10/23/UvSq4AxVNdbzeWC.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1698049838504\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\" />\n\n\n\n## 编辑基础\n\n### Context action (上下文联想动作)  KeyMap：ALT + ENTER\n\n你可以在几乎任何上下文中调用**Context action**。比如在下面代码中：\n\n```python\ndef method_with_unused_parameter(used, redundant):\n    print(\"It is used parameter: \" + str(used))\n\n\ndef intention_example(a, b):\n    if not (a and b):\n        return 1\n    return 2\n\n\nmethod_with_unused_parameter(\"first\", \"second\")\nmethod_with_unused_parameter(\"used\", \"unused\")\nintention_example(True, False)\n```\n\n针对上边的代码按下`ALT` + `ENTER`此时PyCharm会根据上下文环境来推测你想要的行动，<img src=\"https://s2.loli.net/2023/10/22/Wm1EDKLAzbFH4i2.png\" alt=\"image-20231022221515732\" style=\"zoom:150%;\" />\n\n这里就推测出第二个参数没有什么用会自动帮你移除第二个参数.\n\n可以看到整个代码部分对应的无用参数都被移除了：\n\n![image-20231022221913479](https://s2.loli.net/2023/10/22/tEnWoFUckKyagmA.png)\n\n同时Context action也能提供逻辑优化等操作：\n\n还是上边的代码，我们注重这一行：\n\n![image-20231022222939162](https://s2.loli.net/2023/10/22/cQ3byIvaHGo8fkB.png)\n\n我们在and这里使用快捷键`ALT` + `ENTER`：根据德摩根法则其可以优化成：\n\n![image-20231022222733594](https://s2.loli.net/2023/10/22/93obW4BqQEcOtRe.png)\n\n### Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W\n\n有如下代码：\n\n```python\ndef some_method(first, second, third):\n    print(first, second, third)\n\n\ndef example_method(condition):\n    if condition:\n        print(\"Begin of the work\")\n        some_method(\"first string\", \"This is a long string that you can select for refactoring\", \"third string\")\n        print(\"End of the work\")\n    print(\"The end\")\n\n```\n\n你想选择`that`单词，常规做法是双击，在这里你可以使用`CTRL + W`来实现操作：\n\n![image-20231022223705647](https://s2.loli.net/2023/10/22/68gRUyi2tFfehSV.png)\n\n效果如下：\n\n![image-20231022223859938](https://s2.loli.net/2023/10/23/K5Np9UElIOzZwYP.png)\n\n此时你需要选择整个字符串，无需动鼠标，`CTRL+W`即可实现对应操作：\n\n![image-20231022224043310](https://s2.loli.net/2023/10/22/oVF3ZNhwjx7QDMn.png)\n\n当然你连续按下三次`CTRL+W`，你就可选择整个引用内容，包含引号：\n\n![image-20231022231031499](https://s2.loli.net/2023/10/22/CEWYKtswjuA6Pcb.png)\n\n当然你连续按下四次`CTRL+W`，你就可选择整个调用内容：\n\n![image-20231022231548555](https://s2.loli.net/2023/10/22/KyXmx9pB3IZhACa.png)\n\n当然有时候会有不小心按错，使用快捷键`CTRL+Shift+W`就可以回退：\n\n![image-20231022232010023](https://s2.loli.net/2023/10/22/qO2Cj7UDyYV1cNv.png)\n\n在if后边，两次CTRL+W就可以选择整个if表达，十分快捷：\n\n![image-20231022232157648](https://s2.loli.net/2023/10/22/n81dtaj2uXmOQlW.png)\n\n### Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D\n\n当你想快速复制某一行代码的时候，如下所示：\n\n![image-20231022233258128](https://s2.loli.net/2023/10/22/hxuCcEXa7es9k5Z.png)\n\n将光标放在此处按下 CTRL+D，快速复制此行：\n\n![image-20231022233542868](https://s2.loli.net/2023/10/22/1lzJn3ySCUhR9NL.png)\n\n当你需要复制多行的时候：\n\n![image-20231022233522113](https://s2.loli.net/2023/10/22/fUzrZhDaXqdQVYW.png)\n\n完成复制：![image-20231022233701314](https://s2.loli.net/2023/10/22/i2AxcjtTroqQm61.png)\n\n快速删除行的时候使用`CTRL+Y`快捷键实现行删除。\n\n### Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆\n\n重新排序代码往往需要两个过程，剪切和粘贴，而通过Pycharm可以快速实现代码的重排序：\n\n如下代码片段，我们想将输出放到代码更新后：\n\n![2](https://s2.loli.net/2023/10/23/mxWQFl7pPgheBYA.gif)\n\n到这里你也许会感觉有点鸡肋，但是如果他能整个方法，整个结构一起移动呢？\n\n我们将光标放到方法名称前，然后按下快捷键`CTRL + Shift +  ⬆`，实现整个方法的迁移：\n\n![1](https://s2.loli.net/2023/10/23/LiNvx31OsGTWReQ.gif)\n\n### Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete\n\n通常对结构化的代码如`if`等，需要在外围添加`while`或者`trycatch`通常需要进行多步操作，通过环绕代码模板可以快速进行填充，同时也可以使用结构性抹除进行删减，如下面代码：\n\n![3](https://s2.loli.net/2023/10/23/GBq8xD9aFpMhiOW.gif)\n\n### Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J\n\n通常我们在使用Pycharm的时候也会有需求去处理HTML等非常标签化的语言，修改的时候需要前后标签一起修改，鼠标移动的话非正常不方便，Pycharm提供了较为方便的操作多重选择，多重选择后直接进入了编辑模式可以对多个对象同时编辑，见如下代码：\n\n![4](https://s2.loli.net/2023/10/23/MOfGU7n2ovBZayc.gif)\n\n","slug":"PyCharm使用技巧（1）——编辑基础部分","published":1,"updated":"2024-11-06T04:51:29.572Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti09002pyjinefos3ade","content":"<h1><span id=\"pycharm使用技巧1编辑基础部分\">PyCharm使用技巧（1）——编辑基础部分</span></h1>\n<h2><span id=\"提示图床在国外且动图比较多的情况下需要时间加载\">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2>\n<h2><span id=\"目录\">目录：</span></h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E7%BC%96%E8%BE%91%E5%9F%BA%E7%A1%80\">编辑基础</a>\n<ul>\n<li><a href=\"#context-action-%E4%B8%8A%E4%B8%8B%E6%96%87%E8%81%94%E6%83%B3%E5%8A%A8%E4%BD%9C-keymapalt-enter\">Context action (上下文联想动作)  KeyMap：ALT + ENTER</a></li>\n<li><a href=\"#expand-and-shrink-the-code-selection%E6%89%A9%E5%B1%95%E5%92%8C%E7%BC%A9%E5%B0%8F%E4%BB%A3%E7%A0%81%E9%80%89%E6%8B%A9-keymapctrl-w\">Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W</a></li>\n<li><a href=\"#duplicate-and-delete-lines%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%A0%E9%99%A4%E8%A1%8Ckeymapctrl-d\">Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D</a></li>\n<li><a href=\"#move-code-fragments%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8-keymapalt-ctrl-shift\">Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆</a></li>\n<li><a href=\"#surround-and-unwrap-%E7%8E%AF%E7%BB%95%E6%A8%A1%E6%9D%BF%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E6%80%A7%E5%88%A0%E9%99%A4keymapalt-t-ctrl-shift-delete\">Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete</a></li>\n<li><a href=\"#multiple-selection-%E5%A4%9A%E9%87%8D%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9keymap-alt-j-ctrl-alt-shift-j\">Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<img src=\"https://s2.loli.net/2023/10/23/UvSq4AxVNdbzeWC.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1698049838504\" style=\"zoom:67%;\">\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\">\n<h2><span id=\"编辑基础\">编辑基础</span></h2>\n<h3><span id=\"context-action-上下文联想动作-keymapalt-enter\">Context action (上下文联想动作)  KeyMap：ALT + ENTER</span></h3>\n<p>你可以在几乎任何上下文中调用<strong>Context action</strong>。比如在下面代码中：</p>\n<pre><code class=\"language-python\">def method_with_unused_parameter(used, redundant):\n    print(\"It is used parameter: \" + str(used))\n\n\ndef intention_example(a, b):\n    if not (a and b):\n        return 1\n    return 2\n\n\nmethod_with_unused_parameter(\"first\", \"second\")\nmethod_with_unused_parameter(\"used\", \"unused\")\nintention_example(True, False)\n</code></pre>\n<p>针对上边的代码按下<code>ALT</code> + <code>ENTER</code>此时PyCharm会根据上下文环境来推测你想要的行动，<img src=\"https://s2.loli.net/2023/10/22/Wm1EDKLAzbFH4i2.png\" alt=\"image-20231022221515732\" style=\"zoom:150%;\"></p>\n<p>这里就推测出第二个参数没有什么用会自动帮你移除第二个参数.</p>\n<p>可以看到整个代码部分对应的无用参数都被移除了：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/tEnWoFUckKyagmA.png\" alt=\"image-20231022221913479\"></p>\n<p>同时Context action也能提供逻辑优化等操作：</p>\n<p>还是上边的代码，我们注重这一行：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/cQ3byIvaHGo8fkB.png\" alt=\"image-20231022222939162\"></p>\n<p>我们在and这里使用快捷键<code>ALT</code> + <code>ENTER</code>：根据德摩根法则其可以优化成：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/93obW4BqQEcOtRe.png\" alt=\"image-20231022222733594\"></p>\n<h3><span id=\"expand-and-shrink-the-code-selection扩展和缩小代码选择-keymapctrl-w\">Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W</span></h3>\n<p>有如下代码：</p>\n<pre><code class=\"language-python\">def some_method(first, second, third):\n    print(first, second, third)\n\n\ndef example_method(condition):\n    if condition:\n        print(\"Begin of the work\")\n        some_method(\"first string\", \"This is a long string that you can select for refactoring\", \"third string\")\n        print(\"End of the work\")\n    print(\"The end\")\n\n</code></pre>\n<p>你想选择<code>that</code>单词，常规做法是双击，在这里你可以使用<code>CTRL + W</code>来实现操作：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/68gRUyi2tFfehSV.png\" alt=\"image-20231022223705647\"></p>\n<p>效果如下：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/K5Np9UElIOzZwYP.png\" alt=\"image-20231022223859938\"></p>\n<p>此时你需要选择整个字符串，无需动鼠标，<code>CTRL+W</code>即可实现对应操作：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/oVF3ZNhwjx7QDMn.png\" alt=\"image-20231022224043310\"></p>\n<p>当然你连续按下三次<code>CTRL+W</code>，你就可选择整个引用内容，包含引号：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/CEWYKtswjuA6Pcb.png\" alt=\"image-20231022231031499\"></p>\n<p>当然你连续按下四次<code>CTRL+W</code>，你就可选择整个调用内容：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/KyXmx9pB3IZhACa.png\" alt=\"image-20231022231548555\"></p>\n<p>当然有时候会有不小心按错，使用快捷键<code>CTRL+Shift+W</code>就可以回退：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/qO2Cj7UDyYV1cNv.png\" alt=\"image-20231022232010023\"></p>\n<p>在if后边，两次CTRL+W就可以选择整个if表达，十分快捷：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/n81dtaj2uXmOQlW.png\" alt=\"image-20231022232157648\"></p>\n<h3><span id=\"duplicate-and-delete-lines快速复制和删除行keymapctrl-d\">Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D</span></h3>\n<p>当你想快速复制某一行代码的时候，如下所示：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/hxuCcEXa7es9k5Z.png\" alt=\"image-20231022233258128\"></p>\n<p>将光标放在此处按下 CTRL+D，快速复制此行：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/1lzJn3ySCUhR9NL.png\" alt=\"image-20231022233542868\"></p>\n<p>当你需要复制多行的时候：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/fUzrZhDaXqdQVYW.png\" alt=\"image-20231022233522113\"></p>\n<p>完成复制：<img src=\"https://s2.loli.net/2023/10/22/i2AxcjtTroqQm61.png\" alt=\"image-20231022233701314\"></p>\n<p>快速删除行的时候使用<code>CTRL+Y</code>快捷键实现行删除。</p>\n<h3><span id=\"move-code-fragments代码片段快速移动-keymapalt-ctrl-shift\">Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆</span></h3>\n<p>重新排序代码往往需要两个过程，剪切和粘贴，而通过Pycharm可以快速实现代码的重排序：</p>\n<p>如下代码片段，我们想将输出放到代码更新后：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/mxWQFl7pPgheBYA.gif\" alt=\"2\"></p>\n<p>到这里你也许会感觉有点鸡肋，但是如果他能整个方法，整个结构一起移动呢？</p>\n<p>我们将光标放到方法名称前，然后按下快捷键<code>CTRL + Shift +  ⬆</code>，实现整个方法的迁移：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/LiNvx31OsGTWReQ.gif\" alt=\"1\"></p>\n<h3><span id=\"surround-and-unwrap-环绕模板与代码结构性删除keymapalt-t-ctrl-shift-delete\">Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete</span></h3>\n<p>通常对结构化的代码如<code>if</code>等，需要在外围添加<code>while</code>或者<code>trycatch</code>通常需要进行多步操作，通过环绕代码模板可以快速进行填充，同时也可以使用结构性抹除进行删减，如下面代码：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/GBq8xD9aFpMhiOW.gif\" alt=\"3\"></p>\n<h3><span id=\"multiple-selection-多重快速选择keymap-alt-j-ctrl-alt-shift-j\">Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J</span></h3>\n<p>通常我们在使用Pycharm的时候也会有需求去处理HTML等非常标签化的语言，修改的时候需要前后标签一起修改，鼠标移动的话非正常不方便，Pycharm提供了较为方便的操作多重选择，多重选择后直接进入了编辑模式可以对多个对象同时编辑，见如下代码：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/MOfGU7n2ovBZayc.gif\" alt=\"4\"></p>\n","more":"<h1>PyCharm使用技巧（1）——编辑基础部分</h1>\n<h2 id=\"提示：图床在国外且动图比较多的情况下，需要时间加载。\">提示：图床在国外且动图比较多的情况下，需要时间加载。</h2>\n<h2 id=\"目录：\">目录：</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E7%BC%96%E8%BE%91%E5%9F%BA%E7%A1%80\">编辑基础</a>\n<ul>\n<li><a href=\"#context-action-%E4%B8%8A%E4%B8%8B%E6%96%87%E8%81%94%E6%83%B3%E5%8A%A8%E4%BD%9C-keymapalt-enter\">Context action (上下文联想动作)  KeyMap：ALT + ENTER</a></li>\n<li><a href=\"#expand-and-shrink-the-code-selection%E6%89%A9%E5%B1%95%E5%92%8C%E7%BC%A9%E5%B0%8F%E4%BB%A3%E7%A0%81%E9%80%89%E6%8B%A9-keymapctrl-w\">Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W</a></li>\n<li><a href=\"#duplicate-and-delete-lines%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%A0%E9%99%A4%E8%A1%8Ckeymapctrl-d\">Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D</a></li>\n<li><a href=\"#move-code-fragments%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E5%BF%AB%E9%80%9F%E7%A7%BB%E5%8A%A8-keymapalt-ctrl-shift\">Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆</a></li>\n<li><a href=\"#surround-and-unwrap-%E7%8E%AF%E7%BB%95%E6%A8%A1%E6%9D%BF%E4%B8%8E%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84%E6%80%A7%E5%88%A0%E9%99%A4keymapalt-t-ctrl-shift-delete\">Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete</a></li>\n<li><a href=\"#multiple-selection-%E5%A4%9A%E9%87%8D%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9keymap-alt-j-ctrl-alt-shift-j\">Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<img src=\"https://s2.loli.net/2023/10/23/UvSq4AxVNdbzeWC.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1698049838504\" style=\"zoom:67%;\" />\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\" />\n<h2 id=\"编辑基础\">编辑基础</h2>\n<h3 id=\"Context-action-上下文联想动作-KeyMap：ALT-ENTER\">Context action (上下文联想动作)  KeyMap：ALT + ENTER</h3>\n<p>你可以在几乎任何上下文中调用<strong>Context action</strong>。比如在下面代码中：</p>\n<pre><code class=\"language-python\">def method_with_unused_parameter(used, redundant):\n    print(&quot;It is used parameter: &quot; + str(used))\n\n\ndef intention_example(a, b):\n    if not (a and b):\n        return 1\n    return 2\n\n\nmethod_with_unused_parameter(&quot;first&quot;, &quot;second&quot;)\nmethod_with_unused_parameter(&quot;used&quot;, &quot;unused&quot;)\nintention_example(True, False)\n</code></pre>\n<p>针对上边的代码按下<code>ALT</code> + <code>ENTER</code>此时PyCharm会根据上下文环境来推测你想要的行动，<img src=\"https://s2.loli.net/2023/10/22/Wm1EDKLAzbFH4i2.png\" alt=\"image-20231022221515732\" style=\"zoom:150%;\" /></p>\n<p>这里就推测出第二个参数没有什么用会自动帮你移除第二个参数.</p>\n<p>可以看到整个代码部分对应的无用参数都被移除了：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/tEnWoFUckKyagmA.png\" alt=\"image-20231022221913479\"></p>\n<p>同时Context action也能提供逻辑优化等操作：</p>\n<p>还是上边的代码，我们注重这一行：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/cQ3byIvaHGo8fkB.png\" alt=\"image-20231022222939162\"></p>\n<p>我们在and这里使用快捷键<code>ALT</code> + <code>ENTER</code>：根据德摩根法则其可以优化成：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/93obW4BqQEcOtRe.png\" alt=\"image-20231022222733594\"></p>\n<h3 id=\"Expand-and-shrink-the-code-selection（扩展和缩小代码选择）-KeyMap：CTRL-W\">Expand and shrink the code selection（扩展和缩小代码选择） KeyMap：CTRL +  W</h3>\n<p>有如下代码：</p>\n<pre><code class=\"language-python\">def some_method(first, second, third):\n    print(first, second, third)\n\n\ndef example_method(condition):\n    if condition:\n        print(&quot;Begin of the work&quot;)\n        some_method(&quot;first string&quot;, &quot;This is a long string that you can select for refactoring&quot;, &quot;third string&quot;)\n        print(&quot;End of the work&quot;)\n    print(&quot;The end&quot;)\n\n</code></pre>\n<p>你想选择<code>that</code>单词，常规做法是双击，在这里你可以使用<code>CTRL + W</code>来实现操作：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/68gRUyi2tFfehSV.png\" alt=\"image-20231022223705647\"></p>\n<p>效果如下：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/K5Np9UElIOzZwYP.png\" alt=\"image-20231022223859938\"></p>\n<p>此时你需要选择整个字符串，无需动鼠标，<code>CTRL+W</code>即可实现对应操作：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/oVF3ZNhwjx7QDMn.png\" alt=\"image-20231022224043310\"></p>\n<p>当然你连续按下三次<code>CTRL+W</code>，你就可选择整个引用内容，包含引号：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/CEWYKtswjuA6Pcb.png\" alt=\"image-20231022231031499\"></p>\n<p>当然你连续按下四次<code>CTRL+W</code>，你就可选择整个调用内容：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/KyXmx9pB3IZhACa.png\" alt=\"image-20231022231548555\"></p>\n<p>当然有时候会有不小心按错，使用快捷键<code>CTRL+Shift+W</code>就可以回退：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/qO2Cj7UDyYV1cNv.png\" alt=\"image-20231022232010023\"></p>\n<p>在if后边，两次CTRL+W就可以选择整个if表达，十分快捷：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/n81dtaj2uXmOQlW.png\" alt=\"image-20231022232157648\"></p>\n<h3 id=\"Duplicate-and-delete-lines（快速复制和删除行）KeyMap：CTRL-D\">Duplicate and delete lines（快速复制和删除行）KeyMap：CTRL + D</h3>\n<p>当你想快速复制某一行代码的时候，如下所示：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/hxuCcEXa7es9k5Z.png\" alt=\"image-20231022233258128\"></p>\n<p>将光标放在此处按下 CTRL+D，快速复制此行：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/1lzJn3ySCUhR9NL.png\" alt=\"image-20231022233542868\"></p>\n<p>当你需要复制多行的时候：</p>\n<p><img src=\"https://s2.loli.net/2023/10/22/fUzrZhDaXqdQVYW.png\" alt=\"image-20231022233522113\"></p>\n<p>完成复制：<img src=\"https://s2.loli.net/2023/10/22/i2AxcjtTroqQm61.png\" alt=\"image-20231022233701314\"></p>\n<p>快速删除行的时候使用<code>CTRL+Y</code>快捷键实现行删除。</p>\n<h3 id=\"Move-code-fragments（代码片段快速移动）-KeyMap：ALT-CTRL-Shift-⬇-⬆\">Move code fragments（代码片段快速移动） KeyMap：ALT / CTRL  +  Shift  +  ⬇ / ⬆</h3>\n<p>重新排序代码往往需要两个过程，剪切和粘贴，而通过Pycharm可以快速实现代码的重排序：</p>\n<p>如下代码片段，我们想将输出放到代码更新后：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/mxWQFl7pPgheBYA.gif\" alt=\"2\"></p>\n<p>到这里你也许会感觉有点鸡肋，但是如果他能整个方法，整个结构一起移动呢？</p>\n<p>我们将光标放到方法名称前，然后按下快捷键<code>CTRL + Shift +  ⬆</code>，实现整个方法的迁移：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/LiNvx31OsGTWReQ.gif\" alt=\"1\"></p>\n<h3 id=\"Surround-and-unwrap-（环绕模板与代码结构性删除）KeyMap：ALT-T-CTRL-Shift-Delete\">Surround and unwrap （环绕模板与代码结构性删除）KeyMap：ALT + T /  CTRL + Shift + Delete</h3>\n<p>通常对结构化的代码如<code>if</code>等，需要在外围添加<code>while</code>或者<code>trycatch</code>通常需要进行多步操作，通过环绕代码模板可以快速进行填充，同时也可以使用结构性抹除进行删减，如下面代码：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/GBq8xD9aFpMhiOW.gif\" alt=\"3\"></p>\n<h3 id=\"Multiple-selection-（多重快速选择）KeyMap-：ALT-J-CTRL-ALT-Shift-J\">Multiple selection （多重快速选择）KeyMap ：ALT + J  /  CTRL  +  ALT  +  Shift  +  J</h3>\n<p>通常我们在使用Pycharm的时候也会有需求去处理HTML等非常标签化的语言，修改的时候需要前后标签一起修改，鼠标移动的话非正常不方便，Pycharm提供了较为方便的操作多重选择，多重选择后直接进入了编辑模式可以对多个对象同时编辑，见如下代码：</p>\n<p><img src=\"https://s2.loli.net/2023/10/23/MOfGU7n2ovBZayc.gif\" alt=\"4\"></p>\n"},{"title":"PyCharm使用技巧（2）——代码补全","excerpt":"Pycharm代码补全","date":"2023-10-20T16:00:00.000Z","_content":"\n# PyCharm使用技巧（2）——代码补全\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n<img src=\"https://s2.loli.net/2023/11/23/wy1u6H7pXNJfIdx.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1700749534081\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\" />\n\n\n\n## 代码补全\n\n### Basic completion （基本补全）  KeyMap：ALT + A \n\n默认情况下PyCharm会自动给你进行提示，当日输入内容的时候就会进行补全，但是某些情况下并不会立马给你提示，尤其是在你没有输入的时候，那么如何主动唤醒补全呢？\n\n在我的设置中可以使用快捷键`ALT + A` 来实现主动唤醒，效果如下：\n\n![4](https://s2.loli.net/2023/11/23/M13iBtAVOxPEb2u.gif)\n\n#### 注意\n\n注意这里和编辑基础的**Context action (上下文联想动作)**  KeyMap：ALT + ENTER 并不一样，Context action 推测的是动作，补全针对的是内容。\n\n下图展示了如果使用Context action 的效果：\n\n![image-20231123210159827](https://s2.loli.net/2023/11/23/7ec5LU648ZRwqQO.png)\n\n### Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter\n\n在基本补全产生的浮空标签页中，我们不仅可以针对需要写的内容进行补全，也可以对已经存在的某一个或者某一类对象进行修改，下图展示了如何针对已存在对象进行补全：\n\n下图为了修改`current`为`total`我们使用主动唤醒补全来实现，然后按下`ALT + A  + Tab` 来实现替换，但是并不着急，这里并不是说只能实现替换功能，我们也可以通过`ALT + A  + Enter`来实现插入功能，正如动图前边的内容所展示的插入操作：\n\n![4](https://s2.loli.net/2023/11/23/qsJceV6GCdyubzp.gif)\n\n#### 注意\n\n注意光标所在位置所产生的影响，动图的中也展示了光标进行左右移动的时候浮空标签页所展示内容也是不同的。\n\n### Postfix Completion  （后缀补全）   KeyMap：.\n\n后缀补全，后翎补全有助于在写代码时成少向前转光标您可以根据添加的后绍、表达式的类型及其上下文，将已键入的表达式转换成另一种形式在图括号后面罐入`.`以查看建议列表。\n\n下图展示了如何从表达式后边直接修改表达式内容。\n\n![5](https://s2.loli.net/2023/11/23/ZMPthgbOIFC7sW3.gif)\n\n### Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)  \n\n我最讨厌的PyCharm的就是整个教程讲的一点也不清楚，但是至少他还给你做个教程，属实难绷，下面这里就是让人最理解的地方：\n\n这里引入了Type-matching completion，虽然名字叫这个，但实际上在教程上起了一个更加迷惑的名字叫**Smart Completion**，当使用Basic completion 基本补全无效的时候，也就是说无法直接获取对象的信息的时候，可以使用`Ctrl + Shift + Space`来实现通过上下文信息推断内容，这里不是很好用，仅限在于基本补全无法使用的时候比较好用。\n\n![image-20231123215819686](https://s2.loli.net/2023/11/23/qBFgcLrAEolTs4t.png)\n\n具体操作见下图：\n\n![6](https://s2.loli.net/2023/11/23/BrvsjOzaLp3FVwt.gif)\n\n### F-string completion  F-string补全  KeyMap:None\n\nPyCharm已经实现了支持F-string的补全，F-string是什么？\n\n详见：[7. Input and Output — Python 3.12.0 documentation](https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings)\n\n理解了F-string这里就不赘述了。\n\n![7](https://s2.loli.net/2023/11/23/ErUegW1pAoX7l3c.gif)\n","source":"_posts/PyCharm使用技巧（2）——代码补全.md","raw":"---\ntitle: PyCharm使用技巧（2）——代码补全\ncategories:\n  - Pycharm\ntags:\n  - Pycharm\nexcerpt: \"Pycharm代码补全\"\ndate: 2023/10/21 00:00:00\n---\n\n# PyCharm使用技巧（2）——代码补全\n\n## 提示：图床在国外且动图比较多的情况下，需要时间加载。\n\n## 目录：\n\n<!-- toc -->\n\n[TOC]\n\n<img src=\"https://s2.loli.net/2023/11/23/wy1u6H7pXNJfIdx.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1700749534081\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\" />\n\n\n\n## 代码补全\n\n### Basic completion （基本补全）  KeyMap：ALT + A \n\n默认情况下PyCharm会自动给你进行提示，当日输入内容的时候就会进行补全，但是某些情况下并不会立马给你提示，尤其是在你没有输入的时候，那么如何主动唤醒补全呢？\n\n在我的设置中可以使用快捷键`ALT + A` 来实现主动唤醒，效果如下：\n\n![4](https://s2.loli.net/2023/11/23/M13iBtAVOxPEb2u.gif)\n\n#### 注意\n\n注意这里和编辑基础的**Context action (上下文联想动作)**  KeyMap：ALT + ENTER 并不一样，Context action 推测的是动作，补全针对的是内容。\n\n下图展示了如果使用Context action 的效果：\n\n![image-20231123210159827](https://s2.loli.net/2023/11/23/7ec5LU648ZRwqQO.png)\n\n### Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter\n\n在基本补全产生的浮空标签页中，我们不仅可以针对需要写的内容进行补全，也可以对已经存在的某一个或者某一类对象进行修改，下图展示了如何针对已存在对象进行补全：\n\n下图为了修改`current`为`total`我们使用主动唤醒补全来实现，然后按下`ALT + A  + Tab` 来实现替换，但是并不着急，这里并不是说只能实现替换功能，我们也可以通过`ALT + A  + Enter`来实现插入功能，正如动图前边的内容所展示的插入操作：\n\n![4](https://s2.loli.net/2023/11/23/qsJceV6GCdyubzp.gif)\n\n#### 注意\n\n注意光标所在位置所产生的影响，动图的中也展示了光标进行左右移动的时候浮空标签页所展示内容也是不同的。\n\n### Postfix Completion  （后缀补全）   KeyMap：.\n\n后缀补全，后翎补全有助于在写代码时成少向前转光标您可以根据添加的后绍、表达式的类型及其上下文，将已键入的表达式转换成另一种形式在图括号后面罐入`.`以查看建议列表。\n\n下图展示了如何从表达式后边直接修改表达式内容。\n\n![5](https://s2.loli.net/2023/11/23/ZMPthgbOIFC7sW3.gif)\n\n### Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)  \n\n我最讨厌的PyCharm的就是整个教程讲的一点也不清楚，但是至少他还给你做个教程，属实难绷，下面这里就是让人最理解的地方：\n\n这里引入了Type-matching completion，虽然名字叫这个，但实际上在教程上起了一个更加迷惑的名字叫**Smart Completion**，当使用Basic completion 基本补全无效的时候，也就是说无法直接获取对象的信息的时候，可以使用`Ctrl + Shift + Space`来实现通过上下文信息推断内容，这里不是很好用，仅限在于基本补全无法使用的时候比较好用。\n\n![image-20231123215819686](https://s2.loli.net/2023/11/23/qBFgcLrAEolTs4t.png)\n\n具体操作见下图：\n\n![6](https://s2.loli.net/2023/11/23/BrvsjOzaLp3FVwt.gif)\n\n### F-string completion  F-string补全  KeyMap:None\n\nPyCharm已经实现了支持F-string的补全，F-string是什么？\n\n详见：[7. Input and Output — Python 3.12.0 documentation](https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings)\n\n理解了F-string这里就不赘述了。\n\n![7](https://s2.loli.net/2023/11/23/ErUegW1pAoX7l3c.gif)\n","slug":"PyCharm使用技巧（2）——代码补全","published":1,"updated":"2024-11-06T04:51:46.743Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti0a002tyjincgc14uy8","content":"<h1><span id=\"pycharm使用技巧2代码补全\">PyCharm使用技巧（2）——代码补全</span></h1>\n<h2><span id=\"提示图床在国外且动图比较多的情况下需要时间加载\">提示：图床在国外且动图比较多的情况下，需要时间加载。</span></h2>\n<h2><span id=\"目录\">目录：</span></h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8\">代码补全</a>\n<ul>\n<li><a href=\"#basic-completion-%E5%9F%BA%E6%9C%AC%E8%A1%A5%E5%85%A8-keymapalt-a\">Basic completion （基本补全）  KeyMap：ALT + A</a>\n<ul>\n<li><a href=\"#%E6%B3%A8%E6%84%8F\">注意</a></li>\n</ul>\n</li>\n<li><a href=\"#tab-completion-tab%E8%A1%A5%E5%85%A8-keymapalt-a-tab-enter\">Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter</a>\n<ul>\n<li><a href=\"#%E6%B3%A8%E6%84%8F-1\">注意</a></li>\n</ul>\n</li>\n<li><a href=\"#postfix-completion-%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8-keymap\">Postfix Completion  （后缀补全）   KeyMap：.</a></li>\n<li><a href=\"#type-matching-completion-%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E8%A1%A5%E5%85%A8-keymap-ctrl-shift-space-%E7%A9%BA%E6%A0%BC\">Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)</a></li>\n<li><a href=\"#f-string-completion-f-string%E8%A1%A5%E5%85%A8-keymapnone\">F-string completion  F-string补全  KeyMap:None</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<img src=\"https://s2.loli.net/2023/11/23/wy1u6H7pXNJfIdx.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1700749534081\" style=\"zoom:67%;\">\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\">\n<h2><span id=\"代码补全\">代码补全</span></h2>\n<h3><span id=\"basic-completion-基本补全-keymapalt-a\">Basic completion （基本补全）  KeyMap：ALT + A</span></h3>\n<p>默认情况下PyCharm会自动给你进行提示，当日输入内容的时候就会进行补全，但是某些情况下并不会立马给你提示，尤其是在你没有输入的时候，那么如何主动唤醒补全呢？</p>\n<p>在我的设置中可以使用快捷键<code>ALT + A</code> 来实现主动唤醒，效果如下：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/M13iBtAVOxPEb2u.gif\" alt=\"4\"></p>\n<h4><span id=\"注意\">注意</span></h4>\n<p>注意这里和编辑基础的<strong>Context action (上下文联想动作)</strong>  KeyMap：ALT + ENTER 并不一样，Context action 推测的是动作，补全针对的是内容。</p>\n<p>下图展示了如果使用Context action 的效果：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/7ec5LU648ZRwqQO.png\" alt=\"image-20231123210159827\"></p>\n<h3><span id=\"tab-completion-tab补全-keymapalt-a-tab-enter\">Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter</span></h3>\n<p>在基本补全产生的浮空标签页中，我们不仅可以针对需要写的内容进行补全，也可以对已经存在的某一个或者某一类对象进行修改，下图展示了如何针对已存在对象进行补全：</p>\n<p>下图为了修改<code>current</code>为<code>total</code>我们使用主动唤醒补全来实现，然后按下<code>ALT + A  + Tab</code> 来实现替换，但是并不着急，这里并不是说只能实现替换功能，我们也可以通过<code>ALT + A  + Enter</code>来实现插入功能，正如动图前边的内容所展示的插入操作：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/qsJceV6GCdyubzp.gif\" alt=\"4\"></p>\n<h4><span id=\"注意\">注意</span></h4>\n<p>注意光标所在位置所产生的影响，动图的中也展示了光标进行左右移动的时候浮空标签页所展示内容也是不同的。</p>\n<h3><span id=\"postfix-completion-后缀补全-keymap\">Postfix Completion  （后缀补全）   KeyMap：.</span></h3>\n<p>后缀补全，后翎补全有助于在写代码时成少向前转光标您可以根据添加的后绍、表达式的类型及其上下文，将已键入的表达式转换成另一种形式在图括号后面罐入<code>.</code>以查看建议列表。</p>\n<p>下图展示了如何从表达式后边直接修改表达式内容。</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/ZMPthgbOIFC7sW3.gif\" alt=\"5\"></p>\n<h3><span id=\"type-matching-completion-类型匹配补全-keymap-ctrl-shift-space-空格\">Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)</span></h3>\n<p>我最讨厌的PyCharm的就是整个教程讲的一点也不清楚，但是至少他还给你做个教程，属实难绷，下面这里就是让人最理解的地方：</p>\n<p>这里引入了Type-matching completion，虽然名字叫这个，但实际上在教程上起了一个更加迷惑的名字叫<strong>Smart Completion</strong>，当使用Basic completion 基本补全无效的时候，也就是说无法直接获取对象的信息的时候，可以使用<code>Ctrl + Shift + Space</code>来实现通过上下文信息推断内容，这里不是很好用，仅限在于基本补全无法使用的时候比较好用。</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/qBFgcLrAEolTs4t.png\" alt=\"image-20231123215819686\"></p>\n<p>具体操作见下图：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/BrvsjOzaLp3FVwt.gif\" alt=\"6\"></p>\n<h3><span id=\"f-string-completion-f-string补全-keymapnone\">F-string completion  F-string补全  KeyMap:None</span></h3>\n<p>PyCharm已经实现了支持F-string的补全，F-string是什么？</p>\n<p>详见：<a href=\"https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings\">7. Input and Output — Python 3.12.0 documentation</a></p>\n<p>理解了F-string这里就不赘述了。</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/ErUegW1pAoX7l3c.gif\" alt=\"7\"></p>\n","more":"<h1>PyCharm使用技巧（2）——代码补全</h1>\n<h2 id=\"提示：图床在国外且动图比较多的情况下，需要时间加载。\">提示：图床在国外且动图比较多的情况下，需要时间加载。</h2>\n<h2 id=\"目录：\">目录：</h2>\n<!-- toc -->\n<ul>\n<li><a href=\"#%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8\">代码补全</a>\n<ul>\n<li><a href=\"#basic-completion-%E5%9F%BA%E6%9C%AC%E8%A1%A5%E5%85%A8-keymapalt-a\">Basic completion （基本补全）  KeyMap：ALT + A</a>\n<ul>\n<li><a href=\"#%E6%B3%A8%E6%84%8F\">注意</a></li>\n</ul>\n</li>\n<li><a href=\"#tab-completion-tab%E8%A1%A5%E5%85%A8-keymapalt-a-tab-enter\">Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter</a>\n<ul>\n<li><a href=\"#%E6%B3%A8%E6%84%8F-1\">注意</a></li>\n</ul>\n</li>\n<li><a href=\"#postfix-completion-%E5%90%8E%E7%BC%80%E8%A1%A5%E5%85%A8-keymap\">Postfix Completion  （后缀补全）   KeyMap：.</a></li>\n<li><a href=\"#type-matching-completion-%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D%E8%A1%A5%E5%85%A8-keymap-ctrl-shift-space-%E7%A9%BA%E6%A0%BC\">Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)</a></li>\n<li><a href=\"#f-string-completion-f-string%E8%A1%A5%E5%85%A8-keymapnone\">F-string completion  F-string补全  KeyMap:None</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<img src=\"https://s2.loli.net/2023/11/23/wy1u6H7pXNJfIdx.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1700749534081\" style=\"zoom:67%;\" />\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1695021721029\" style=\"zoom:67%;\" />\n<h2 id=\"代码补全\">代码补全</h2>\n<h3 id=\"Basic-completion-（基本补全）-KeyMap：ALT-A\">Basic completion （基本补全）  KeyMap：ALT + A</h3>\n<p>默认情况下PyCharm会自动给你进行提示，当日输入内容的时候就会进行补全，但是某些情况下并不会立马给你提示，尤其是在你没有输入的时候，那么如何主动唤醒补全呢？</p>\n<p>在我的设置中可以使用快捷键<code>ALT + A</code> 来实现主动唤醒，效果如下：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/M13iBtAVOxPEb2u.gif\" alt=\"4\"></p>\n<h4 id=\"注意\">注意</h4>\n<p>注意这里和编辑基础的<strong>Context action (上下文联想动作)</strong>  KeyMap：ALT + ENTER 并不一样，Context action 推测的是动作，补全针对的是内容。</p>\n<p>下图展示了如果使用Context action 的效果：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/7ec5LU648ZRwqQO.png\" alt=\"image-20231123210159827\"></p>\n<h3 id=\"Tab-completion-（Tab补全）-KeyMap：ALT-A-Tab-Enter\">Tab completion （Tab补全）  KeyMap：ALT + A  + Tab  /  Enter</h3>\n<p>在基本补全产生的浮空标签页中，我们不仅可以针对需要写的内容进行补全，也可以对已经存在的某一个或者某一类对象进行修改，下图展示了如何针对已存在对象进行补全：</p>\n<p>下图为了修改<code>current</code>为<code>total</code>我们使用主动唤醒补全来实现，然后按下<code>ALT + A  + Tab</code> 来实现替换，但是并不着急，这里并不是说只能实现替换功能，我们也可以通过<code>ALT + A  + Enter</code>来实现插入功能，正如动图前边的内容所展示的插入操作：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/qsJceV6GCdyubzp.gif\" alt=\"4\"></p>\n<h4 id=\"注意-2\">注意</h4>\n<p>注意光标所在位置所产生的影响，动图的中也展示了光标进行左右移动的时候浮空标签页所展示内容也是不同的。</p>\n<h3 id=\"Postfix-Completion-（后缀补全）-KeyMap：\">Postfix Completion  （后缀补全）   KeyMap：.</h3>\n<p>后缀补全，后翎补全有助于在写代码时成少向前转光标您可以根据添加的后绍、表达式的类型及其上下文，将已键入的表达式转换成另一种形式在图括号后面罐入<code>.</code>以查看建议列表。</p>\n<p>下图展示了如何从表达式后边直接修改表达式内容。</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/ZMPthgbOIFC7sW3.gif\" alt=\"5\"></p>\n<h3 id=\"Type-matching-completion-（类型匹配补全）-KeyMap-Ctrl-Shift-Space-空格\">Type-matching completion  （类型匹配补全） KeyMap: Ctrl + Shift + Space (空格)</h3>\n<p>我最讨厌的PyCharm的就是整个教程讲的一点也不清楚，但是至少他还给你做个教程，属实难绷，下面这里就是让人最理解的地方：</p>\n<p>这里引入了Type-matching completion，虽然名字叫这个，但实际上在教程上起了一个更加迷惑的名字叫<strong>Smart Completion</strong>，当使用Basic completion 基本补全无效的时候，也就是说无法直接获取对象的信息的时候，可以使用<code>Ctrl + Shift + Space</code>来实现通过上下文信息推断内容，这里不是很好用，仅限在于基本补全无法使用的时候比较好用。</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/qBFgcLrAEolTs4t.png\" alt=\"image-20231123215819686\"></p>\n<p>具体操作见下图：</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/BrvsjOzaLp3FVwt.gif\" alt=\"6\"></p>\n<h3 id=\"F-string-completion-F-string补全-KeyMap-None\">F-string completion  F-string补全  KeyMap:None</h3>\n<p>PyCharm已经实现了支持F-string的补全，F-string是什么？</p>\n<p>详见：<a href=\"https://docs.python.org/3/tutorial/inputoutput.html#tut-f-strings\">7. Input and Output — Python 3.12.0 documentation</a></p>\n<p>理解了F-string这里就不赘述了。</p>\n<p><img src=\"https://s2.loli.net/2023/11/23/ErUegW1pAoX7l3c.gif\" alt=\"7\"></p>\n"},{"title":"Python类基础筑基（1）————面对对象","excerpt":"本文以Python3主要为主，穿插2.7的信息，如无特别说明默认为Python3。","date":"2024-09-27T16:00:00.000Z","_content":"\n# Python类基础筑基（1）————面对对象\n\n<img src=\"https://s2.loli.net/2023/11/30/9ktxJMd1G5perfh.jpg\" alt=\"zXu5EpoCmKH8FiJ\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2023/12/01/WpEDI6ayQt5zbM9.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1701391443259\" style=\"zoom:67%;\" />\n\n本文以Python3主要为主，穿插2.7的信息，如无特别说明默认为Python3\n\n\n\n[TOC]\n\n\n\n## 1.Python的命名空间与作用域\n\n### 1.1命名空间（namespace）\n\n*namespace* （命名空间）是从名称到对象的映射。现在，大多数命名空间都使用 Python 字典实现，但除非涉及到性能优化，我们一般不会关注这方面的事情，而且将来也可能会改变这种方式。命名空间的例子有：内置名称集合（包括 [`abs()`](https://docs.python.org/zh-cn/3/library/functions.html#abs) 函数以及内置异常的名称等）；一个模块的全局命名空间；一个函数调用中的局部命名空间。对象的属性集合也是命名空间的一种形式。\n\n命名空间是在不同时刻创建的，且拥有不同的生命周期。下边列出来四种常见的命名空间的简单介绍：\n\n- 内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。内置名称实际上也在模块里，即 [`builtins`](https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins) 。\n- 模块的全局命名空间在读取模块定义时创建；通常，模块的命名空间也会持续到解释器退出。\n- 从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 [`__main__`](https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__) 模块调用的一部分，也拥有自己的全局命名空间。\n- 函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局部命名空间。\n\n上述内容代表了常见的四种命名空间：内置命名空间、全局命名空间、main模块命名空间、函数的命名空间。实际上main也应该算作一种全局命名空间，只是他相对特殊这里单列出来。\n\n“从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 [`__main__`](https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__) 模块调用的一部分，也拥有自己的全局命名空间” 这句话该如何理解呢？什么是main模块自己的全局命名空间？\n\n这里可以参考一下python官方文档的解释：\n\n在 Python 中，特殊名称 `__main__` 用于两个重要的构造：\n\n1. 程序的顶层环境的名称，可以使用 `__name__ == '__main__'` 表达式进行检查；\n2. Python 包中的 `__main__.py` 文件。\n\n这两种机制都与 Python 模块有关，涉及用户如何与模块互动以及模块之间如何互动。下面详细解释了它们的作用。如果你是 Python 模块的新手，请参阅教程部分 [Modules](https://docs.python.org/3/tutorial/modules.html#tut-modules) 以进行介绍。\n\n`__main__` 是顶层代码运行的环境名称。所谓的 \"顶层代码\" 是指开始运行的第一个用户指定的 Python 模块。它之所以被称为 \"顶层\"，是因为它导入了程序所需的所有其他模块。有时 \"顶层代码\" 也被称为应用程序的 *入口点*。\n\n顶层代码环境可以是：\n\n- 交互式提示符的作用域：\n\n  ```\n  pythonCopy code>>> __name__\n  '__main__'\n  ```\n\n- 作为文件参数传递给 Python 解释器的 Python 模块：\n\n  ```\n  pythonCopy code$ python helloworld.py\n  Hello, world!\n  ```\n\n- 使用 [`-m`](https://docs.python.org/3/using/cmdline.html#cmdoption-m) 参数传递给 Python 解释器的 Python 模块或包：\n\n  ```\n  pythonCopy code$ python -m tarfile\n  usage: tarfile.py [-h] [-v] (...)\n  ```\n\n- 从标准输入中读取的 Python 代码：\n\n  ```\n  pythonCopy code$ echo \"import this\" | python\n  The Zen of Python, by Tim Peters\n  \n  Beautiful is better than ugly.\n  Explicit is better than implicit.\n  ...\n  ```\n\n- 使用 [`-c`](https://docs.python.org/3/using/cmdline.html#cmdoption-c) 参数传递给 Python 解释器的 Python 代码：\n\n  ```\n  pythonCopy code$ python -c \"import this\"\n  The Zen of Python, by Tim Peters\n  \n  Beautiful is better than ugly.\n  Explicit is better than implicit.\n  ...\n  ```\n\n在每一种情况下，顶层模块的 `__name__` 被设置为 `'__main__'`。\n\n因此，一个模块可以通过检查自己的 `__name__` 来发现它是否在顶层环境中运行，这允许一种常见的习惯用法，用于在模块未从导入语句初始化时有条件地执行代码：\n\n```\npythonCopy codeif __name__ == '__main__':\n    # 当模块未从导入语句初始化时执行。\n    ...\n```\n\n```python\nif __name__ == '__main__':\n    # Execute when the module is not initialized from an import statement.\n    ...\n```\n\n这意味着如果脚本文件被直接运行（而不是被导入为模块），那么其中的代码将作为主程序执行，即被解释器顶层调用执行。这是Python中的一种约定，用于标识脚本的主要入口点。\n\n### 1.2作用域（scope）\n\n一个命名空间的 *作用域* 是 Python 代码中的一段文本区域（textual region），**从这个区域可直接访问该命名空间**。“可直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间在内的。\n\n作用域是按字面文本（textual region）确定的解释：模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部变量已经是被静态确定了。）\n\n作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可直接访问”的嵌套作用域：\n\n- 最内层作用域，包含局部名称，并首先在其中进行搜索\n- 那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐层向外搜索。\n- 倒数第二层作用域，包含当前模块的全局名称\n- 最外层（最后搜索）的作用域，是内置名称的命名空间\n\n如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全局名称的作用域。\n\n### 1.3关于作用域和命名空间的混淆点\n\n命名空间：名称(name)及其所引用对象(object)的集合。python使用dictionary来表示命名空间，key对应名称(name)，value为名称所对应的对象(object)。\n\n实际上命名空间是一种映射关系的具体实现，在python中以dictionary来实现，其存储了具体的映射关系。\n\n而作用域是在命名空间的基础上所遵循的规则信息。其规定了我们的程序将查看哪些命名空间（中的名称）及以顺序。\n\n### 1.1.4作用域的具体例子（global & nonlocal）\n\n如果程序执行时去使用一个变量 hello ，那么 Python， 查找变量顺序为：\n\n**局部的命名空间 -> 全局命名空间 -> 内置命名空间**\n\n如果按照这个顺序找不到相应的变量，它将放弃查找并抛出一个 NameError 异常：\n\n```shell\nNameError: name 'hello' is not defined。\n```\n\nPython 有一个特殊规定。如果不存在生效的 [`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 或 [`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 `del x` 从局部作用域引用的命名空间中移除对 `x` 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是 [`import`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import) 语句和函数定义会在局部作用域中绑定模块或函数名称。\n\n[`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。\n\n摘两段关于global和nonlocal的定义：\n\n[`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 `global` 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。\n\n[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的**除全局变量以外的变量**。与 [`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 语句中列出的名称不同，[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。\n\n要重新绑定在最内层作用域以外的变量，可以使用 [`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句；如果未使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 *新的* 局部变量，而使得同名的外部变量保持不变）。\n\n[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。\n\n这句话看起来很难理解，不过没关系，下面的例子很好的解释了这个问题：\n\n```python\ndef scope_test():\n\n    def do_nonlocal():\n        spam = \"do_nonlocal spam\"\n        nonlocal spam\n        spam = \"nonlocal spam\"\n        \n    spam = \"test spam\"\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n\nscope_test()\n```\n\n![image-20231128130324612](https://s2.loli.net/2023/11/28/hmzu2dqKHFP83yS.png)\n\n可以看到`nonlocal`不能绑定已经绑定过的局部变量，这里使用‘绑定’这个词是有原因的，可以看一下下边的内容。\n\n#### 扩展：名称和对象\n\n对于Python来说所有内容都是对象，对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。这在其他语言中通常被称为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。\n\n但是，对于涉及可变对象（如列表、字典，以及大多数其他类型）的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针。\n\n我们通过以下的例子来综合解释一下如何使用global & nonlocal：\n\n```python\ndef scope_test():\n    def do_local():\n        spam = \"local spam\"\n\n    def do_nonlocal():\n        nonlocal spam\n        spam = \"nonlocal spam\"\n\n    def do_global():\n        global spam\n        spam = \"global spam\"\n\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignment:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n    do_global()\n    print(\"After global assignment:\", spam)\n\nscope_test()\nprint(\"In global scope:\", spam)\n```\n\n示例代码的输出是：\n\n```shell\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n```\n\n在调用`scope_test`之后，会先创建一个在`scope_test`函数作用域之内的`spam`变量其作用域是在`scope_test`函数的局部变量里面，这时候调用`do_local()`函数其将`do_local()`函数小局部作用域中的spam通过nonlocal关键字绑定到了上一个局部作用域中，并进行了赋值，这时上一个局部作用域中的spam被赋值修改了绑定关系。所以输出结果从`test spam`变化成为了`nonlocal spam`。\n\n需要注意的是`do_global()`函数将在全局一个不存在的spam进行了绑定，相当于在局部变量中创建了全局变量，这是比较特殊的。\n\n## 2.面对对象与类\n\n### 2.1Python的面对对象\n\n最简单的类定义形式如下：\n\n```python\nclass ClassName:\n    \"\"\"class help doc\"\"\"\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```\n\n当进入类定义时，将创建一个新的**命名空间**，并将其用作**局部作用域**，因此，所有对局部变量的赋值都是在这个新**命名空间**之内。 \n\n类的帮助信息可以通过ClassName.__ doc __查看。\n\n特别的，函数定义会绑定到这里的新函数名称。也就是会将里面的函数定义绑定到对应的函数名称，完成函数的创建。\n\n当 (从结尾处) 正常离开类定义时，将创建一个 ***类对象***。 这基本上是一个围绕类定义所创建的命名空间的包装器；至于什么是包装器，包装器的作用是什么，这个以后再讨论。\n\n原始 (在进入类定义之前有效的) 作用域将重新生效，**类对象**将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为 `ClassName`)。\n\n这里需要关注的是类其实也是一个对象，**类对象也是对象的一种。在创建的结束将类名和类对象进行绑定**。\n\n### 2.2类对象\n\n类对象支持两种操作：属性引用和实例化。\n\n#### 2.2.1属性引用\n\n 使用 Python 中所有属性引用所使用的标准语法: `obj.name`。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:\n\n```python\nclass MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n```\n\n那么 `MyClass.i` 和 `MyClass.f` 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 `MyClass.i` 的值。 有趣的是这样的内容在java系语言中被定为静态属性，其生命周期不会随着类的实例化所变化。\n\n`__doc__` 也是一个有效的属性，将返回所属类的文档字符串: `\"A simple example class\"`。\n\n#### 2.2.2实例化\n\n类对象的实例化功能实际上就是其他语言的创建类的实例对象，需要注意的是**实例对象**和**类对象**是两个不同的概念，后面会详细介绍二者的区别。\n\n类的 *实例化* 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。常见的形式如下：\n\n```python\n对象变量 = 类名()\nx = MyClass()\n```\n\n创建类的新 *实例* 并将此对象分配给局部变量 `x`。\n\n上述实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态定制的。 \n\n因此一个类可能会定义名为 [`__init__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__) 的特殊方法，就像这样:\n\n```python\ndef __init__(self):\n    self.data = []\n```\n\n当一个类定义了 `__init__()`方法时，类的实例化会自动为新创建的类实例发起调用 `__init__()`。 因此在这个例子中，可以通过以下语句获得一个已初始化的新实例:\n\n```python\nx = MyClass()\n```\n\nExample：\n\n![image-20231128173030208](https://s2.loli.net/2023/11/28/W9kIqAGpDdoZjh6.png)\n\n### 2.3实例对象\n\n实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。\n\n#### 2.3.1数据属性\n\n数据属性就是java中的成员属性，需要注意的是pyhton是一门动态的语言， 数据属性不需要声明；就像局部变量一样，它们将在首次被赋值时产生。且在操作过程中可进行删除操作，删除一个实例对象的数据属性。这是其他静态语言所难以企及的。\n\n下面举个例子，在上文的基础上进行修改：\n\n![image-20231128174245657](https://s2.loli.net/2023/11/28/c9XjiGlNACIKs42.png)\n\n只能说python过于自由了。哈哈哈。\n\n#### 2.3.2方法\n\n另一类实例属性引用称为 **方法**。 方法是**从属于**对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明）\n\n实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是其实例的相应方法。\n\n 因此在我们的示例中，`x.f` 是有效的方法引用，因为 `MyClass.f` 是一个函数，而 `x.i` 不是方法，因为 `MyClass.i` 不是函数。 但是 `x.f` 与 `MyClass.f` 并不是一回事 --- 它是一个 **方法对象**，不是**函数对象**。\n\n这里让人难以理解的就是什么。为什么方法也是对象，对于函数对象还是比较好理解的，就像变量对象一样，是基础的对象类型，那么什么是方法对象呢？\n\n### 2.4方法对象\n\n这里在上文的对象中添加一个`f()`方法，代码如下：\n\n```python\nclass Complex:\n    def __init__(self,realpart , imagpart):\n        self.r = realpart\n        self.i = imagpart\n    def f(self):\n        return 'hello world'\n```\n\n添加完成以后，Complex对象就有了方法对象，可以通过实例对象来进行引用，如下图所示，它不仅可以在实例对象中进行引用同时也可以将其存储起来，存储对象在xf中，xf就相当于方法的别名，可以看到二者指向的对象是相同。\n\n![image-20231128193553688](https://s2.loli.net/2023/11/28/JmHpSQNYbOwdLt3.png)\n\n### 2.5方法对象&函数对象的区别、类对象&实例对象的区别\n\n#### 2.5.1方法对象&函数对象的区别\n\n在官方的文档中有这样一句话：\n\nEach value is an object, and therefore has a *class* (also called its *type*). It is stored as `object.__class__`.\n\n对于方法对象和函数对象来说而这最大的区别就在于使用方法上，我们可以注意到：\n\n`f()` 的函数定义指定了一个参数，但上面调用 `x.f()` 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何参数的情况下被调用时 Python 肯定会引发异常 --- 即使参数实际上没有被使用...\n\n实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 `x.f()` 其实就相当于 `MyClass.f(x)`。\n\n我们可以构建一个例子关于f的直接引用和实例对象的方法引用，如下代码所展示的\n\n```python\n>>>y = Complex.f\n>>>y\n<function Complex.f at 0x000002A8D1C23910>\n```\n\n可以看到直接使用类对象的f引用结果变成了一个函数对象。图像右侧可以看到\n\n![image-20231128200522921](https://s2.loli.net/2023/11/28/Fi3L5f7CmOhurPk.png)\n\n那如果我们打印一个上文中`x.f`呢？\n\n![image-20231128200731043](https://s2.loli.net/2023/11/28/oZXjEUHLR51MO79.png)\n\n这就是二者的核心区别，如果我们直接调用y，他就会因为缺少参数而无法运行：\n\n![image-20231128200824816](https://s2.loli.net/2023/11/28/zl25Kf9Cs4bxdwI.png)\n\n当然到这里你会更迷惑了，那么一个实例的方法的调用过程是什么呢？\n\n当对实例对象进行属性引用时，如果该属性在实例中无法找到，将搜索实例所属的类。如果被引用的属性名称表示一个有效的类属性中的函数对象，会打包两者（实例对象和查找到的函数对象）的指针到一个抽象对象，这个抽象对象就是方法对象。当用参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并用这个新参数列表调用相应的函数对象。\n\n也就是说你本质上调用的是新参数列表的函数对象，当直接调用的时候新参数列表中没有实例对象（self实际上代之的是实例对象自己）而无法运行。\n\n这也是类对象&实例对象的区别，实际上二者底层实现不一样，功能不同。\n\n![image-20231128201202962](https://s2.loli.net/2023/11/28/5PotQHXh6DyxgWY.png)\n\n可以看到Complex自己代表了一个命名空间，和x并不相同。\n\n**任何一个作为类属性的函数都为该类的实例定义了一个相应方法**。 **注意的是这里是任何，也就是说任何符合带有self参数的引用的都只能作为方法来使用，这句话下面会解释**。函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如，下面的代码实现了一个函数并将其添加到了类中：\n\n```python\n# Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n```\n\n现在 `f`、`g` 和 `h` 都 `C` 类的指向函数对象的属性，因此它们都是 `C` 实例的方法 --- 其中 `h` 与 `g` 完全等价。 但请注意这种做法通常只会使程序的阅读者感到迷惑，这里只是展示其完全相同的结果。\n\n也就是说在类空间中定义的函数对象，被转化成为了方法。实例化后以方法对象的形式调用。\n\n那么这些函数对象能被调用吗？如何获取呢？\n\n**实例方法对象也具有属性: `m.__self__` 就是带有 `m()` 方法的实例对象，而 `m.__func__` 则是该方法所对应的函数对象。**\n\n举个例子可能会更好理解，在上文代码的基础上做一些简单的修改：\n\n```python\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        # super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n        print(self)\n        # print(self.y)\n        \nson = SonClass()\nm = son.method\nprint(m.__self__)\nfunc = m.__func__\nprint(func('self', son_value='func_test'))\n```\n\n注意的是，这里修改了method方法，取消了内部所有对self的引用，至于为什么接下来会说，我们在下边调用了`m = son.method`来获取**实例对象的方法对象**，简称**实例方法对象**，输出两个属性，并通过`__func__`来获取其函数对象，最后通过`func('self', son_value='func_test')`来实现调用函数对象。\n\n输出结果如下：\n\n```shell\nThis is son init\n<__main__.SonClass object at 0x000001526B98FA00>\nson_value is func_test\nThis is a son method\nself\n```\n\n这里再解释一下为什么要取消self的调用，很简单函数对象并没有继承关系，也不会获取self对象到底是什么，是否是实例对象，所以这里使用字符串来作为参数，输出结果就是self字符。\n\n若果包含self参数调用，会是什么样呢？报错如下：\n\n```shell\nTraceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 52, in <module>\n    print(func('self', son_value='func_test'))\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 33, in method\n    super(SonClass, self).method()\nTypeError: super(type, obj): obj must be an instance or subtype of type\n```\n\n\n\n#### 2.5.2类对象&实例对象的区别\n\n一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:\n\n```python\nclass Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\n```\n\n正如 [名称和对象](https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object) 中已讨论过的，共享数据可能在涉及 [mutable](https://docs.python.org/zh-cn/3/glossary.html#term-mutable) 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 *tricks* 列表不应该被用作类变量，因为所有的 *Dog* 实例将只共享一个单独的列表,也就是说所有可变变量不应该放到类中。正如下下面的例子中：\n\n```python\nclass Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n```\n\n这里回到本小节开头的那句话：\n\n每个值都是一个对象，因此具有 *类* （也称为 *类型*），并存储为 `object.__class__` 。\n\n我们上文代码中的打印所有的对象的Class：\n\n![image-20231128204036052](https://s2.loli.net/2023/11/28/gAqiwv28jPy4VDL.png)\n\n有趣的是Class的类型是type，这就非常有趣了，至于为什么可以参考：\n\n[在 Python 中，为什么 type 类对象自身的类型是 type？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/349522986)\n\n## 3.继承\n\n终于讨论到最有趣的地方的了，Python是我接触的第一个动态语言和多继承语言，当然，如果不支持继承，语言特性就不值得称为“类”。单继承的语言类似Java系，继承很好理解，Python的多继承将会是我们讨论的重点，我们不妨先从单继承的视角来看它的继承。\n\n子（派生）类的语法定义如下：\n\n```python\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```\n\n当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。这只是针对单继承的基本查找规则，多继承相对更加复杂一点，后面会着重讨论。\n\n### 3.1派生类的实例化\n\n派生类的实例化没有任何特殊之处: `DerivedClassName()` 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。\n\n上边的是官方的文档，实际上什么也没说，和狗屁一样，我们不如实际一点，通过几个例子来详细说明，派生类实例化会涉及到什么，应用的时候应该注意什么。\n\n3.1.1`__init__`会怎么调用?\n\n```python\nclass FatherClass(object):\n    def __init__(self):\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    # def __init__(self):\n    #     #super(SonClass,self).__init__()\n    #     print('This is son init')\n\n    def method(self):\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nson.method()\n```\n\n代码的输出：\n\n```python\nThis is father init\n<class '__main__.SonClass'>\nThis is a son method\n```\n\n可以看到子类初始化的时候没有显式指定`__init__`，就会默认调用父类的`__init__`。\n\n如果我们显式的指定`__init__`会有什么后果？我们将注释去掉，结果如下：\n\n注意的是这里的super行仍有注释存在。\n\n```python\nThis is son init\n<class '__main__.SonClass'>\nThis is a son method\n```\n\n这里就要引出`super()`方法了，这里先不说名为什么要用super()，以及super()是如何实现的，我们就先姑且把它当作父类实例的代指函数，通过他就可以调用父类的对象。\n\n我们把对应的super注释去掉，看看结果会如何：\n\n```python\nThis is father init\nThis is son init\n<class '__main__.SonClass'>\nThis is a son method\n```\n\n可以看到父类的`__init__`方法也被调用了。\n\n上述的内容可以一句话总结一下：\n\n子类没有显式指定的时候，会自动调用父类的init，子类显示指定的时候也要显式调用父类的init。\n\n需要补充的是，在没有显式指定的时候，父类的实例变量并无法访问，之恩那个访问到对应的父类的类变量。修改上文的代码后，来验证这个内容：\n\n```python\nclass FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        #super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self):\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method()\n```\n\n结果如下：\n\n```shell\nThis is son init\n<class '__main__.SonClass'>\nfather class variable\nTraceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 25, in <module>\n    print(son.x)\nAttributeError: 'SonClass' object has no attribute 'x'\n```\n\n### 3.2派生类方法的扩展与重载\n\n重载派生类的方法很简单，只需要直接修改参数内容即可：\n\n如下代码所示，重载了对应的method方法：\n\n```python\nclass FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method('mother fucker')\n```\n\n输出结果如下：\n\n```shell\nThis is father init\nThis is son init\n<class '__main__.SonClass'>\nfather class variable\nfather variable\nson_value is mother fucker\nThis is a son method\n```\n\n扩展就更加简单，只需要通过super来调用父类，即可接着父类方法来实现续写：\n\n```python\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n```\n\n输出结果如下：\n\n```python\nfather class variable\nfather variable\nThis is a father method\nson_value is mother fucker\nThis is a son method\n```\n\n### 3.3 super()函数详解\n\n上文中所有super的写法我都依照python2的写法来实现的，实际上python3对于super有了更简便的写法，如下所示：\n\n```python\nsuper(SonClass, self).method()#python 2\nsuper().method()#python 3\n```\n\n这两个关键的参数被省略了，这对新手来说是一个很方便的事情，但是参数的省略带来信息的丢失，总是让人很迷茫，super到底的作用是什么？同时有很多python3的代码也采用了python2的写法（python3 对这个是兼容的）\n\n那么不禁让人提问 ：super是如何工作的？两个参数的作用是什么呢？\n\nsuper的定义如下：\n\n```python\nclass super(type, object_or_type=None)\n返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。\n```\n\ntype这里只是一个参数名称，如果你要问和type有什么关系，不要忘记了所有class的类型是type，也就是说这里要填一个类对象进去。\n\n对于后一个参数的理解就更加简单了，填入一个**实例对象**或者**类对象**即可。\n\n那对这两个参数填入的内容已经有大概的了解，那么这两个参数到底有什么用？\n\n这两参数被用来实例化super类，对没错。super是一个类对象：\n\n```python\n>>>super.__class__\n<class 'type'>\n>>>class A:pass\n>>>super(A).__class__\n<class 'super'>\n```\n\n实例化之后将会返回代理对象，代理的就是他的祖先类的对象（可按照顺序调用各种祖先类对象，具体按照什么顺序稍后会解释）。它会将方法调用委托给 *type* 的父类或兄弟类。\n\n*object_or_type* 确定要用于搜索的 [method resolution order](https://docs.python.org/zh-cn/3/glossary.html#term-method-resolution-order)。 搜索会从 *type* 之后的类开始。\n\n**MRO** 指的是 type(**object_or_type**)的 MRO, MRO 中的那个类就是 **type**。注意这里使用粗体的指的是参数，前边的type为python内置函数。\n\n也就是说，object_or_type用于确定在哪一颗祖先树上进行搜索，因为Python是多继承的(这里还没有讲多继承是如何实现的，不过没关系，可以从真实世界的族谱上理解一下)，所以其继承关系会构建出来一颗祖先树。\n\n在早期python的经典类结构，也就是python2中MRO遵循的是从左到右，深度优先，但是在2.2版本后多继承遵循了C3算法，详细可参考：[The Python 2.3 Method Resolution Order | Python.org](https://www.python.org/download/releases/2.3/mro/)里面详细论述了python是如何实现MRO，考虑到文章的长度，在以后会单独写一篇关于继承顺序的文章，这里可以先看一下参考文献。\n\n举一个简单的例子：\n\nFor example, if [`__mro__`](https://docs.python.org/3/library/stdtypes.html#class.__mro__) of *object_or_type* is `D -> B -> C -> A -> object` and the value of *type* is `B`, then [`super()`](https://docs.python.org/3/library/functions.html#super) searches `C -> A -> object`。\n\n想要了解某一个类的MRO情况可以通过__mro__属性来获取：\n\n```python\nprint(SonClass.__mro__)\n输出：\n(<class '__main__.SonClass'>, <class '__main__.FatherClass'>, <class '__main__.UncleClass'>, <class 'object'>)\n```\n\n这里再介绍一下两个内置函数，这两个内置函数用来测试是否满足的super的参数条件。\n\n- 使用 [`isinstance()`](https://docs.python.org/zh-cn/3/library/functions.html#isinstance) 来检查一个实例的类型: `isinstance(obj, int)` 仅会在 `obj.__class__` 为 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 或某个派生自 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 的类时为 `True`。简单来说作用是检测实例是否是某一个类子类的实例对象。\n- 使用 [`issubclass()`](https://docs.python.org/zh-cn/3/library/functions.html#issubclass) 来检查类的继承关系: `issubclass(bool, int)` 为 `True`，因为 [`bool`](https://docs.python.org/zh-cn/3/library/functions.html#bool) 是 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 的子类。 但是，`issubclass(float, int)` 为 `False`，因为 [`float`](https://docs.python.org/zh-cn/3/library/functions.html#float) 不是 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 的子类。 检测class对象是否为某一个类对象的子类。\n\n实际上super的参数还有另一种情况，当object_or_type 输入类型也是type的时候，就需要满足issubclass为true的条件，这时候super的调用就成了这样：\n\n```python\nsuper(type1, type2)\n```\n\nMRO 指的是 **type2** 的 **MRO**, **MRO** 中的那个类就是 **type1** ，同时 **issubclass(type2, type1) == True** 。\n\n那么， **super()** 实际上做了啥呢？简单来说就是：提供一个 **MRO** 以及一个 **MRO** 中的类 **C** ， **super()** 将返回一个从 **MRO** 中 **C** 之后的类中查找方法的对象。\n\n那是不是意味着我们也可以这样写，写了之后会有什么效果呢？\n\n这样调用会有什么结果呢？我们再举一个例子，在上文的代码中扩充添加一个TestClass类，他是最底层的类，是所有类的子类：\n\n```python\nclass FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n    def function():\n        print('This is a father function')\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n\n\nclass TestClass(SonClass):\n    def __init__(self):\n        super().__init__()\n\n    def metod(self):\n        pass\n\n```\n\n然后进行调用：\n\n```python\nson = SonClass()\nprint(super(SonClass, TestClass).y)\n```\n\n输出结果：\n\n```shell\nThis is father init\nThis is son init\nfather class variable\n```\n\n可以看到他直接找到了父类作为调用对象，并输出了对应的y属性，需要注意的是这里无法针对方法对象来实现，原因很简单，并没有self参数作为载体，来进行方法的调用。记住上文说的：**任何一个作为类属性的函数都为该类的实例定义了一个相应方法**。不能把它作为函数对象来调用。\n\n### 3.4私有变量\n\n那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。这也算是设计特点， 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 `_spam`) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。\n\n但是这样并不是很有效的操作，例如避免名称与子类所定义的名称相冲突，即使去使用 `_spam`的形式也是不合理的，子类仍能继承到，因此Python存在一个机制，叫做**名称改写**。\n\n### 3.4.1名称改写\n\n形式为 `__spam` 的标识符，至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 `_classname__spam`，其中 `classname` 为去除了前缀下划线的当前类名称。\n\n这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。\n\n举个例子：如何使用私有变量进行解耦合\n\n```python\nclass FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.method()\n\n    def method(self):\n        print(\"This is a father method\")\n```\n\n可以看到 父类这里的init和method进行了耦合，init依赖于 method。产生了耦合\n\n子类继承的时候无法重写method方法，如果重写了就会报错：\n\n子类定义如下：\n\n```python\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n```\n\n报错信息如下：\n\n```shell\nTraceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 33, in <module>\n    son = SonClass()\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 16, in __init__\n    super(SonClass, self).__init__()\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 7, in __init__\n    self.method()\nTypeError: SonClass.method() missing 1 required positional argument: 'son_value'\nThis is father init\n```\n\n如何进行解耦合呢？\n\n```python\nclass FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.__method()\n\n    def method(self):\n        print(\"This is a father method\")\n\n    __method = method\n```\n\n修改父类如上，使用名称改写来实现其解耦，子类无法直接调用到方法__y，实际上被替换为`_FatherClass__method()` ,不要没事调用他。\n\n上面的示例即使在 `SonClass` 引入了一个 `__update` 标识符的情况下也不会出错，因为它会在 `FatherClass` 类中被替换为 `_FatherClass__update` 而在 `MappingSubclass` 类中被替换为 `_MappingSubclass__update`。\n\n## 4.dataclass\n\n有时候需要一些数据类型类似C的struct结构的，需要糅合一部分数据在一起，Python提供了预实现模块**dataclasses**，\n\n我们引用就可以了，举个例子：\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Chinese:\n    name: str\n    money: str\n    appearance: str\n    theone:bool\n```\n\n如何使用呢？\n\n```python\nneonexus = Chinese('neonexus',money=0,appearance='normal',theone=False)\nprint(neonexus.theone)\n```\n\n输出结果：\n\n```python\n<super: <class 'SonClass'>, <TestClass object>>\nFalse\n```\n\n# 参考文章：\n\n[Python’s super() considered super! | Deep Thoughts by Raymond Hettinger (wordpress.com)](https://rhettinger.wordpress.com/2011/05/26/super-considered-super/)\n\n[Good With Computers (sixty-north.com)](https://sixty-north.com/blog/pythons-super-not-as-simple-as-you-thought.html)\n\n[Python super 详解 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/python-super-detail-intro.html)\n\n[3. 数据模型 — Python 3.12.0 文档](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__)\n\n[3. 数据模型 — Python 2.7.18 文档](https://docs.python.org/zh-cn/2.7/reference/datamodel.html?highlight=__init__#object.__init__)\n\n[内置函数 — Python 3.12.0 文档](https://docs.python.org/zh-cn/3/library/functions.html#super)\n\n[9. 类 — Python 3.12.0 文档](https://docs.python.org/zh-cn/3/tutorial/classes.html)\n\n[9. 类 — Python 2.7.18 文档](https://docs.python.org/zh-cn/2.7/tutorial/classes.html)\n","source":"_posts/Python筑基(1)——面对对象.md","raw":"---\ntitle: Python类基础筑基（1）————面对对象\ncategories:\n  - Pytorch\ntags:\n  - Pytorch\nexcerpt: \"本文以Python3主要为主，穿插2.7的信息，如无特别说明默认为Python3。\"\ndate: 2024/09/28 00:00:00\n---\n\n# Python类基础筑基（1）————面对对象\n\n<img src=\"https://s2.loli.net/2023/11/30/9ktxJMd1G5perfh.jpg\" alt=\"zXu5EpoCmKH8FiJ\" style=\"zoom:67%;\" />\n\n<img src=\"https://s2.loli.net/2023/12/01/WpEDI6ayQt5zbM9.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1701391443259\" style=\"zoom:67%;\" />\n\n本文以Python3主要为主，穿插2.7的信息，如无特别说明默认为Python3\n\n\n\n[TOC]\n\n\n\n## 1.Python的命名空间与作用域\n\n### 1.1命名空间（namespace）\n\n*namespace* （命名空间）是从名称到对象的映射。现在，大多数命名空间都使用 Python 字典实现，但除非涉及到性能优化，我们一般不会关注这方面的事情，而且将来也可能会改变这种方式。命名空间的例子有：内置名称集合（包括 [`abs()`](https://docs.python.org/zh-cn/3/library/functions.html#abs) 函数以及内置异常的名称等）；一个模块的全局命名空间；一个函数调用中的局部命名空间。对象的属性集合也是命名空间的一种形式。\n\n命名空间是在不同时刻创建的，且拥有不同的生命周期。下边列出来四种常见的命名空间的简单介绍：\n\n- 内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。内置名称实际上也在模块里，即 [`builtins`](https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins) 。\n- 模块的全局命名空间在读取模块定义时创建；通常，模块的命名空间也会持续到解释器退出。\n- 从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 [`__main__`](https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__) 模块调用的一部分，也拥有自己的全局命名空间。\n- 函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局部命名空间。\n\n上述内容代表了常见的四种命名空间：内置命名空间、全局命名空间、main模块命名空间、函数的命名空间。实际上main也应该算作一种全局命名空间，只是他相对特殊这里单列出来。\n\n“从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 [`__main__`](https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__) 模块调用的一部分，也拥有自己的全局命名空间” 这句话该如何理解呢？什么是main模块自己的全局命名空间？\n\n这里可以参考一下python官方文档的解释：\n\n在 Python 中，特殊名称 `__main__` 用于两个重要的构造：\n\n1. 程序的顶层环境的名称，可以使用 `__name__ == '__main__'` 表达式进行检查；\n2. Python 包中的 `__main__.py` 文件。\n\n这两种机制都与 Python 模块有关，涉及用户如何与模块互动以及模块之间如何互动。下面详细解释了它们的作用。如果你是 Python 模块的新手，请参阅教程部分 [Modules](https://docs.python.org/3/tutorial/modules.html#tut-modules) 以进行介绍。\n\n`__main__` 是顶层代码运行的环境名称。所谓的 \"顶层代码\" 是指开始运行的第一个用户指定的 Python 模块。它之所以被称为 \"顶层\"，是因为它导入了程序所需的所有其他模块。有时 \"顶层代码\" 也被称为应用程序的 *入口点*。\n\n顶层代码环境可以是：\n\n- 交互式提示符的作用域：\n\n  ```\n  pythonCopy code>>> __name__\n  '__main__'\n  ```\n\n- 作为文件参数传递给 Python 解释器的 Python 模块：\n\n  ```\n  pythonCopy code$ python helloworld.py\n  Hello, world!\n  ```\n\n- 使用 [`-m`](https://docs.python.org/3/using/cmdline.html#cmdoption-m) 参数传递给 Python 解释器的 Python 模块或包：\n\n  ```\n  pythonCopy code$ python -m tarfile\n  usage: tarfile.py [-h] [-v] (...)\n  ```\n\n- 从标准输入中读取的 Python 代码：\n\n  ```\n  pythonCopy code$ echo \"import this\" | python\n  The Zen of Python, by Tim Peters\n  \n  Beautiful is better than ugly.\n  Explicit is better than implicit.\n  ...\n  ```\n\n- 使用 [`-c`](https://docs.python.org/3/using/cmdline.html#cmdoption-c) 参数传递给 Python 解释器的 Python 代码：\n\n  ```\n  pythonCopy code$ python -c \"import this\"\n  The Zen of Python, by Tim Peters\n  \n  Beautiful is better than ugly.\n  Explicit is better than implicit.\n  ...\n  ```\n\n在每一种情况下，顶层模块的 `__name__` 被设置为 `'__main__'`。\n\n因此，一个模块可以通过检查自己的 `__name__` 来发现它是否在顶层环境中运行，这允许一种常见的习惯用法，用于在模块未从导入语句初始化时有条件地执行代码：\n\n```\npythonCopy codeif __name__ == '__main__':\n    # 当模块未从导入语句初始化时执行。\n    ...\n```\n\n```python\nif __name__ == '__main__':\n    # Execute when the module is not initialized from an import statement.\n    ...\n```\n\n这意味着如果脚本文件被直接运行（而不是被导入为模块），那么其中的代码将作为主程序执行，即被解释器顶层调用执行。这是Python中的一种约定，用于标识脚本的主要入口点。\n\n### 1.2作用域（scope）\n\n一个命名空间的 *作用域* 是 Python 代码中的一段文本区域（textual region），**从这个区域可直接访问该命名空间**。“可直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间在内的。\n\n作用域是按字面文本（textual region）确定的解释：模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部变量已经是被静态确定了。）\n\n作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可直接访问”的嵌套作用域：\n\n- 最内层作用域，包含局部名称，并首先在其中进行搜索\n- 那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐层向外搜索。\n- 倒数第二层作用域，包含当前模块的全局名称\n- 最外层（最后搜索）的作用域，是内置名称的命名空间\n\n如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全局名称的作用域。\n\n### 1.3关于作用域和命名空间的混淆点\n\n命名空间：名称(name)及其所引用对象(object)的集合。python使用dictionary来表示命名空间，key对应名称(name)，value为名称所对应的对象(object)。\n\n实际上命名空间是一种映射关系的具体实现，在python中以dictionary来实现，其存储了具体的映射关系。\n\n而作用域是在命名空间的基础上所遵循的规则信息。其规定了我们的程序将查看哪些命名空间（中的名称）及以顺序。\n\n### 1.1.4作用域的具体例子（global & nonlocal）\n\n如果程序执行时去使用一个变量 hello ，那么 Python， 查找变量顺序为：\n\n**局部的命名空间 -> 全局命名空间 -> 内置命名空间**\n\n如果按照这个顺序找不到相应的变量，它将放弃查找并抛出一个 NameError 异常：\n\n```shell\nNameError: name 'hello' is not defined。\n```\n\nPython 有一个特殊规定。如果不存在生效的 [`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 或 [`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 `del x` 从局部作用域引用的命名空间中移除对 `x` 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是 [`import`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import) 语句和函数定义会在局部作用域中绑定模块或函数名称。\n\n[`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。\n\n摘两段关于global和nonlocal的定义：\n\n[`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 `global` 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。\n\n[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的**除全局变量以外的变量**。与 [`global`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global) 语句中列出的名称不同，[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。\n\n要重新绑定在最内层作用域以外的变量，可以使用 [`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句；如果未使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 *新的* 局部变量，而使得同名的外部变量保持不变）。\n\n[`nonlocal`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal) 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。\n\n这句话看起来很难理解，不过没关系，下面的例子很好的解释了这个问题：\n\n```python\ndef scope_test():\n\n    def do_nonlocal():\n        spam = \"do_nonlocal spam\"\n        nonlocal spam\n        spam = \"nonlocal spam\"\n        \n    spam = \"test spam\"\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n\nscope_test()\n```\n\n![image-20231128130324612](https://s2.loli.net/2023/11/28/hmzu2dqKHFP83yS.png)\n\n可以看到`nonlocal`不能绑定已经绑定过的局部变量，这里使用‘绑定’这个词是有原因的，可以看一下下边的内容。\n\n#### 扩展：名称和对象\n\n对于Python来说所有内容都是对象，对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。这在其他语言中通常被称为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。\n\n但是，对于涉及可变对象（如列表、字典，以及大多数其他类型）的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针。\n\n我们通过以下的例子来综合解释一下如何使用global & nonlocal：\n\n```python\ndef scope_test():\n    def do_local():\n        spam = \"local spam\"\n\n    def do_nonlocal():\n        nonlocal spam\n        spam = \"nonlocal spam\"\n\n    def do_global():\n        global spam\n        spam = \"global spam\"\n\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignment:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n    do_global()\n    print(\"After global assignment:\", spam)\n\nscope_test()\nprint(\"In global scope:\", spam)\n```\n\n示例代码的输出是：\n\n```shell\nAfter local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n```\n\n在调用`scope_test`之后，会先创建一个在`scope_test`函数作用域之内的`spam`变量其作用域是在`scope_test`函数的局部变量里面，这时候调用`do_local()`函数其将`do_local()`函数小局部作用域中的spam通过nonlocal关键字绑定到了上一个局部作用域中，并进行了赋值，这时上一个局部作用域中的spam被赋值修改了绑定关系。所以输出结果从`test spam`变化成为了`nonlocal spam`。\n\n需要注意的是`do_global()`函数将在全局一个不存在的spam进行了绑定，相当于在局部变量中创建了全局变量，这是比较特殊的。\n\n## 2.面对对象与类\n\n### 2.1Python的面对对象\n\n最简单的类定义形式如下：\n\n```python\nclass ClassName:\n    \"\"\"class help doc\"\"\"\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```\n\n当进入类定义时，将创建一个新的**命名空间**，并将其用作**局部作用域**，因此，所有对局部变量的赋值都是在这个新**命名空间**之内。 \n\n类的帮助信息可以通过ClassName.__ doc __查看。\n\n特别的，函数定义会绑定到这里的新函数名称。也就是会将里面的函数定义绑定到对应的函数名称，完成函数的创建。\n\n当 (从结尾处) 正常离开类定义时，将创建一个 ***类对象***。 这基本上是一个围绕类定义所创建的命名空间的包装器；至于什么是包装器，包装器的作用是什么，这个以后再讨论。\n\n原始 (在进入类定义之前有效的) 作用域将重新生效，**类对象**将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为 `ClassName`)。\n\n这里需要关注的是类其实也是一个对象，**类对象也是对象的一种。在创建的结束将类名和类对象进行绑定**。\n\n### 2.2类对象\n\n类对象支持两种操作：属性引用和实例化。\n\n#### 2.2.1属性引用\n\n 使用 Python 中所有属性引用所使用的标准语法: `obj.name`。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:\n\n```python\nclass MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n```\n\n那么 `MyClass.i` 和 `MyClass.f` 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 `MyClass.i` 的值。 有趣的是这样的内容在java系语言中被定为静态属性，其生命周期不会随着类的实例化所变化。\n\n`__doc__` 也是一个有效的属性，将返回所属类的文档字符串: `\"A simple example class\"`。\n\n#### 2.2.2实例化\n\n类对象的实例化功能实际上就是其他语言的创建类的实例对象，需要注意的是**实例对象**和**类对象**是两个不同的概念，后面会详细介绍二者的区别。\n\n类的 *实例化* 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。常见的形式如下：\n\n```python\n对象变量 = 类名()\nx = MyClass()\n```\n\n创建类的新 *实例* 并将此对象分配给局部变量 `x`。\n\n上述实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态定制的。 \n\n因此一个类可能会定义名为 [`__init__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__) 的特殊方法，就像这样:\n\n```python\ndef __init__(self):\n    self.data = []\n```\n\n当一个类定义了 `__init__()`方法时，类的实例化会自动为新创建的类实例发起调用 `__init__()`。 因此在这个例子中，可以通过以下语句获得一个已初始化的新实例:\n\n```python\nx = MyClass()\n```\n\nExample：\n\n![image-20231128173030208](https://s2.loli.net/2023/11/28/W9kIqAGpDdoZjh6.png)\n\n### 2.3实例对象\n\n实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。\n\n#### 2.3.1数据属性\n\n数据属性就是java中的成员属性，需要注意的是pyhton是一门动态的语言， 数据属性不需要声明；就像局部变量一样，它们将在首次被赋值时产生。且在操作过程中可进行删除操作，删除一个实例对象的数据属性。这是其他静态语言所难以企及的。\n\n下面举个例子，在上文的基础上进行修改：\n\n![image-20231128174245657](https://s2.loli.net/2023/11/28/c9XjiGlNACIKs42.png)\n\n只能说python过于自由了。哈哈哈。\n\n#### 2.3.2方法\n\n另一类实例属性引用称为 **方法**。 方法是**从属于**对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明）\n\n实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是其实例的相应方法。\n\n 因此在我们的示例中，`x.f` 是有效的方法引用，因为 `MyClass.f` 是一个函数，而 `x.i` 不是方法，因为 `MyClass.i` 不是函数。 但是 `x.f` 与 `MyClass.f` 并不是一回事 --- 它是一个 **方法对象**，不是**函数对象**。\n\n这里让人难以理解的就是什么。为什么方法也是对象，对于函数对象还是比较好理解的，就像变量对象一样，是基础的对象类型，那么什么是方法对象呢？\n\n### 2.4方法对象\n\n这里在上文的对象中添加一个`f()`方法，代码如下：\n\n```python\nclass Complex:\n    def __init__(self,realpart , imagpart):\n        self.r = realpart\n        self.i = imagpart\n    def f(self):\n        return 'hello world'\n```\n\n添加完成以后，Complex对象就有了方法对象，可以通过实例对象来进行引用，如下图所示，它不仅可以在实例对象中进行引用同时也可以将其存储起来，存储对象在xf中，xf就相当于方法的别名，可以看到二者指向的对象是相同。\n\n![image-20231128193553688](https://s2.loli.net/2023/11/28/JmHpSQNYbOwdLt3.png)\n\n### 2.5方法对象&函数对象的区别、类对象&实例对象的区别\n\n#### 2.5.1方法对象&函数对象的区别\n\n在官方的文档中有这样一句话：\n\nEach value is an object, and therefore has a *class* (also called its *type*). It is stored as `object.__class__`.\n\n对于方法对象和函数对象来说而这最大的区别就在于使用方法上，我们可以注意到：\n\n`f()` 的函数定义指定了一个参数，但上面调用 `x.f()` 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何参数的情况下被调用时 Python 肯定会引发异常 --- 即使参数实际上没有被使用...\n\n实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 `x.f()` 其实就相当于 `MyClass.f(x)`。\n\n我们可以构建一个例子关于f的直接引用和实例对象的方法引用，如下代码所展示的\n\n```python\n>>>y = Complex.f\n>>>y\n<function Complex.f at 0x000002A8D1C23910>\n```\n\n可以看到直接使用类对象的f引用结果变成了一个函数对象。图像右侧可以看到\n\n![image-20231128200522921](https://s2.loli.net/2023/11/28/Fi3L5f7CmOhurPk.png)\n\n那如果我们打印一个上文中`x.f`呢？\n\n![image-20231128200731043](https://s2.loli.net/2023/11/28/oZXjEUHLR51MO79.png)\n\n这就是二者的核心区别，如果我们直接调用y，他就会因为缺少参数而无法运行：\n\n![image-20231128200824816](https://s2.loli.net/2023/11/28/zl25Kf9Cs4bxdwI.png)\n\n当然到这里你会更迷惑了，那么一个实例的方法的调用过程是什么呢？\n\n当对实例对象进行属性引用时，如果该属性在实例中无法找到，将搜索实例所属的类。如果被引用的属性名称表示一个有效的类属性中的函数对象，会打包两者（实例对象和查找到的函数对象）的指针到一个抽象对象，这个抽象对象就是方法对象。当用参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并用这个新参数列表调用相应的函数对象。\n\n也就是说你本质上调用的是新参数列表的函数对象，当直接调用的时候新参数列表中没有实例对象（self实际上代之的是实例对象自己）而无法运行。\n\n这也是类对象&实例对象的区别，实际上二者底层实现不一样，功能不同。\n\n![image-20231128201202962](https://s2.loli.net/2023/11/28/5PotQHXh6DyxgWY.png)\n\n可以看到Complex自己代表了一个命名空间，和x并不相同。\n\n**任何一个作为类属性的函数都为该类的实例定义了一个相应方法**。 **注意的是这里是任何，也就是说任何符合带有self参数的引用的都只能作为方法来使用，这句话下面会解释**。函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如，下面的代码实现了一个函数并将其添加到了类中：\n\n```python\n# Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n```\n\n现在 `f`、`g` 和 `h` 都 `C` 类的指向函数对象的属性，因此它们都是 `C` 实例的方法 --- 其中 `h` 与 `g` 完全等价。 但请注意这种做法通常只会使程序的阅读者感到迷惑，这里只是展示其完全相同的结果。\n\n也就是说在类空间中定义的函数对象，被转化成为了方法。实例化后以方法对象的形式调用。\n\n那么这些函数对象能被调用吗？如何获取呢？\n\n**实例方法对象也具有属性: `m.__self__` 就是带有 `m()` 方法的实例对象，而 `m.__func__` 则是该方法所对应的函数对象。**\n\n举个例子可能会更好理解，在上文代码的基础上做一些简单的修改：\n\n```python\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        # super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n        print(self)\n        # print(self.y)\n        \nson = SonClass()\nm = son.method\nprint(m.__self__)\nfunc = m.__func__\nprint(func('self', son_value='func_test'))\n```\n\n注意的是，这里修改了method方法，取消了内部所有对self的引用，至于为什么接下来会说，我们在下边调用了`m = son.method`来获取**实例对象的方法对象**，简称**实例方法对象**，输出两个属性，并通过`__func__`来获取其函数对象，最后通过`func('self', son_value='func_test')`来实现调用函数对象。\n\n输出结果如下：\n\n```shell\nThis is son init\n<__main__.SonClass object at 0x000001526B98FA00>\nson_value is func_test\nThis is a son method\nself\n```\n\n这里再解释一下为什么要取消self的调用，很简单函数对象并没有继承关系，也不会获取self对象到底是什么，是否是实例对象，所以这里使用字符串来作为参数，输出结果就是self字符。\n\n若果包含self参数调用，会是什么样呢？报错如下：\n\n```shell\nTraceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 52, in <module>\n    print(func('self', son_value='func_test'))\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 33, in method\n    super(SonClass, self).method()\nTypeError: super(type, obj): obj must be an instance or subtype of type\n```\n\n\n\n#### 2.5.2类对象&实例对象的区别\n\n一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:\n\n```python\nclass Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.kind                  # shared by all dogs\n'canine'\n>>> e.kind                  # shared by all dogs\n'canine'\n>>> d.name                  # unique to d\n'Fido'\n>>> e.name                  # unique to e\n'Buddy'\n```\n\n正如 [名称和对象](https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object) 中已讨论过的，共享数据可能在涉及 [mutable](https://docs.python.org/zh-cn/3/glossary.html#term-mutable) 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 *tricks* 列表不应该被用作类变量，因为所有的 *Dog* 实例将只共享一个单独的列表,也就是说所有可变变量不应该放到类中。正如下下面的例子中：\n\n```python\nclass Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n>>> d = Dog('Fido')\n>>> e = Dog('Buddy')\n>>> d.add_trick('roll over')\n>>> e.add_trick('play dead')\n>>> d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n```\n\n这里回到本小节开头的那句话：\n\n每个值都是一个对象，因此具有 *类* （也称为 *类型*），并存储为 `object.__class__` 。\n\n我们上文代码中的打印所有的对象的Class：\n\n![image-20231128204036052](https://s2.loli.net/2023/11/28/gAqiwv28jPy4VDL.png)\n\n有趣的是Class的类型是type，这就非常有趣了，至于为什么可以参考：\n\n[在 Python 中，为什么 type 类对象自身的类型是 type？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/349522986)\n\n## 3.继承\n\n终于讨论到最有趣的地方的了，Python是我接触的第一个动态语言和多继承语言，当然，如果不支持继承，语言特性就不值得称为“类”。单继承的语言类似Java系，继承很好理解，Python的多继承将会是我们讨论的重点，我们不妨先从单继承的视角来看它的继承。\n\n子（派生）类的语法定义如下：\n\n```python\nclass DerivedClassName(BaseClassName):\n    <statement-1>\n    .\n    .\n    .\n    <statement-N>\n```\n\n当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。这只是针对单继承的基本查找规则，多继承相对更加复杂一点，后面会着重讨论。\n\n### 3.1派生类的实例化\n\n派生类的实例化没有任何特殊之处: `DerivedClassName()` 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。\n\n上边的是官方的文档，实际上什么也没说，和狗屁一样，我们不如实际一点，通过几个例子来详细说明，派生类实例化会涉及到什么，应用的时候应该注意什么。\n\n3.1.1`__init__`会怎么调用?\n\n```python\nclass FatherClass(object):\n    def __init__(self):\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    # def __init__(self):\n    #     #super(SonClass,self).__init__()\n    #     print('This is son init')\n\n    def method(self):\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nson.method()\n```\n\n代码的输出：\n\n```python\nThis is father init\n<class '__main__.SonClass'>\nThis is a son method\n```\n\n可以看到子类初始化的时候没有显式指定`__init__`，就会默认调用父类的`__init__`。\n\n如果我们显式的指定`__init__`会有什么后果？我们将注释去掉，结果如下：\n\n注意的是这里的super行仍有注释存在。\n\n```python\nThis is son init\n<class '__main__.SonClass'>\nThis is a son method\n```\n\n这里就要引出`super()`方法了，这里先不说名为什么要用super()，以及super()是如何实现的，我们就先姑且把它当作父类实例的代指函数，通过他就可以调用父类的对象。\n\n我们把对应的super注释去掉，看看结果会如何：\n\n```python\nThis is father init\nThis is son init\n<class '__main__.SonClass'>\nThis is a son method\n```\n\n可以看到父类的`__init__`方法也被调用了。\n\n上述的内容可以一句话总结一下：\n\n子类没有显式指定的时候，会自动调用父类的init，子类显示指定的时候也要显式调用父类的init。\n\n需要补充的是，在没有显式指定的时候，父类的实例变量并无法访问，之恩那个访问到对应的父类的类变量。修改上文的代码后，来验证这个内容：\n\n```python\nclass FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        #super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self):\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method()\n```\n\n结果如下：\n\n```shell\nThis is son init\n<class '__main__.SonClass'>\nfather class variable\nTraceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 25, in <module>\n    print(son.x)\nAttributeError: 'SonClass' object has no attribute 'x'\n```\n\n### 3.2派生类方法的扩展与重载\n\n重载派生类的方法很简单，只需要直接修改参数内容即可：\n\n如下代码所示，重载了对应的method方法：\n\n```python\nclass FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method('mother fucker')\n```\n\n输出结果如下：\n\n```shell\nThis is father init\nThis is son init\n<class '__main__.SonClass'>\nfather class variable\nfather variable\nson_value is mother fucker\nThis is a son method\n```\n\n扩展就更加简单，只需要通过super来调用父类，即可接着父类方法来实现续写：\n\n```python\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n```\n\n输出结果如下：\n\n```python\nfather class variable\nfather variable\nThis is a father method\nson_value is mother fucker\nThis is a son method\n```\n\n### 3.3 super()函数详解\n\n上文中所有super的写法我都依照python2的写法来实现的，实际上python3对于super有了更简便的写法，如下所示：\n\n```python\nsuper(SonClass, self).method()#python 2\nsuper().method()#python 3\n```\n\n这两个关键的参数被省略了，这对新手来说是一个很方便的事情，但是参数的省略带来信息的丢失，总是让人很迷茫，super到底的作用是什么？同时有很多python3的代码也采用了python2的写法（python3 对这个是兼容的）\n\n那么不禁让人提问 ：super是如何工作的？两个参数的作用是什么呢？\n\nsuper的定义如下：\n\n```python\nclass super(type, object_or_type=None)\n返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。\n```\n\ntype这里只是一个参数名称，如果你要问和type有什么关系，不要忘记了所有class的类型是type，也就是说这里要填一个类对象进去。\n\n对于后一个参数的理解就更加简单了，填入一个**实例对象**或者**类对象**即可。\n\n那对这两个参数填入的内容已经有大概的了解，那么这两个参数到底有什么用？\n\n这两参数被用来实例化super类，对没错。super是一个类对象：\n\n```python\n>>>super.__class__\n<class 'type'>\n>>>class A:pass\n>>>super(A).__class__\n<class 'super'>\n```\n\n实例化之后将会返回代理对象，代理的就是他的祖先类的对象（可按照顺序调用各种祖先类对象，具体按照什么顺序稍后会解释）。它会将方法调用委托给 *type* 的父类或兄弟类。\n\n*object_or_type* 确定要用于搜索的 [method resolution order](https://docs.python.org/zh-cn/3/glossary.html#term-method-resolution-order)。 搜索会从 *type* 之后的类开始。\n\n**MRO** 指的是 type(**object_or_type**)的 MRO, MRO 中的那个类就是 **type**。注意这里使用粗体的指的是参数，前边的type为python内置函数。\n\n也就是说，object_or_type用于确定在哪一颗祖先树上进行搜索，因为Python是多继承的(这里还没有讲多继承是如何实现的，不过没关系，可以从真实世界的族谱上理解一下)，所以其继承关系会构建出来一颗祖先树。\n\n在早期python的经典类结构，也就是python2中MRO遵循的是从左到右，深度优先，但是在2.2版本后多继承遵循了C3算法，详细可参考：[The Python 2.3 Method Resolution Order | Python.org](https://www.python.org/download/releases/2.3/mro/)里面详细论述了python是如何实现MRO，考虑到文章的长度，在以后会单独写一篇关于继承顺序的文章，这里可以先看一下参考文献。\n\n举一个简单的例子：\n\nFor example, if [`__mro__`](https://docs.python.org/3/library/stdtypes.html#class.__mro__) of *object_or_type* is `D -> B -> C -> A -> object` and the value of *type* is `B`, then [`super()`](https://docs.python.org/3/library/functions.html#super) searches `C -> A -> object`。\n\n想要了解某一个类的MRO情况可以通过__mro__属性来获取：\n\n```python\nprint(SonClass.__mro__)\n输出：\n(<class '__main__.SonClass'>, <class '__main__.FatherClass'>, <class '__main__.UncleClass'>, <class 'object'>)\n```\n\n这里再介绍一下两个内置函数，这两个内置函数用来测试是否满足的super的参数条件。\n\n- 使用 [`isinstance()`](https://docs.python.org/zh-cn/3/library/functions.html#isinstance) 来检查一个实例的类型: `isinstance(obj, int)` 仅会在 `obj.__class__` 为 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 或某个派生自 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 的类时为 `True`。简单来说作用是检测实例是否是某一个类子类的实例对象。\n- 使用 [`issubclass()`](https://docs.python.org/zh-cn/3/library/functions.html#issubclass) 来检查类的继承关系: `issubclass(bool, int)` 为 `True`，因为 [`bool`](https://docs.python.org/zh-cn/3/library/functions.html#bool) 是 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 的子类。 但是，`issubclass(float, int)` 为 `False`，因为 [`float`](https://docs.python.org/zh-cn/3/library/functions.html#float) 不是 [`int`](https://docs.python.org/zh-cn/3/library/functions.html#int) 的子类。 检测class对象是否为某一个类对象的子类。\n\n实际上super的参数还有另一种情况，当object_or_type 输入类型也是type的时候，就需要满足issubclass为true的条件，这时候super的调用就成了这样：\n\n```python\nsuper(type1, type2)\n```\n\nMRO 指的是 **type2** 的 **MRO**, **MRO** 中的那个类就是 **type1** ，同时 **issubclass(type2, type1) == True** 。\n\n那么， **super()** 实际上做了啥呢？简单来说就是：提供一个 **MRO** 以及一个 **MRO** 中的类 **C** ， **super()** 将返回一个从 **MRO** 中 **C** 之后的类中查找方法的对象。\n\n那是不是意味着我们也可以这样写，写了之后会有什么效果呢？\n\n这样调用会有什么结果呢？我们再举一个例子，在上文的代码中扩充添加一个TestClass类，他是最底层的类，是所有类的子类：\n\n```python\nclass FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n    def function():\n        print('This is a father function')\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n\n\nclass TestClass(SonClass):\n    def __init__(self):\n        super().__init__()\n\n    def metod(self):\n        pass\n\n```\n\n然后进行调用：\n\n```python\nson = SonClass()\nprint(super(SonClass, TestClass).y)\n```\n\n输出结果：\n\n```shell\nThis is father init\nThis is son init\nfather class variable\n```\n\n可以看到他直接找到了父类作为调用对象，并输出了对应的y属性，需要注意的是这里无法针对方法对象来实现，原因很简单，并没有self参数作为载体，来进行方法的调用。记住上文说的：**任何一个作为类属性的函数都为该类的实例定义了一个相应方法**。不能把它作为函数对象来调用。\n\n### 3.4私有变量\n\n那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。这也算是设计特点， 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 `_spam`) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。\n\n但是这样并不是很有效的操作，例如避免名称与子类所定义的名称相冲突，即使去使用 `_spam`的形式也是不合理的，子类仍能继承到，因此Python存在一个机制，叫做**名称改写**。\n\n### 3.4.1名称改写\n\n形式为 `__spam` 的标识符，至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 `_classname__spam`，其中 `classname` 为去除了前缀下划线的当前类名称。\n\n这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。\n\n举个例子：如何使用私有变量进行解耦合\n\n```python\nclass FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.method()\n\n    def method(self):\n        print(\"This is a father method\")\n```\n\n可以看到 父类这里的init和method进行了耦合，init依赖于 method。产生了耦合\n\n子类继承的时候无法重写method方法，如果重写了就会报错：\n\n子类定义如下：\n\n```python\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n```\n\n报错信息如下：\n\n```shell\nTraceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 33, in <module>\n    son = SonClass()\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 16, in __init__\n    super(SonClass, self).__init__()\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 7, in __init__\n    self.method()\nTypeError: SonClass.method() missing 1 required positional argument: 'son_value'\nThis is father init\n```\n\n如何进行解耦合呢？\n\n```python\nclass FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.__method()\n\n    def method(self):\n        print(\"This is a father method\")\n\n    __method = method\n```\n\n修改父类如上，使用名称改写来实现其解耦，子类无法直接调用到方法__y，实际上被替换为`_FatherClass__method()` ,不要没事调用他。\n\n上面的示例即使在 `SonClass` 引入了一个 `__update` 标识符的情况下也不会出错，因为它会在 `FatherClass` 类中被替换为 `_FatherClass__update` 而在 `MappingSubclass` 类中被替换为 `_MappingSubclass__update`。\n\n## 4.dataclass\n\n有时候需要一些数据类型类似C的struct结构的，需要糅合一部分数据在一起，Python提供了预实现模块**dataclasses**，\n\n我们引用就可以了，举个例子：\n\n```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Chinese:\n    name: str\n    money: str\n    appearance: str\n    theone:bool\n```\n\n如何使用呢？\n\n```python\nneonexus = Chinese('neonexus',money=0,appearance='normal',theone=False)\nprint(neonexus.theone)\n```\n\n输出结果：\n\n```python\n<super: <class 'SonClass'>, <TestClass object>>\nFalse\n```\n\n# 参考文章：\n\n[Python’s super() considered super! | Deep Thoughts by Raymond Hettinger (wordpress.com)](https://rhettinger.wordpress.com/2011/05/26/super-considered-super/)\n\n[Good With Computers (sixty-north.com)](https://sixty-north.com/blog/pythons-super-not-as-simple-as-you-thought.html)\n\n[Python super 详解 | 菜鸟教程 (runoob.com)](https://www.runoob.com/w3cnote/python-super-detail-intro.html)\n\n[3. 数据模型 — Python 3.12.0 文档](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__)\n\n[3. 数据模型 — Python 2.7.18 文档](https://docs.python.org/zh-cn/2.7/reference/datamodel.html?highlight=__init__#object.__init__)\n\n[内置函数 — Python 3.12.0 文档](https://docs.python.org/zh-cn/3/library/functions.html#super)\n\n[9. 类 — Python 3.12.0 文档](https://docs.python.org/zh-cn/3/tutorial/classes.html)\n\n[9. 类 — Python 2.7.18 文档](https://docs.python.org/zh-cn/2.7/tutorial/classes.html)\n","slug":"Python筑基(1)——面对对象","published":1,"updated":"2024-11-06T04:55:25.805Z","comments":1,"layout":"post","photos":[],"_id":"cm3zcti0a002xyjin9l2a3xmg","content":"<h1><span id=\"python类基础筑基1面对对象\">Python类基础筑基（1）————面对对象</span></h1>\n<img src=\"https://s2.loli.net/2023/11/30/9ktxJMd1G5perfh.jpg\" alt=\"zXu5EpoCmKH8FiJ\" style=\"zoom:67%;\">\n<img src=\"https://s2.loli.net/2023/12/01/WpEDI6ayQt5zbM9.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1701391443259\" style=\"zoom:67%;\">\n<p>本文以Python3主要为主，穿插2.7的信息，如无特别说明默认为Python3</p>\n<p>[TOC]</p>\n<h2><span id=\"1python的命名空间与作用域\">1.Python的命名空间与作用域</span></h2>\n<h3><span id=\"11命名空间namespace\">1.1命名空间（namespace）</span></h3>\n<p><em>namespace</em> （命名空间）是从名称到对象的映射。现在，大多数命名空间都使用 Python 字典实现，但除非涉及到性能优化，我们一般不会关注这方面的事情，而且将来也可能会改变这种方式。命名空间的例子有：内置名称集合（包括 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#abs\"><code>abs()</code></a> 函数以及内置异常的名称等）；一个模块的全局命名空间；一个函数调用中的局部命名空间。对象的属性集合也是命名空间的一种形式。</p>\n<p>命名空间是在不同时刻创建的，且拥有不同的生命周期。下边列出来四种常见的命名空间的简单介绍：</p>\n<ul>\n<li>内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。内置名称实际上也在模块里，即 <a href=\"https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins\"><code>builtins</code></a> 。</li>\n<li>模块的全局命名空间在读取模块定义时创建；通常，模块的命名空间也会持续到解释器退出。</li>\n<li>从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 <a href=\"https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__\"><code>__main__</code></a> 模块调用的一部分，也拥有自己的全局命名空间。</li>\n<li>函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局部命名空间。</li>\n</ul>\n<p>上述内容代表了常见的四种命名空间：内置命名空间、全局命名空间、main模块命名空间、函数的命名空间。实际上main也应该算作一种全局命名空间，只是他相对特殊这里单列出来。</p>\n<p>“从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 <a href=\"https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__\"><code>__main__</code></a> 模块调用的一部分，也拥有自己的全局命名空间” 这句话该如何理解呢？什么是main模块自己的全局命名空间？</p>\n<p>这里可以参考一下python官方文档的解释：</p>\n<p>在 Python 中，特殊名称 <code>__main__</code> 用于两个重要的构造：</p>\n<ol>\n<li>程序的顶层环境的名称，可以使用 <code>__name__ == '__main__'</code> 表达式进行检查；</li>\n<li>Python 包中的 <code>__main__.py</code> 文件。</li>\n</ol>\n<p>这两种机制都与 Python 模块有关，涉及用户如何与模块互动以及模块之间如何互动。下面详细解释了它们的作用。如果你是 Python 模块的新手，请参阅教程部分 <a href=\"https://docs.python.org/3/tutorial/modules.html#tut-modules\">Modules</a> 以进行介绍。</p>\n<p><code>__main__</code> 是顶层代码运行的环境名称。所谓的 “顶层代码” 是指开始运行的第一个用户指定的 Python 模块。它之所以被称为 “顶层”，是因为它导入了程序所需的所有其他模块。有时 “顶层代码” 也被称为应用程序的 <em>入口点</em>。</p>\n<p>顶层代码环境可以是：</p>\n<ul>\n<li>\n<p>交互式提示符的作用域：</p>\n<pre><code>pythonCopy code&gt;&gt;&gt; __name__\n'__main__'\n</code></pre>\n</li>\n<li>\n<p>作为文件参数传递给 Python 解释器的 Python 模块：</p>\n<pre><code>pythonCopy code$ python helloworld.py\nHello, world!\n</code></pre>\n</li>\n<li>\n<p>使用 <a href=\"https://docs.python.org/3/using/cmdline.html#cmdoption-m\"><code>-m</code></a> 参数传递给 Python 解释器的 Python 模块或包：</p>\n<pre><code>pythonCopy code$ python -m tarfile\nusage: tarfile.py [-h] [-v] (...)\n</code></pre>\n</li>\n<li>\n<p>从标准输入中读取的 Python 代码：</p>\n<pre><code>pythonCopy code$ echo \"import this\" | python\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\n...\n</code></pre>\n</li>\n<li>\n<p>使用 <a href=\"https://docs.python.org/3/using/cmdline.html#cmdoption-c\"><code>-c</code></a> 参数传递给 Python 解释器的 Python 代码：</p>\n<pre><code>pythonCopy code$ python -c \"import this\"\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\n...\n</code></pre>\n</li>\n</ul>\n<p>在每一种情况下，顶层模块的 <code>__name__</code> 被设置为 <code>'__main__'</code>。</p>\n<p>因此，一个模块可以通过检查自己的 <code>__name__</code> 来发现它是否在顶层环境中运行，这允许一种常见的习惯用法，用于在模块未从导入语句初始化时有条件地执行代码：</p>\n<pre><code>pythonCopy codeif __name__ == '__main__':\n    # 当模块未从导入语句初始化时执行。\n    ...\n</code></pre>\n<pre><code class=\"language-python\">if __name__ == '__main__':\n    # Execute when the module is not initialized from an import statement.\n    ...\n</code></pre>\n<p>这意味着如果脚本文件被直接运行（而不是被导入为模块），那么其中的代码将作为主程序执行，即被解释器顶层调用执行。这是Python中的一种约定，用于标识脚本的主要入口点。</p>\n<h3><span id=\"12作用域scope\">1.2作用域（scope）</span></h3>\n<p>一个命名空间的 <em>作用域</em> 是 Python 代码中的一段文本区域（textual region），<strong>从这个区域可直接访问该命名空间</strong>。“可直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间在内的。</p>\n<p>作用域是按字面文本（textual region）确定的解释：模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部变量已经是被静态确定了。）</p>\n<p>作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可直接访问”的嵌套作用域：</p>\n<ul>\n<li>最内层作用域，包含局部名称，并首先在其中进行搜索</li>\n<li>那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐层向外搜索。</li>\n<li>倒数第二层作用域，包含当前模块的全局名称</li>\n<li>最外层（最后搜索）的作用域，是内置名称的命名空间</li>\n</ul>\n<p>如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全局名称的作用域。</p>\n<h3><span id=\"13关于作用域和命名空间的混淆点\">1.3关于作用域和命名空间的混淆点</span></h3>\n<p>命名空间：名称(name)及其所引用对象(object)的集合。python使用dictionary来表示命名空间，key对应名称(name)，value为名称所对应的对象(object)。</p>\n<p>实际上命名空间是一种映射关系的具体实现，在python中以dictionary来实现，其存储了具体的映射关系。</p>\n<p>而作用域是在命名空间的基础上所遵循的规则信息。其规定了我们的程序将查看哪些命名空间（中的名称）及以顺序。</p>\n<h3><span id=\"114作用域的具体例子global-amp-nonlocal\">1.1.4作用域的具体例子（global &amp; nonlocal）</span></h3>\n<p>如果程序执行时去使用一个变量 hello ，那么 Python， 查找变量顺序为：</p>\n<p><strong>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</strong></p>\n<p>如果按照这个顺序找不到相应的变量，它将放弃查找并抛出一个 NameError 异常：</p>\n<pre><code class=\"language-shell\">NameError: name 'hello' is not defined。\n</code></pre>\n<p>Python 有一个特殊规定。如果不存在生效的 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 或 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 <code>del x</code> 从局部作用域引用的命名空间中移除对 <code>x</code> 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import\"><code>import</code></a> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；<a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。</p>\n<p>摘两段关于global和nonlocal的定义：</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的<strong>除全局变量以外的变量</strong>。与 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 语句中列出的名称不同，<a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。</p>\n<p>要重新绑定在最内层作用域以外的变量，可以使用 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句；如果未使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 <em>新的</em> 局部变量，而使得同名的外部变量保持不变）。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。</p>\n<p>这句话看起来很难理解，不过没关系，下面的例子很好的解释了这个问题：</p>\n<pre><code class=\"language-python\">def scope_test():\n\n    def do_nonlocal():\n        spam = \"do_nonlocal spam\"\n        nonlocal spam\n        spam = \"nonlocal spam\"\n        \n    spam = \"test spam\"\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n\nscope_test()\n</code></pre>\n<p><img src=\"https://s2.loli.net/2023/11/28/hmzu2dqKHFP83yS.png\" alt=\"image-20231128130324612\"></p>\n<p>可以看到<code>nonlocal</code>不能绑定已经绑定过的局部变量，这里使用‘绑定’这个词是有原因的，可以看一下下边的内容。</p>\n<h4><span id=\"扩展名称和对象\">扩展：名称和对象</span></h4>\n<p>对于Python来说所有内容都是对象，对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。这在其他语言中通常被称为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。</p>\n<p>但是，对于涉及可变对象（如列表、字典，以及大多数其他类型）的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针。</p>\n<p>我们通过以下的例子来综合解释一下如何使用global &amp; nonlocal：</p>\n<pre><code class=\"language-python\">def scope_test():\n    def do_local():\n        spam = \"local spam\"\n\n    def do_nonlocal():\n        nonlocal spam\n        spam = \"nonlocal spam\"\n\n    def do_global():\n        global spam\n        spam = \"global spam\"\n\n    spam = \"test spam\"\n    do_local()\n    print(\"After local assignment:\", spam)\n    do_nonlocal()\n    print(\"After nonlocal assignment:\", spam)\n    do_global()\n    print(\"After global assignment:\", spam)\n\nscope_test()\nprint(\"In global scope:\", spam)\n</code></pre>\n<p>示例代码的输出是：</p>\n<pre><code class=\"language-shell\">After local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n</code></pre>\n<p>在调用<code>scope_test</code>之后，会先创建一个在<code>scope_test</code>函数作用域之内的<code>spam</code>变量其作用域是在<code>scope_test</code>函数的局部变量里面，这时候调用<code>do_local()</code>函数其将<code>do_local()</code>函数小局部作用域中的spam通过nonlocal关键字绑定到了上一个局部作用域中，并进行了赋值，这时上一个局部作用域中的spam被赋值修改了绑定关系。所以输出结果从<code>test spam</code>变化成为了<code>nonlocal spam</code>。</p>\n<p>需要注意的是<code>do_global()</code>函数将在全局一个不存在的spam进行了绑定，相当于在局部变量中创建了全局变量，这是比较特殊的。</p>\n<h2><span id=\"2面对对象与类\">2.面对对象与类</span></h2>\n<h3><span id=\"21python的面对对象\">2.1Python的面对对象</span></h3>\n<p>最简单的类定义形式如下：</p>\n<pre><code class=\"language-python\">class ClassName:\n    \"\"\"class help doc\"\"\"\n    &lt;statement-1&gt;\n    .\n    .\n    .\n    &lt;statement-N&gt;\n</code></pre>\n<p>当进入类定义时，将创建一个新的<strong>命名空间</strong>，并将其用作<strong>局部作用域</strong>，因此，所有对局部变量的赋值都是在这个新<strong>命名空间</strong>之内。</p>\n<p>类的帮助信息可以通过ClassName.__ doc __查看。</p>\n<p>特别的，函数定义会绑定到这里的新函数名称。也就是会将里面的函数定义绑定到对应的函数名称，完成函数的创建。</p>\n<p>当 (从结尾处) 正常离开类定义时，将创建一个 <em><strong>类对象</strong></em>。 这基本上是一个围绕类定义所创建的命名空间的包装器；至于什么是包装器，包装器的作用是什么，这个以后再讨论。</p>\n<p>原始 (在进入类定义之前有效的) 作用域将重新生效，<strong>类对象</strong>将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为 <code>ClassName</code>)。</p>\n<p>这里需要关注的是类其实也是一个对象，<strong>类对象也是对象的一种。在创建的结束将类名和类对象进行绑定</strong>。</p>\n<h3><span id=\"22类对象\">2.2类对象</span></h3>\n<p>类对象支持两种操作：属性引用和实例化。</p>\n<h4><span id=\"221属性引用\">2.2.1属性引用</span></h4>\n<p>使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p>\n<pre><code class=\"language-python\">class MyClass:\n    \"\"\"A simple example class\"\"\"\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n</code></pre>\n<p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 有趣的是这样的内容在java系语言中被定为静态属性，其生命周期不会随着类的实例化所变化。</p>\n<p><code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>\"A simple example class\"</code>。</p>\n<h4><span id=\"222实例化\">2.2.2实例化</span></h4>\n<p>类对象的实例化功能实际上就是其他语言的创建类的实例对象，需要注意的是<strong>实例对象</strong>和<strong>类对象</strong>是两个不同的概念，后面会详细介绍二者的区别。</p>\n<p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。常见的形式如下：</p>\n<pre><code class=\"language-python\">对象变量 = 类名()\nx = MyClass()\n</code></pre>\n<p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p>\n<p>上述实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态定制的。</p>\n<p>因此一个类可能会定义名为 <a href=\"https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__\"><code>__init__()</code></a> 的特殊方法，就像这样:</p>\n<pre><code class=\"language-python\">def __init__(self):\n    self.data = []\n</code></pre>\n<p>当一个类定义了 <code>__init__()</code>方法时，类的实例化会自动为新创建的类实例发起调用 <code>__init__()</code>。 因此在这个例子中，可以通过以下语句获得一个已初始化的新实例:</p>\n<pre><code class=\"language-python\">x = MyClass()\n</code></pre>\n<p>Example：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/W9kIqAGpDdoZjh6.png\" alt=\"image-20231128173030208\"></p>\n<h3><span id=\"23实例对象\">2.3实例对象</span></h3>\n<p>实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p>\n<h4><span id=\"231数据属性\">2.3.1数据属性</span></h4>\n<p>数据属性就是java中的成员属性，需要注意的是pyhton是一门动态的语言， 数据属性不需要声明；就像局部变量一样，它们将在首次被赋值时产生。且在操作过程中可进行删除操作，删除一个实例对象的数据属性。这是其他静态语言所难以企及的。</p>\n<p>下面举个例子，在上文的基础上进行修改：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/c9XjiGlNACIKs42.png\" alt=\"image-20231128174245657\"></p>\n<p>只能说python过于自由了。哈哈哈。</p>\n<h4><span id=\"232方法\">2.3.2方法</span></h4>\n<p>另一类实例属性引用称为 <strong>方法</strong>。 方法是<strong>从属于</strong>对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明）</p>\n<p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是其实例的相应方法。</p>\n<p>因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 — 它是一个 <strong>方法对象</strong>，不是<strong>函数对象</strong>。</p>\n<p>这里让人难以理解的就是什么。为什么方法也是对象，对于函数对象还是比较好理解的，就像变量对象一样，是基础的对象类型，那么什么是方法对象呢？</p>\n<h3><span id=\"24方法对象\">2.4方法对象</span></h3>\n<p>这里在上文的对象中添加一个<code>f()</code>方法，代码如下：</p>\n<pre><code class=\"language-python\">class Complex:\n    def __init__(self,realpart , imagpart):\n        self.r = realpart\n        self.i = imagpart\n    def f(self):\n        return 'hello world'\n</code></pre>\n<p>添加完成以后，Complex对象就有了方法对象，可以通过实例对象来进行引用，如下图所示，它不仅可以在实例对象中进行引用同时也可以将其存储起来，存储对象在xf中，xf就相当于方法的别名，可以看到二者指向的对象是相同。</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/JmHpSQNYbOwdLt3.png\" alt=\"image-20231128193553688\"></p>\n<h3><span id=\"25方法对象amp函数对象的区别-类对象amp实例对象的区别\">2.5方法对象&amp;函数对象的区别、类对象&amp;实例对象的区别</span></h3>\n<h4><span id=\"251方法对象amp函数对象的区别\">2.5.1方法对象&amp;函数对象的区别</span></h4>\n<p>在官方的文档中有这样一句话：</p>\n<p>Each value is an object, and therefore has a <em>class</em> (also called its <em>type</em>). It is stored as <code>object.__class__</code>.</p>\n<p>对于方法对象和函数对象来说而这最大的区别就在于使用方法上，我们可以注意到：</p>\n<p><code>f()</code> 的函数定义指定了一个参数，但上面调用 <code>x.f()</code> 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何参数的情况下被调用时 Python 肯定会引发异常 — 即使参数实际上没有被使用…</p>\n<p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。</p>\n<p>我们可以构建一个例子关于f的直接引用和实例对象的方法引用，如下代码所展示的</p>\n<pre><code class=\"language-python\">&gt;&gt;&gt;y = Complex.f\n&gt;&gt;&gt;y\n&lt;function Complex.f at 0x000002A8D1C23910&gt;\n</code></pre>\n<p>可以看到直接使用类对象的f引用结果变成了一个函数对象。图像右侧可以看到</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/Fi3L5f7CmOhurPk.png\" alt=\"image-20231128200522921\"></p>\n<p>那如果我们打印一个上文中<code>x.f</code>呢？</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/oZXjEUHLR51MO79.png\" alt=\"image-20231128200731043\"></p>\n<p>这就是二者的核心区别，如果我们直接调用y，他就会因为缺少参数而无法运行：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/zl25Kf9Cs4bxdwI.png\" alt=\"image-20231128200824816\"></p>\n<p>当然到这里你会更迷惑了，那么一个实例的方法的调用过程是什么呢？</p>\n<p>当对实例对象进行属性引用时，如果该属性在实例中无法找到，将搜索实例所属的类。如果被引用的属性名称表示一个有效的类属性中的函数对象，会打包两者（实例对象和查找到的函数对象）的指针到一个抽象对象，这个抽象对象就是方法对象。当用参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并用这个新参数列表调用相应的函数对象。</p>\n<p>也就是说你本质上调用的是新参数列表的函数对象，当直接调用的时候新参数列表中没有实例对象（self实际上代之的是实例对象自己）而无法运行。</p>\n<p>这也是类对象&amp;实例对象的区别，实际上二者底层实现不一样，功能不同。</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/5PotQHXh6DyxgWY.png\" alt=\"image-20231128201202962\"></p>\n<p>可以看到Complex自己代表了一个命名空间，和x并不相同。</p>\n<p><strong>任何一个作为类属性的函数都为该类的实例定义了一个相应方法</strong>。 <strong>注意的是这里是任何，也就是说任何符合带有self参数的引用的都只能作为方法来使用，这句话下面会解释</strong>。函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如，下面的代码实现了一个函数并将其添加到了类中：</p>\n<pre><code class=\"language-python\"># Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n</code></pre>\n<p>现在 <code>f</code>、<code>g</code> 和 <code>h</code> 都 <code>C</code> 类的指向函数对象的属性，因此它们都是 <code>C</code> 实例的方法 — 其中 <code>h</code> 与 <code>g</code> 完全等价。 但请注意这种做法通常只会使程序的阅读者感到迷惑，这里只是展示其完全相同的结果。</p>\n<p>也就是说在类空间中定义的函数对象，被转化成为了方法。实例化后以方法对象的形式调用。</p>\n<p>那么这些函数对象能被调用吗？如何获取呢？</p>\n<p><strong>实例方法对象也具有属性: <code>m.__self__</code> 就是带有 <code>m()</code> 方法的实例对象，而 <code>m.__func__</code> 则是该方法所对应的函数对象。</strong></p>\n<p>举个例子可能会更好理解，在上文代码的基础上做一些简单的修改：</p>\n<pre><code class=\"language-python\">class SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        # super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n        print(self)\n        # print(self.y)\n        \nson = SonClass()\nm = son.method\nprint(m.__self__)\nfunc = m.__func__\nprint(func('self', son_value='func_test'))\n</code></pre>\n<p>注意的是，这里修改了method方法，取消了内部所有对self的引用，至于为什么接下来会说，我们在下边调用了<code>m = son.method</code>来获取<strong>实例对象的方法对象</strong>，简称<strong>实例方法对象</strong>，输出两个属性，并通过<code>__func__</code>来获取其函数对象，最后通过<code>func('self', son_value='func_test')</code>来实现调用函数对象。</p>\n<p>输出结果如下：</p>\n<pre><code class=\"language-shell\">This is son init\n&lt;__main__.SonClass object at 0x000001526B98FA00&gt;\nson_value is func_test\nThis is a son method\nself\n</code></pre>\n<p>这里再解释一下为什么要取消self的调用，很简单函数对象并没有继承关系，也不会获取self对象到底是什么，是否是实例对象，所以这里使用字符串来作为参数，输出结果就是self字符。</p>\n<p>若果包含self参数调用，会是什么样呢？报错如下：</p>\n<pre><code class=\"language-shell\">Traceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 52, in &lt;module&gt;\n    print(func('self', son_value='func_test'))\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 33, in method\n    super(SonClass, self).method()\nTypeError: super(type, obj): obj must be an instance or subtype of type\n</code></pre>\n<h4><span id=\"252类对象amp实例对象的区别\">2.5.2类对象&amp;实例对象的区别</span></h4>\n<p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p>\n<pre><code class=\"language-python\">class Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n&gt;&gt;&gt; d = Dog('Fido')\n&gt;&gt;&gt; e = Dog('Buddy')\n&gt;&gt;&gt; d.kind                  # shared by all dogs\n'canine'\n&gt;&gt;&gt; e.kind                  # shared by all dogs\n'canine'\n&gt;&gt;&gt; d.name                  # unique to d\n'Fido'\n&gt;&gt;&gt; e.name                  # unique to e\n'Buddy'\n</code></pre>\n<p>正如 <a href=\"https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object\">名称和对象</a> 中已讨论过的，共享数据可能在涉及 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-mutable\">mutable</a> 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表,也就是说所有可变变量不应该放到类中。正如下下面的例子中：</p>\n<pre><code class=\"language-python\">class Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n&gt;&gt;&gt; d = Dog('Fido')\n&gt;&gt;&gt; e = Dog('Buddy')\n&gt;&gt;&gt; d.add_trick('roll over')\n&gt;&gt;&gt; e.add_trick('play dead')\n&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n</code></pre>\n<p>这里回到本小节开头的那句话：</p>\n<p>每个值都是一个对象，因此具有 <em>类</em> （也称为 <em>类型</em>），并存储为 <code>object.__class__</code> 。</p>\n<p>我们上文代码中的打印所有的对象的Class：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/gAqiwv28jPy4VDL.png\" alt=\"image-20231128204036052\"></p>\n<p>有趣的是Class的类型是type，这就非常有趣了，至于为什么可以参考：</p>\n<p><a href=\"https://www.zhihu.com/question/349522986\">在 Python 中，为什么 type 类对象自身的类型是 type？ - 知乎 (zhihu.com)</a></p>\n<h2><span id=\"3继承\">3.继承</span></h2>\n<p>终于讨论到最有趣的地方的了，Python是我接触的第一个动态语言和多继承语言，当然，如果不支持继承，语言特性就不值得称为“类”。单继承的语言类似Java系，继承很好理解，Python的多继承将会是我们讨论的重点，我们不妨先从单继承的视角来看它的继承。</p>\n<p>子（派生）类的语法定义如下：</p>\n<pre><code class=\"language-python\">class DerivedClassName(BaseClassName):\n    &lt;statement-1&gt;\n    .\n    .\n    .\n    &lt;statement-N&gt;\n</code></pre>\n<p>当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。这只是针对单继承的基本查找规则，多继承相对更加复杂一点，后面会着重讨论。</p>\n<h3><span id=\"31派生类的实例化\">3.1派生类的实例化</span></h3>\n<p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p>\n<p>上边的是官方的文档，实际上什么也没说，和狗屁一样，我们不如实际一点，通过几个例子来详细说明，派生类实例化会涉及到什么，应用的时候应该注意什么。</p>\n<p>3.1.1<code>__init__</code>会怎么调用?</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    def __init__(self):\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    # def __init__(self):\n    #     #super(SonClass,self).__init__()\n    #     print('This is son init')\n\n    def method(self):\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nson.method()\n</code></pre>\n<p>代码的输出：</p>\n<pre><code class=\"language-python\">This is father init\n&lt;class '__main__.SonClass'&gt;\nThis is a son method\n</code></pre>\n<p>可以看到子类初始化的时候没有显式指定<code>__init__</code>，就会默认调用父类的<code>__init__</code>。</p>\n<p>如果我们显式的指定<code>__init__</code>会有什么后果？我们将注释去掉，结果如下：</p>\n<p>注意的是这里的super行仍有注释存在。</p>\n<pre><code class=\"language-python\">This is son init\n&lt;class '__main__.SonClass'&gt;\nThis is a son method\n</code></pre>\n<p>这里就要引出<code>super()</code>方法了，这里先不说名为什么要用super()，以及super()是如何实现的，我们就先姑且把它当作父类实例的代指函数，通过他就可以调用父类的对象。</p>\n<p>我们把对应的super注释去掉，看看结果会如何：</p>\n<pre><code class=\"language-python\">This is father init\nThis is son init\n&lt;class '__main__.SonClass'&gt;\nThis is a son method\n</code></pre>\n<p>可以看到父类的<code>__init__</code>方法也被调用了。</p>\n<p>上述的内容可以一句话总结一下：</p>\n<p>子类没有显式指定的时候，会自动调用父类的init，子类显示指定的时候也要显式调用父类的init。</p>\n<p>需要补充的是，在没有显式指定的时候，父类的实例变量并无法访问，之恩那个访问到对应的父类的类变量。修改上文的代码后，来验证这个内容：</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        #super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self):\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method()\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">This is son init\n&lt;class '__main__.SonClass'&gt;\nfather class variable\nTraceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 25, in &lt;module&gt;\n    print(son.x)\nAttributeError: 'SonClass' object has no attribute 'x'\n</code></pre>\n<h3><span id=\"32派生类方法的扩展与重载\">3.2派生类方法的扩展与重载</span></h3>\n<p>重载派生类的方法很简单，只需要直接修改参数内容即可：</p>\n<p>如下代码所示，重载了对应的method方法：</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method('mother fucker')\n</code></pre>\n<p>输出结果如下：</p>\n<pre><code class=\"language-shell\">This is father init\nThis is son init\n&lt;class '__main__.SonClass'&gt;\nfather class variable\nfather variable\nson_value is mother fucker\nThis is a son method\n</code></pre>\n<p>扩展就更加简单，只需要通过super来调用父类，即可接着父类方法来实现续写：</p>\n<pre><code class=\"language-python\">    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n</code></pre>\n<p>输出结果如下：</p>\n<pre><code class=\"language-python\">father class variable\nfather variable\nThis is a father method\nson_value is mother fucker\nThis is a son method\n</code></pre>\n<h3><span id=\"33-super函数详解\">3.3 super()函数详解</span></h3>\n<p>上文中所有super的写法我都依照python2的写法来实现的，实际上python3对于super有了更简便的写法，如下所示：</p>\n<pre><code class=\"language-python\">super(SonClass, self).method()#python 2\nsuper().method()#python 3\n</code></pre>\n<p>这两个关键的参数被省略了，这对新手来说是一个很方便的事情，但是参数的省略带来信息的丢失，总是让人很迷茫，super到底的作用是什么？同时有很多python3的代码也采用了python2的写法（python3 对这个是兼容的）</p>\n<p>那么不禁让人提问 ：super是如何工作的？两个参数的作用是什么呢？</p>\n<p>super的定义如下：</p>\n<pre><code class=\"language-python\">class super(type, object_or_type=None)\n返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。\n</code></pre>\n<p>type这里只是一个参数名称，如果你要问和type有什么关系，不要忘记了所有class的类型是type，也就是说这里要填一个类对象进去。</p>\n<p>对于后一个参数的理解就更加简单了，填入一个<strong>实例对象</strong>或者<strong>类对象</strong>即可。</p>\n<p>那对这两个参数填入的内容已经有大概的了解，那么这两个参数到底有什么用？</p>\n<p>这两参数被用来实例化super类，对没错。super是一个类对象：</p>\n<pre><code class=\"language-python\">&gt;&gt;&gt;super.__class__\n&lt;class 'type'&gt;\n&gt;&gt;&gt;class A:pass\n&gt;&gt;&gt;super(A).__class__\n&lt;class 'super'&gt;\n</code></pre>\n<p>实例化之后将会返回代理对象，代理的就是他的祖先类的对象（可按照顺序调用各种祖先类对象，具体按照什么顺序稍后会解释）。它会将方法调用委托给 <em>type</em> 的父类或兄弟类。</p>\n<p><em>object_or_type</em> 确定要用于搜索的 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-method-resolution-order\">method resolution order</a>。 搜索会从 <em>type</em> 之后的类开始。</p>\n<p><strong>MRO</strong> 指的是 type(<strong>object_or_type</strong>)的 MRO, MRO 中的那个类就是 <strong>type</strong>。注意这里使用粗体的指的是参数，前边的type为python内置函数。</p>\n<p>也就是说，object_or_type用于确定在哪一颗祖先树上进行搜索，因为Python是多继承的(这里还没有讲多继承是如何实现的，不过没关系，可以从真实世界的族谱上理解一下)，所以其继承关系会构建出来一颗祖先树。</p>\n<p>在早期python的经典类结构，也就是python2中MRO遵循的是从左到右，深度优先，但是在2.2版本后多继承遵循了C3算法，详细可参考：<a href=\"https://www.python.org/download/releases/2.3/mro/\">The Python 2.3 Method Resolution Order | Python.org</a>里面详细论述了python是如何实现MRO，考虑到文章的长度，在以后会单独写一篇关于继承顺序的文章，这里可以先看一下参考文献。</p>\n<p>举一个简单的例子：</p>\n<p>For example, if <a href=\"https://docs.python.org/3/library/stdtypes.html#class.__mro__\"><code>__mro__</code></a> of <em>object_or_type</em> is <code>D -&gt; B -&gt; C -&gt; A -&gt; object</code> and the value of <em>type</em> is <code>B</code>, then <a href=\"https://docs.python.org/3/library/functions.html#super\"><code>super()</code></a> searches <code>C -&gt; A -&gt; object</code>。</p>\n<p>想要了解某一个类的MRO情况可以通过__mro__属性来获取：</p>\n<pre><code class=\"language-python\">print(SonClass.__mro__)\n输出：\n(&lt;class '__main__.SonClass'&gt;, &lt;class '__main__.FatherClass'&gt;, &lt;class '__main__.UncleClass'&gt;, &lt;class 'object'&gt;)\n</code></pre>\n<p>这里再介绍一下两个内置函数，这两个内置函数用来测试是否满足的super的参数条件。</p>\n<ul>\n<li>使用 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#isinstance\"><code>isinstance()</code></a> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 或某个派生自 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 的类时为 <code>True</code>。简单来说作用是检测实例是否是某一个类子类的实例对象。</li>\n<li>使用 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#issubclass\"><code>issubclass()</code></a> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#bool\"><code>bool</code></a> 是 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#float\"><code>float</code></a> 不是 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 的子类。 检测class对象是否为某一个类对象的子类。</li>\n</ul>\n<p>实际上super的参数还有另一种情况，当object_or_type 输入类型也是type的时候，就需要满足issubclass为true的条件，这时候super的调用就成了这样：</p>\n<pre><code class=\"language-python\">super(type1, type2)\n</code></pre>\n<p>MRO 指的是 <strong>type2</strong> 的 <strong>MRO</strong>, <strong>MRO</strong> 中的那个类就是 <strong>type1</strong> ，同时 <strong>issubclass(type2, type1) == True</strong> 。</p>\n<p>那么， <strong>super()</strong> 实际上做了啥呢？简单来说就是：提供一个 <strong>MRO</strong> 以及一个 <strong>MRO</strong> 中的类 <strong>C</strong> ， <strong>super()</strong> 将返回一个从 <strong>MRO</strong> 中 <strong>C</strong> 之后的类中查找方法的对象。</p>\n<p>那是不是意味着我们也可以这样写，写了之后会有什么效果呢？</p>\n<p>这样调用会有什么结果呢？我们再举一个例子，在上文的代码中扩充添加一个TestClass类，他是最底层的类，是所有类的子类：</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(\"This is a father method\")\n\n    def function():\n        print('This is a father function')\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n\n\nclass TestClass(SonClass):\n    def __init__(self):\n        super().__init__()\n\n    def metod(self):\n        pass\n\n</code></pre>\n<p>然后进行调用：</p>\n<pre><code class=\"language-python\">son = SonClass()\nprint(super(SonClass, TestClass).y)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-shell\">This is father init\nThis is son init\nfather class variable\n</code></pre>\n<p>可以看到他直接找到了父类作为调用对象，并输出了对应的y属性，需要注意的是这里无法针对方法对象来实现，原因很简单，并没有self参数作为载体，来进行方法的调用。记住上文说的：<strong>任何一个作为类属性的函数都为该类的实例定义了一个相应方法</strong>。不能把它作为函数对象来调用。</p>\n<h3><span id=\"34私有变量\">3.4私有变量</span></h3>\n<p>那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。这也算是设计特点， 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p>\n<p>但是这样并不是很有效的操作，例如避免名称与子类所定义的名称相冲突，即使去使用 <code>_spam</code>的形式也是不合理的，子类仍能继承到，因此Python存在一个机制，叫做<strong>名称改写</strong>。</p>\n<h3><span id=\"341名称改写\">3.4.1名称改写</span></h3>\n<p>形式为 <code>__spam</code> 的标识符，至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。</p>\n<p>这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p>\n<p>举个例子：如何使用私有变量进行解耦合</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.method()\n\n    def method(self):\n        print(\"This is a father method\")\n</code></pre>\n<p>可以看到 父类这里的init和method进行了耦合，init依赖于 method。产生了耦合</p>\n<p>子类继承的时候无法重写method方法，如果重写了就会报错：</p>\n<p>子类定义如下：</p>\n<pre><code class=\"language-python\">class SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(\"This is a son method\")\n</code></pre>\n<p>报错信息如下：</p>\n<pre><code class=\"language-shell\">Traceback (most recent call last):\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 33, in &lt;module&gt;\n    son = SonClass()\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 16, in __init__\n    super(SonClass, self).__init__()\n  File \"D:\\SafeZone\\PythonProjects\\ICS_4\\main.py\", line 7, in __init__\n    self.method()\nTypeError: SonClass.method() missing 1 required positional argument: 'son_value'\nThis is father init\n</code></pre>\n<p>如何进行解耦合呢？</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.__method()\n\n    def method(self):\n        print(\"This is a father method\")\n\n    __method = method\n</code></pre>\n<p>修改父类如上，使用名称改写来实现其解耦，子类无法直接调用到方法__y，实际上被替换为<code>_FatherClass__method()</code> ,不要没事调用他。</p>\n<p>上面的示例即使在 <code>SonClass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>FatherClass</code> 类中被替换为 <code>_FatherClass__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p>\n<h2><span id=\"4dataclass\">4.dataclass</span></h2>\n<p>有时候需要一些数据类型类似C的struct结构的，需要糅合一部分数据在一起，Python提供了预实现模块<strong>dataclasses</strong>，</p>\n<p>我们引用就可以了，举个例子：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\n\n@dataclass\nclass Chinese:\n    name: str\n    money: str\n    appearance: str\n    theone:bool\n</code></pre>\n<p>如何使用呢？</p>\n<pre><code class=\"language-python\">neonexus = Chinese('neonexus',money=0,appearance='normal',theone=False)\nprint(neonexus.theone)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-python\">&lt;super: &lt;class 'SonClass'&gt;, &lt;TestClass object&gt;&gt;\nFalse\n</code></pre>\n<h1><span id=\"参考文章\">参考文章：</span></h1>\n<p><a href=\"https://rhettinger.wordpress.com/2011/05/26/super-considered-super/\">Python’s super() considered super! | Deep Thoughts by Raymond Hettinger (wordpress.com)</a></p>\n<p><a href=\"https://sixty-north.com/blog/pythons-super-not-as-simple-as-you-thought.html\">Good With Computers (sixty-north.com)</a></p>\n<p><a href=\"https://www.runoob.com/w3cnote/python-super-detail-intro.html\">Python super 详解 | 菜鸟教程 (runoob.com)</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__\">3. 数据模型 — Python 3.12.0 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/2.7/reference/datamodel.html?highlight=__init__#object.__init__\">3. 数据模型 — Python 2.7.18 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/3/library/functions.html#super\">内置函数 — Python 3.12.0 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/3/tutorial/classes.html\">9. 类 — Python 3.12.0 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/2.7/tutorial/classes.html\">9. 类 — Python 2.7.18 文档</a></p>\n","more":"<h1>Python类基础筑基（1）————面对对象</h1>\n<img src=\"https://s2.loli.net/2023/11/30/9ktxJMd1G5perfh.jpg\" alt=\"zXu5EpoCmKH8FiJ\" style=\"zoom:67%;\" />\n<img src=\"https://s2.loli.net/2023/12/01/WpEDI6ayQt5zbM9.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1701391443259\" style=\"zoom:67%;\" />\n<p>本文以Python3主要为主，穿插2.7的信息，如无特别说明默认为Python3</p>\n<p>[TOC]</p>\n<h2 id=\"1-Python的命名空间与作用域\">1.Python的命名空间与作用域</h2>\n<h3 id=\"1-1命名空间（namespace）\">1.1命名空间（namespace）</h3>\n<p><em>namespace</em> （命名空间）是从名称到对象的映射。现在，大多数命名空间都使用 Python 字典实现，但除非涉及到性能优化，我们一般不会关注这方面的事情，而且将来也可能会改变这种方式。命名空间的例子有：内置名称集合（包括 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#abs\"><code>abs()</code></a> 函数以及内置异常的名称等）；一个模块的全局命名空间；一个函数调用中的局部命名空间。对象的属性集合也是命名空间的一种形式。</p>\n<p>命名空间是在不同时刻创建的，且拥有不同的生命周期。下边列出来四种常见的命名空间的简单介绍：</p>\n<ul>\n<li>内置名称的命名空间是在 Python 解释器启动时创建的，永远不会被删除。内置名称实际上也在模块里，即 <a href=\"https://docs.python.org/zh-cn/3/library/builtins.html#module-builtins\"><code>builtins</code></a> 。</li>\n<li>模块的全局命名空间在读取模块定义时创建；通常，模块的命名空间也会持续到解释器退出。</li>\n<li>从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 <a href=\"https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__\"><code>__main__</code></a> 模块调用的一部分，也拥有自己的全局命名空间。</li>\n<li>函数的局部命名空间在函数被调用时被创建，并在函数返回或抛出未在函数内被处理的异常时，被删除。（实际上，用“遗忘”来描述实际发生的情况会更好一些。）当然，每次递归调用都有自己的局部命名空间。</li>\n</ul>\n<p>上述内容代表了常见的四种命名空间：内置命名空间、全局命名空间、main模块命名空间、函数的命名空间。实际上main也应该算作一种全局命名空间，只是他相对特殊这里单列出来。</p>\n<p>“从脚本文件读取或交互式读取的，由解释器顶层调用执行的语句是 <a href=\"https://docs.python.org/zh-cn/3/library/__main__.html#module-__main__\"><code>__main__</code></a> 模块调用的一部分，也拥有自己的全局命名空间” 这句话该如何理解呢？什么是main模块自己的全局命名空间？</p>\n<p>这里可以参考一下python官方文档的解释：</p>\n<p>在 Python 中，特殊名称 <code>__main__</code> 用于两个重要的构造：</p>\n<ol>\n<li>程序的顶层环境的名称，可以使用 <code>__name__ == '__main__'</code> 表达式进行检查；</li>\n<li>Python 包中的 <code>__main__.py</code> 文件。</li>\n</ol>\n<p>这两种机制都与 Python 模块有关，涉及用户如何与模块互动以及模块之间如何互动。下面详细解释了它们的作用。如果你是 Python 模块的新手，请参阅教程部分 <a href=\"https://docs.python.org/3/tutorial/modules.html#tut-modules\">Modules</a> 以进行介绍。</p>\n<p><code>__main__</code> 是顶层代码运行的环境名称。所谓的 “顶层代码” 是指开始运行的第一个用户指定的 Python 模块。它之所以被称为 “顶层”，是因为它导入了程序所需的所有其他模块。有时 “顶层代码” 也被称为应用程序的 <em>入口点</em>。</p>\n<p>顶层代码环境可以是：</p>\n<ul>\n<li>\n<p>交互式提示符的作用域：</p>\n<pre><code>pythonCopy code&gt;&gt;&gt; __name__\n'__main__'\n</code></pre>\n</li>\n<li>\n<p>作为文件参数传递给 Python 解释器的 Python 模块：</p>\n<pre><code>pythonCopy code$ python helloworld.py\nHello, world!\n</code></pre>\n</li>\n<li>\n<p>使用 <a href=\"https://docs.python.org/3/using/cmdline.html#cmdoption-m\"><code>-m</code></a> 参数传递给 Python 解释器的 Python 模块或包：</p>\n<pre><code>pythonCopy code$ python -m tarfile\nusage: tarfile.py [-h] [-v] (...)\n</code></pre>\n</li>\n<li>\n<p>从标准输入中读取的 Python 代码：</p>\n<pre><code>pythonCopy code$ echo &quot;import this&quot; | python\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\n...\n</code></pre>\n</li>\n<li>\n<p>使用 <a href=\"https://docs.python.org/3/using/cmdline.html#cmdoption-c\"><code>-c</code></a> 参数传递给 Python 解释器的 Python 代码：</p>\n<pre><code>pythonCopy code$ python -c &quot;import this&quot;\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\n...\n</code></pre>\n</li>\n</ul>\n<p>在每一种情况下，顶层模块的 <code>__name__</code> 被设置为 <code>'__main__'</code>。</p>\n<p>因此，一个模块可以通过检查自己的 <code>__name__</code> 来发现它是否在顶层环境中运行，这允许一种常见的习惯用法，用于在模块未从导入语句初始化时有条件地执行代码：</p>\n<pre><code>pythonCopy codeif __name__ == '__main__':\n    # 当模块未从导入语句初始化时执行。\n    ...\n</code></pre>\n<pre><code class=\"language-python\">if __name__ == '__main__':\n    # Execute when the module is not initialized from an import statement.\n    ...\n</code></pre>\n<p>这意味着如果脚本文件被直接运行（而不是被导入为模块），那么其中的代码将作为主程序执行，即被解释器顶层调用执行。这是Python中的一种约定，用于标识脚本的主要入口点。</p>\n<h3 id=\"1-2作用域（scope）\">1.2作用域（scope）</h3>\n<p>一个命名空间的 <em>作用域</em> 是 Python 代码中的一段文本区域（textual region），<strong>从这个区域可直接访问该命名空间</strong>。“可直接访问”的意思是，该文本区域内的名称在被非限定引用时，查找名称的范围，是包括该命名空间在内的。</p>\n<p>作用域是按字面文本（textual region）确定的解释：模块内定义的函数的全局作用域就是该模块的命名空间，无论该函数从什么地方或以什么别名被调用。另一方面，实际的名称搜索是在运行时动态完成的。但是，Python 正在朝着“编译时静态名称解析”的方向发展，因此不要过于依赖动态名称解析！（局部变量已经是被静态确定了。）</p>\n<p>作用域虽然是被静态确定的，但会被动态使用。执行期间的任何时刻，都会有 3 或 4 个“命名空间可直接访问”的嵌套作用域：</p>\n<ul>\n<li>最内层作用域，包含局部名称，并首先在其中进行搜索</li>\n<li>那些外层闭包函数的作用域，包含“非局部、非全局”的名称，从最靠内层的那个作用域开始，逐层向外搜索。</li>\n<li>倒数第二层作用域，包含当前模块的全局名称</li>\n<li>最外层（最后搜索）的作用域，是内置名称的命名空间</li>\n</ul>\n<p>如果一个名称被声明为全局，则所有引用和赋值都将直接指向“倒数第二层作用域”，即包含模块的全局名称的作用域。</p>\n<h3 id=\"1-3关于作用域和命名空间的混淆点\">1.3关于作用域和命名空间的混淆点</h3>\n<p>命名空间：名称(name)及其所引用对象(object)的集合。python使用dictionary来表示命名空间，key对应名称(name)，value为名称所对应的对象(object)。</p>\n<p>实际上命名空间是一种映射关系的具体实现，在python中以dictionary来实现，其存储了具体的映射关系。</p>\n<p>而作用域是在命名空间的基础上所遵循的规则信息。其规定了我们的程序将查看哪些命名空间（中的名称）及以顺序。</p>\n<h3 id=\"1-1-4作用域的具体例子（global-nonlocal）\">1.1.4作用域的具体例子（global &amp; nonlocal）</h3>\n<p>如果程序执行时去使用一个变量 hello ，那么 Python， 查找变量顺序为：</p>\n<p><strong>局部的命名空间 -&gt; 全局命名空间 -&gt; 内置命名空间</strong></p>\n<p>如果按照这个顺序找不到相应的变量，它将放弃查找并抛出一个 NameError 异常：</p>\n<pre><code class=\"language-shell\">NameError: name 'hello' is not defined。\n</code></pre>\n<p>Python 有一个特殊规定。如果不存在生效的 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 或 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句，则对名称的赋值总是会进入最内层作用域。赋值不会复制数据，只是将名称绑定到对象。删除也是如此：语句 <code>del x</code> 从局部作用域引用的命名空间中移除对 <code>x</code> 的绑定。所有引入新名称的操作都是使用局部作用域：尤其是 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import\"><code>import</code></a> 语句和函数定义会在局部作用域中绑定模块或函数名称。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 语句用于表明特定变量在全局作用域里，并应在全局作用域中重新绑定；<a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句表明特定变量在外层作用域中，并应在外层作用域中重新绑定。</p>\n<p>摘两段关于global和nonlocal的定义：</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 语句是作用于整个当前代码块的声明。 它意味着所列出的标识符将被解读为全局变量。 要给全局变量赋值不可能不用到 <code>global</code> 关键字，不过自由变量也可以指向全局变量而不必声明为全局变量。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句会使得所列出的名称指向之前在最近的包含作用域中绑定的<strong>除全局变量以外的变量</strong>。与 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#global\"><code>global</code></a> 语句中列出的名称不同，<a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句中列出的名称必须指向之前存在于包含作用域之中的绑定（在这个应当用来创建新绑定的作用域不能被无歧义地确定）。</p>\n<p>要重新绑定在最内层作用域以外的变量，可以使用 <a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句；如果未使用 nonlocal 声明，这些变量将为只读（尝试写入这样的变量将在最内层作用域中创建一个 <em>新的</em> 局部变量，而使得同名的外部变量保持不变）。</p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/simple_stmts.html#nonlocal\"><code>nonlocal</code></a> 语句中列出的名称不得与之前存在于局部作用域中的绑定相冲突。</p>\n<p>这句话看起来很难理解，不过没关系，下面的例子很好的解释了这个问题：</p>\n<pre><code class=\"language-python\">def scope_test():\n\n    def do_nonlocal():\n        spam = &quot;do_nonlocal spam&quot;\n        nonlocal spam\n        spam = &quot;nonlocal spam&quot;\n        \n    spam = &quot;test spam&quot;\n    do_nonlocal()\n    print(&quot;After nonlocal assignment:&quot;, spam)\n\nscope_test()\n</code></pre>\n<p><img src=\"https://s2.loli.net/2023/11/28/hmzu2dqKHFP83yS.png\" alt=\"image-20231128130324612\"></p>\n<p>可以看到<code>nonlocal</code>不能绑定已经绑定过的局部变量，这里使用‘绑定’这个词是有原因的，可以看一下下边的内容。</p>\n<h4 id=\"扩展：名称和对象\">扩展：名称和对象</h4>\n<p>对于Python来说所有内容都是对象，对象之间相互独立，多个名称（甚至是多个作用域内的多个名称）可以绑定到同一对象。这在其他语言中通常被称为别名。Python 初学者通常不容易理解这个概念，处理数字、字符串、元组等不可变基本类型时，可以不必理会。</p>\n<p>但是，对于涉及可变对象（如列表、字典，以及大多数其他类型）的 Python 代码的语义，别名可能会产生意料之外的效果。这样做，通常是为了让程序受益，因为别名在某些方面就像指针。例如，传递对象的代价很小，因为实现只传递一个指针。</p>\n<p>我们通过以下的例子来综合解释一下如何使用global &amp; nonlocal：</p>\n<pre><code class=\"language-python\">def scope_test():\n    def do_local():\n        spam = &quot;local spam&quot;\n\n    def do_nonlocal():\n        nonlocal spam\n        spam = &quot;nonlocal spam&quot;\n\n    def do_global():\n        global spam\n        spam = &quot;global spam&quot;\n\n    spam = &quot;test spam&quot;\n    do_local()\n    print(&quot;After local assignment:&quot;, spam)\n    do_nonlocal()\n    print(&quot;After nonlocal assignment:&quot;, spam)\n    do_global()\n    print(&quot;After global assignment:&quot;, spam)\n\nscope_test()\nprint(&quot;In global scope:&quot;, spam)\n</code></pre>\n<p>示例代码的输出是：</p>\n<pre><code class=\"language-shell\">After local assignment: test spam\nAfter nonlocal assignment: nonlocal spam\nAfter global assignment: nonlocal spam\nIn global scope: global spam\n</code></pre>\n<p>在调用<code>scope_test</code>之后，会先创建一个在<code>scope_test</code>函数作用域之内的<code>spam</code>变量其作用域是在<code>scope_test</code>函数的局部变量里面，这时候调用<code>do_local()</code>函数其将<code>do_local()</code>函数小局部作用域中的spam通过nonlocal关键字绑定到了上一个局部作用域中，并进行了赋值，这时上一个局部作用域中的spam被赋值修改了绑定关系。所以输出结果从<code>test spam</code>变化成为了<code>nonlocal spam</code>。</p>\n<p>需要注意的是<code>do_global()</code>函数将在全局一个不存在的spam进行了绑定，相当于在局部变量中创建了全局变量，这是比较特殊的。</p>\n<h2 id=\"2-面对对象与类\">2.面对对象与类</h2>\n<h3 id=\"2-1Python的面对对象\">2.1Python的面对对象</h3>\n<p>最简单的类定义形式如下：</p>\n<pre><code class=\"language-python\">class ClassName:\n    &quot;&quot;&quot;class help doc&quot;&quot;&quot;\n    &lt;statement-1&gt;\n    .\n    .\n    .\n    &lt;statement-N&gt;\n</code></pre>\n<p>当进入类定义时，将创建一个新的<strong>命名空间</strong>，并将其用作<strong>局部作用域</strong>，因此，所有对局部变量的赋值都是在这个新<strong>命名空间</strong>之内。</p>\n<p>类的帮助信息可以通过ClassName.__ doc __查看。</p>\n<p>特别的，函数定义会绑定到这里的新函数名称。也就是会将里面的函数定义绑定到对应的函数名称，完成函数的创建。</p>\n<p>当 (从结尾处) 正常离开类定义时，将创建一个 <em><strong>类对象</strong></em>。 这基本上是一个围绕类定义所创建的命名空间的包装器；至于什么是包装器，包装器的作用是什么，这个以后再讨论。</p>\n<p>原始 (在进入类定义之前有效的) 作用域将重新生效，<strong>类对象</strong>将在这里与类定义头所给出的类名称进行绑定 (在这个示例中为 <code>ClassName</code>)。</p>\n<p>这里需要关注的是类其实也是一个对象，<strong>类对象也是对象的一种。在创建的结束将类名和类对象进行绑定</strong>。</p>\n<h3 id=\"2-2类对象\">2.2类对象</h3>\n<p>类对象支持两种操作：属性引用和实例化。</p>\n<h4 id=\"2-2-1属性引用\">2.2.1属性引用</h4>\n<p>使用 Python 中所有属性引用所使用的标准语法: <code>obj.name</code>。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的:</p>\n<pre><code class=\"language-python\">class MyClass:\n    &quot;&quot;&quot;A simple example class&quot;&quot;&quot;\n    i = 12345\n\n    def f(self):\n        return 'hello world'\n</code></pre>\n<p>那么 <code>MyClass.i</code> 和 <code>MyClass.f</code> 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 <code>MyClass.i</code> 的值。 有趣的是这样的内容在java系语言中被定为静态属性，其生命周期不会随着类的实例化所变化。</p>\n<p><code>__doc__</code> 也是一个有效的属性，将返回所属类的文档字符串: <code>&quot;A simple example class&quot;</code>。</p>\n<h4 id=\"2-2-2实例化\">2.2.2实例化</h4>\n<p>类对象的实例化功能实际上就是其他语言的创建类的实例对象，需要注意的是<strong>实例对象</strong>和<strong>类对象</strong>是两个不同的概念，后面会详细介绍二者的区别。</p>\n<p>类的 <em>实例化</em> 使用函数表示法。 可以把类对象视为是返回该类的一个新实例的不带参数的函数。常见的形式如下：</p>\n<pre><code class=\"language-python\">对象变量 = 类名()\nx = MyClass()\n</code></pre>\n<p>创建类的新 <em>实例</em> 并将此对象分配给局部变量 <code>x</code>。</p>\n<p>上述实例化操作 (“调用”类对象) 会创建一个空对象。 许多类都希望创建的对象实例是根据特定初始状态定制的。</p>\n<p>因此一个类可能会定义名为 <a href=\"https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__\"><code>__init__()</code></a> 的特殊方法，就像这样:</p>\n<pre><code class=\"language-python\">def __init__(self):\n    self.data = []\n</code></pre>\n<p>当一个类定义了 <code>__init__()</code>方法时，类的实例化会自动为新创建的类实例发起调用 <code>__init__()</code>。 因此在这个例子中，可以通过以下语句获得一个已初始化的新实例:</p>\n<pre><code class=\"language-python\">x = MyClass()\n</code></pre>\n<p>Example：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/W9kIqAGpDdoZjh6.png\" alt=\"image-20231128173030208\"></p>\n<h3 id=\"2-3实例对象\">2.3实例对象</h3>\n<p>实例对象所能理解的唯一操作是属性引用。 有两种有效的属性名称：数据属性和方法。</p>\n<h4 id=\"2-3-1数据属性\">2.3.1数据属性</h4>\n<p>数据属性就是java中的成员属性，需要注意的是pyhton是一门动态的语言， 数据属性不需要声明；就像局部变量一样，它们将在首次被赋值时产生。且在操作过程中可进行删除操作，删除一个实例对象的数据属性。这是其他静态语言所难以企及的。</p>\n<p>下面举个例子，在上文的基础上进行修改：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/c9XjiGlNACIKs42.png\" alt=\"image-20231128174245657\"></p>\n<p>只能说python过于自由了。哈哈哈。</p>\n<h4 id=\"2-3-2方法\">2.3.2方法</h4>\n<p>另一类实例属性引用称为 <strong>方法</strong>。 方法是<strong>从属于</strong>对象的函数。 （在 Python 中，方法这个术语并不是类实例所特有的：其他对象也可以有方法。 例如，列表对象具有 append, insert, remove, sort 等方法。 然而，在以下讨论中，我们使用方法一词将专指类实例对象的方法，除非另外显式地说明）</p>\n<p>实例对象的有效方法名称依赖于其所属的类。 根据定义，一个类中所有是函数对象的属性都是其实例的相应方法。</p>\n<p>因此在我们的示例中，<code>x.f</code> 是有效的方法引用，因为 <code>MyClass.f</code> 是一个函数，而 <code>x.i</code> 不是方法，因为 <code>MyClass.i</code> 不是函数。 但是 <code>x.f</code> 与 <code>MyClass.f</code> 并不是一回事 — 它是一个 <strong>方法对象</strong>，不是<strong>函数对象</strong>。</p>\n<p>这里让人难以理解的就是什么。为什么方法也是对象，对于函数对象还是比较好理解的，就像变量对象一样，是基础的对象类型，那么什么是方法对象呢？</p>\n<h3 id=\"2-4方法对象\">2.4方法对象</h3>\n<p>这里在上文的对象中添加一个<code>f()</code>方法，代码如下：</p>\n<pre><code class=\"language-python\">class Complex:\n    def __init__(self,realpart , imagpart):\n        self.r = realpart\n        self.i = imagpart\n    def f(self):\n        return 'hello world'\n</code></pre>\n<p>添加完成以后，Complex对象就有了方法对象，可以通过实例对象来进行引用，如下图所示，它不仅可以在实例对象中进行引用同时也可以将其存储起来，存储对象在xf中，xf就相当于方法的别名，可以看到二者指向的对象是相同。</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/JmHpSQNYbOwdLt3.png\" alt=\"image-20231128193553688\"></p>\n<h3 id=\"2-5方法对象-函数对象的区别、类对象-实例对象的区别\">2.5方法对象&amp;函数对象的区别、类对象&amp;实例对象的区别</h3>\n<h4 id=\"2-5-1方法对象-函数对象的区别\">2.5.1方法对象&amp;函数对象的区别</h4>\n<p>在官方的文档中有这样一句话：</p>\n<p>Each value is an object, and therefore has a <em>class</em> (also called its <em>type</em>). It is stored as <code>object.__class__</code>.</p>\n<p>对于方法对象和函数对象来说而这最大的区别就在于使用方法上，我们可以注意到：</p>\n<p><code>f()</code> 的函数定义指定了一个参数，但上面调用 <code>x.f()</code> 时却没有带参数。 这个参数发生了什么事？ 当一个需要参数的函数在不附带任何参数的情况下被调用时 Python 肯定会引发异常 — 即使参数实际上没有被使用…</p>\n<p>实际上，你可能已经猜到了答案：方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 <code>x.f()</code> 其实就相当于 <code>MyClass.f(x)</code>。</p>\n<p>我们可以构建一个例子关于f的直接引用和实例对象的方法引用，如下代码所展示的</p>\n<pre><code class=\"language-python\">&gt;&gt;&gt;y = Complex.f\n&gt;&gt;&gt;y\n&lt;function Complex.f at 0x000002A8D1C23910&gt;\n</code></pre>\n<p>可以看到直接使用类对象的f引用结果变成了一个函数对象。图像右侧可以看到</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/Fi3L5f7CmOhurPk.png\" alt=\"image-20231128200522921\"></p>\n<p>那如果我们打印一个上文中<code>x.f</code>呢？</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/oZXjEUHLR51MO79.png\" alt=\"image-20231128200731043\"></p>\n<p>这就是二者的核心区别，如果我们直接调用y，他就会因为缺少参数而无法运行：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/zl25Kf9Cs4bxdwI.png\" alt=\"image-20231128200824816\"></p>\n<p>当然到这里你会更迷惑了，那么一个实例的方法的调用过程是什么呢？</p>\n<p>当对实例对象进行属性引用时，如果该属性在实例中无法找到，将搜索实例所属的类。如果被引用的属性名称表示一个有效的类属性中的函数对象，会打包两者（实例对象和查找到的函数对象）的指针到一个抽象对象，这个抽象对象就是方法对象。当用参数列表调用方法对象时，将基于实例对象和参数列表构建一个新的参数列表，并用这个新参数列表调用相应的函数对象。</p>\n<p>也就是说你本质上调用的是新参数列表的函数对象，当直接调用的时候新参数列表中没有实例对象（self实际上代之的是实例对象自己）而无法运行。</p>\n<p>这也是类对象&amp;实例对象的区别，实际上二者底层实现不一样，功能不同。</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/5PotQHXh6DyxgWY.png\" alt=\"image-20231128201202962\"></p>\n<p>可以看到Complex自己代表了一个命名空间，和x并不相同。</p>\n<p><strong>任何一个作为类属性的函数都为该类的实例定义了一个相应方法</strong>。 <strong>注意的是这里是任何，也就是说任何符合带有self参数的引用的都只能作为方法来使用，这句话下面会解释</strong>。函数定义的文本并非必须包含于类定义之内：将一个函数对象赋值给一个局部变量也是可以的。 例如，下面的代码实现了一个函数并将其添加到了类中：</p>\n<pre><code class=\"language-python\"># Function defined outside the class\ndef f1(self, x, y):\n    return min(x, x+y)\n\nclass C:\n    f = f1\n\n    def g(self):\n        return 'hello world'\n\n    h = g\n</code></pre>\n<p>现在 <code>f</code>、<code>g</code> 和 <code>h</code> 都 <code>C</code> 类的指向函数对象的属性，因此它们都是 <code>C</code> 实例的方法 — 其中 <code>h</code> 与 <code>g</code> 完全等价。 但请注意这种做法通常只会使程序的阅读者感到迷惑，这里只是展示其完全相同的结果。</p>\n<p>也就是说在类空间中定义的函数对象，被转化成为了方法。实例化后以方法对象的形式调用。</p>\n<p>那么这些函数对象能被调用吗？如何获取呢？</p>\n<p><strong>实例方法对象也具有属性: <code>m.__self__</code> 就是带有 <code>m()</code> 方法的实例对象，而 <code>m.__func__</code> 则是该方法所对应的函数对象。</strong></p>\n<p>举个例子可能会更好理解，在上文代码的基础上做一些简单的修改：</p>\n<pre><code class=\"language-python\">class SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        # super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(&quot;This is a son method&quot;)\n        print(self)\n        # print(self.y)\n        \nson = SonClass()\nm = son.method\nprint(m.__self__)\nfunc = m.__func__\nprint(func('self', son_value='func_test'))\n</code></pre>\n<p>注意的是，这里修改了method方法，取消了内部所有对self的引用，至于为什么接下来会说，我们在下边调用了<code>m = son.method</code>来获取<strong>实例对象的方法对象</strong>，简称<strong>实例方法对象</strong>，输出两个属性，并通过<code>__func__</code>来获取其函数对象，最后通过<code>func('self', son_value='func_test')</code>来实现调用函数对象。</p>\n<p>输出结果如下：</p>\n<pre><code class=\"language-shell\">This is son init\n&lt;__main__.SonClass object at 0x000001526B98FA00&gt;\nson_value is func_test\nThis is a son method\nself\n</code></pre>\n<p>这里再解释一下为什么要取消self的调用，很简单函数对象并没有继承关系，也不会获取self对象到底是什么，是否是实例对象，所以这里使用字符串来作为参数，输出结果就是self字符。</p>\n<p>若果包含self参数调用，会是什么样呢？报错如下：</p>\n<pre><code class=\"language-shell\">Traceback (most recent call last):\n  File &quot;D:\\SafeZone\\PythonProjects\\ICS_4\\main.py&quot;, line 52, in &lt;module&gt;\n    print(func('self', son_value='func_test'))\n  File &quot;D:\\SafeZone\\PythonProjects\\ICS_4\\main.py&quot;, line 33, in method\n    super(SonClass, self).method()\nTypeError: super(type, obj): obj must be an instance or subtype of type\n</code></pre>\n<h4 id=\"2-5-2类对象-实例对象的区别\">2.5.2类对象&amp;实例对象的区别</h4>\n<p>一般来说，实例变量用于每个实例的唯一数据，而类变量用于类的所有实例共享的属性和方法:</p>\n<pre><code class=\"language-python\">class Dog:\n\n    kind = 'canine'         # class variable shared by all instances\n\n    def __init__(self, name):\n        self.name = name    # instance variable unique to each instance\n\n&gt;&gt;&gt; d = Dog('Fido')\n&gt;&gt;&gt; e = Dog('Buddy')\n&gt;&gt;&gt; d.kind                  # shared by all dogs\n'canine'\n&gt;&gt;&gt; e.kind                  # shared by all dogs\n'canine'\n&gt;&gt;&gt; d.name                  # unique to d\n'Fido'\n&gt;&gt;&gt; e.name                  # unique to e\n'Buddy'\n</code></pre>\n<p>正如 <a href=\"https://docs.python.org/zh-cn/3/tutorial/classes.html#tut-object\">名称和对象</a> 中已讨论过的，共享数据可能在涉及 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-mutable\">mutable</a> 对象例如列表和字典的时候导致令人惊讶的结果。 例如以下代码中的 <em>tricks</em> 列表不应该被用作类变量，因为所有的 <em>Dog</em> 实例将只共享一个单独的列表,也就是说所有可变变量不应该放到类中。正如下下面的例子中：</p>\n<pre><code class=\"language-python\">class Dog:\n\n    tricks = []             # mistaken use of a class variable\n\n    def __init__(self, name):\n        self.name = name\n\n    def add_trick(self, trick):\n        self.tricks.append(trick)\n\n&gt;&gt;&gt; d = Dog('Fido')\n&gt;&gt;&gt; e = Dog('Buddy')\n&gt;&gt;&gt; d.add_trick('roll over')\n&gt;&gt;&gt; e.add_trick('play dead')\n&gt;&gt;&gt; d.tricks                # unexpectedly shared by all dogs\n['roll over', 'play dead']\n</code></pre>\n<p>这里回到本小节开头的那句话：</p>\n<p>每个值都是一个对象，因此具有 <em>类</em> （也称为 <em>类型</em>），并存储为 <code>object.__class__</code> 。</p>\n<p>我们上文代码中的打印所有的对象的Class：</p>\n<p><img src=\"https://s2.loli.net/2023/11/28/gAqiwv28jPy4VDL.png\" alt=\"image-20231128204036052\"></p>\n<p>有趣的是Class的类型是type，这就非常有趣了，至于为什么可以参考：</p>\n<p><a href=\"https://www.zhihu.com/question/349522986\">在 Python 中，为什么 type 类对象自身的类型是 type？ - 知乎 (zhihu.com)</a></p>\n<h2 id=\"3-继承\">3.继承</h2>\n<p>终于讨论到最有趣的地方的了，Python是我接触的第一个动态语言和多继承语言，当然，如果不支持继承，语言特性就不值得称为“类”。单继承的语言类似Java系，继承很好理解，Python的多继承将会是我们讨论的重点，我们不妨先从单继承的视角来看它的继承。</p>\n<p>子（派生）类的语法定义如下：</p>\n<pre><code class=\"language-python\">class DerivedClassName(BaseClassName):\n    &lt;statement-1&gt;\n    .\n    .\n    .\n    &lt;statement-N&gt;\n</code></pre>\n<p>当构造类对象时，基类会被记住。 此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找。 如果基类本身也派生自其他某个类，则此规则将被递归地应用。这只是针对单继承的基本查找规则，多继承相对更加复杂一点，后面会着重讨论。</p>\n<h3 id=\"3-1派生类的实例化\">3.1派生类的实例化</h3>\n<p>派生类的实例化没有任何特殊之处: <code>DerivedClassName()</code> 会创建该类的一个新实例。 方法引用将按以下方式解析：搜索相应的类属性，如有必要将按基类继承链逐步向下查找，如果产生了一个函数对象则方法引用就生效。</p>\n<p>上边的是官方的文档，实际上什么也没说，和狗屁一样，我们不如实际一点，通过几个例子来详细说明，派生类实例化会涉及到什么，应用的时候应该注意什么。</p>\n<p>3.1.1<code>__init__</code>会怎么调用?</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    def __init__(self):\n        print('This is father init')\n\n    def method(self):\n        print(&quot;This is a father method&quot;)\n\n\nclass SonClass(FatherClass):\n\n    # def __init__(self):\n    #     #super(SonClass,self).__init__()\n    #     print('This is son init')\n\n    def method(self):\n        print(&quot;This is a son method&quot;)\n\n\nson = SonClass()\nprint(son.__class__)\nson.method()\n</code></pre>\n<p>代码的输出：</p>\n<pre><code class=\"language-python\">This is father init\n&lt;class '__main__.SonClass'&gt;\nThis is a son method\n</code></pre>\n<p>可以看到子类初始化的时候没有显式指定<code>__init__</code>，就会默认调用父类的<code>__init__</code>。</p>\n<p>如果我们显式的指定<code>__init__</code>会有什么后果？我们将注释去掉，结果如下：</p>\n<p>注意的是这里的super行仍有注释存在。</p>\n<pre><code class=\"language-python\">This is son init\n&lt;class '__main__.SonClass'&gt;\nThis is a son method\n</code></pre>\n<p>这里就要引出<code>super()</code>方法了，这里先不说名为什么要用super()，以及super()是如何实现的，我们就先姑且把它当作父类实例的代指函数，通过他就可以调用父类的对象。</p>\n<p>我们把对应的super注释去掉，看看结果会如何：</p>\n<pre><code class=\"language-python\">This is father init\nThis is son init\n&lt;class '__main__.SonClass'&gt;\nThis is a son method\n</code></pre>\n<p>可以看到父类的<code>__init__</code>方法也被调用了。</p>\n<p>上述的内容可以一句话总结一下：</p>\n<p>子类没有显式指定的时候，会自动调用父类的init，子类显示指定的时候也要显式调用父类的init。</p>\n<p>需要补充的是，在没有显式指定的时候，父类的实例变量并无法访问，之恩那个访问到对应的父类的类变量。修改上文的代码后，来验证这个内容：</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(&quot;This is a father method&quot;)\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        #super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self):\n        print(&quot;This is a son method&quot;)\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method()\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"language-shell\">This is son init\n&lt;class '__main__.SonClass'&gt;\nfather class variable\nTraceback (most recent call last):\n  File &quot;D:\\SafeZone\\PythonProjects\\ICS_4\\main.py&quot;, line 25, in &lt;module&gt;\n    print(son.x)\nAttributeError: 'SonClass' object has no attribute 'x'\n</code></pre>\n<h3 id=\"3-2派生类方法的扩展与重载\">3.2派生类方法的扩展与重载</h3>\n<p>重载派生类的方法很简单，只需要直接修改参数内容即可：</p>\n<p>如下代码所示，重载了对应的method方法：</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(&quot;This is a father method&quot;)\n\n\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        print('son_value is ' + son_value)\n        print(&quot;This is a son method&quot;)\n\n\nson = SonClass()\nprint(son.__class__)\nprint(son.y)\nprint(son.x)\nson.method('mother fucker')\n</code></pre>\n<p>输出结果如下：</p>\n<pre><code class=\"language-shell\">This is father init\nThis is son init\n&lt;class '__main__.SonClass'&gt;\nfather class variable\nfather variable\nson_value is mother fucker\nThis is a son method\n</code></pre>\n<p>扩展就更加简单，只需要通过super来调用父类，即可接着父类方法来实现续写：</p>\n<pre><code class=\"language-python\">    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(&quot;This is a son method&quot;)\n</code></pre>\n<p>输出结果如下：</p>\n<pre><code class=\"language-python\">father class variable\nfather variable\nThis is a father method\nson_value is mother fucker\nThis is a son method\n</code></pre>\n<h3 id=\"3-3-super-函数详解\">3.3 super()函数详解</h3>\n<p>上文中所有super的写法我都依照python2的写法来实现的，实际上python3对于super有了更简便的写法，如下所示：</p>\n<pre><code class=\"language-python\">super(SonClass, self).method()#python 2\nsuper().method()#python 3\n</code></pre>\n<p>这两个关键的参数被省略了，这对新手来说是一个很方便的事情，但是参数的省略带来信息的丢失，总是让人很迷茫，super到底的作用是什么？同时有很多python3的代码也采用了python2的写法（python3 对这个是兼容的）</p>\n<p>那么不禁让人提问 ：super是如何工作的？两个参数的作用是什么呢？</p>\n<p>super的定义如下：</p>\n<pre><code class=\"language-python\">class super(type, object_or_type=None)\n返回一个代理对象，它会将方法调用委托给 type 的父类或兄弟类。 这对于访问已在类中被重载的继承方法很有用。\n</code></pre>\n<p>type这里只是一个参数名称，如果你要问和type有什么关系，不要忘记了所有class的类型是type，也就是说这里要填一个类对象进去。</p>\n<p>对于后一个参数的理解就更加简单了，填入一个<strong>实例对象</strong>或者<strong>类对象</strong>即可。</p>\n<p>那对这两个参数填入的内容已经有大概的了解，那么这两个参数到底有什么用？</p>\n<p>这两参数被用来实例化super类，对没错。super是一个类对象：</p>\n<pre><code class=\"language-python\">&gt;&gt;&gt;super.__class__\n&lt;class 'type'&gt;\n&gt;&gt;&gt;class A:pass\n&gt;&gt;&gt;super(A).__class__\n&lt;class 'super'&gt;\n</code></pre>\n<p>实例化之后将会返回代理对象，代理的就是他的祖先类的对象（可按照顺序调用各种祖先类对象，具体按照什么顺序稍后会解释）。它会将方法调用委托给 <em>type</em> 的父类或兄弟类。</p>\n<p><em>object_or_type</em> 确定要用于搜索的 <a href=\"https://docs.python.org/zh-cn/3/glossary.html#term-method-resolution-order\">method resolution order</a>。 搜索会从 <em>type</em> 之后的类开始。</p>\n<p><strong>MRO</strong> 指的是 type(<strong>object_or_type</strong>)的 MRO, MRO 中的那个类就是 <strong>type</strong>。注意这里使用粗体的指的是参数，前边的type为python内置函数。</p>\n<p>也就是说，object_or_type用于确定在哪一颗祖先树上进行搜索，因为Python是多继承的(这里还没有讲多继承是如何实现的，不过没关系，可以从真实世界的族谱上理解一下)，所以其继承关系会构建出来一颗祖先树。</p>\n<p>在早期python的经典类结构，也就是python2中MRO遵循的是从左到右，深度优先，但是在2.2版本后多继承遵循了C3算法，详细可参考：<a href=\"https://www.python.org/download/releases/2.3/mro/\">The Python 2.3 Method Resolution Order | Python.org</a>里面详细论述了python是如何实现MRO，考虑到文章的长度，在以后会单独写一篇关于继承顺序的文章，这里可以先看一下参考文献。</p>\n<p>举一个简单的例子：</p>\n<p>For example, if <a href=\"https://docs.python.org/3/library/stdtypes.html#class.__mro__\"><code>__mro__</code></a> of <em>object_or_type</em> is <code>D -&gt; B -&gt; C -&gt; A -&gt; object</code> and the value of <em>type</em> is <code>B</code>, then <a href=\"https://docs.python.org/3/library/functions.html#super\"><code>super()</code></a> searches <code>C -&gt; A -&gt; object</code>。</p>\n<p>想要了解某一个类的MRO情况可以通过__mro__属性来获取：</p>\n<pre><code class=\"language-python\">print(SonClass.__mro__)\n输出：\n(&lt;class '__main__.SonClass'&gt;, &lt;class '__main__.FatherClass'&gt;, &lt;class '__main__.UncleClass'&gt;, &lt;class 'object'&gt;)\n</code></pre>\n<p>这里再介绍一下两个内置函数，这两个内置函数用来测试是否满足的super的参数条件。</p>\n<ul>\n<li>使用 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#isinstance\"><code>isinstance()</code></a> 来检查一个实例的类型: <code>isinstance(obj, int)</code> 仅会在 <code>obj.__class__</code> 为 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 或某个派生自 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 的类时为 <code>True</code>。简单来说作用是检测实例是否是某一个类子类的实例对象。</li>\n<li>使用 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#issubclass\"><code>issubclass()</code></a> 来检查类的继承关系: <code>issubclass(bool, int)</code> 为 <code>True</code>，因为 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#bool\"><code>bool</code></a> 是 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 的子类。 但是，<code>issubclass(float, int)</code> 为 <code>False</code>，因为 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#float\"><code>float</code></a> 不是 <a href=\"https://docs.python.org/zh-cn/3/library/functions.html#int\"><code>int</code></a> 的子类。 检测class对象是否为某一个类对象的子类。</li>\n</ul>\n<p>实际上super的参数还有另一种情况，当object_or_type 输入类型也是type的时候，就需要满足issubclass为true的条件，这时候super的调用就成了这样：</p>\n<pre><code class=\"language-python\">super(type1, type2)\n</code></pre>\n<p>MRO 指的是 <strong>type2</strong> 的 <strong>MRO</strong>, <strong>MRO</strong> 中的那个类就是 <strong>type1</strong> ，同时 <strong>issubclass(type2, type1) == True</strong> 。</p>\n<p>那么， <strong>super()</strong> 实际上做了啥呢？简单来说就是：提供一个 <strong>MRO</strong> 以及一个 <strong>MRO</strong> 中的类 <strong>C</strong> ， <strong>super()</strong> 将返回一个从 <strong>MRO</strong> 中 <strong>C</strong> 之后的类中查找方法的对象。</p>\n<p>那是不是意味着我们也可以这样写，写了之后会有什么效果呢？</p>\n<p>这样调用会有什么结果呢？我们再举一个例子，在上文的代码中扩充添加一个TestClass类，他是最底层的类，是所有类的子类：</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n\n    def method(self):\n        print(&quot;This is a father method&quot;)\n\n    def function():\n        print('This is a father function')\nclass SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(&quot;This is a son method&quot;)\n\n\nclass TestClass(SonClass):\n    def __init__(self):\n        super().__init__()\n\n    def metod(self):\n        pass\n\n</code></pre>\n<p>然后进行调用：</p>\n<pre><code class=\"language-python\">son = SonClass()\nprint(super(SonClass, TestClass).y)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-shell\">This is father init\nThis is son init\nfather class variable\n</code></pre>\n<p>可以看到他直接找到了父类作为调用对象，并输出了对应的y属性，需要注意的是这里无法针对方法对象来实现，原因很简单，并没有self参数作为载体，来进行方法的调用。记住上文说的：<strong>任何一个作为类属性的函数都为该类的实例定义了一个相应方法</strong>。不能把它作为函数对象来调用。</p>\n<h3 id=\"3-4私有变量\">3.4私有变量</h3>\n<p>那种仅限从一个对象内部访问的“私有”实例变量在 Python 中并不存在。这也算是设计特点， 但是，大多数 Python 代码都遵循这样一个约定：带有一个下划线的名称 (例如 <code>_spam</code>) 应该被当作是 API 的非公有部分 (无论它是函数、方法或是数据成员)。 这应当被视为一个实现细节，可能不经通知即加以改变。</p>\n<p>但是这样并不是很有效的操作，例如避免名称与子类所定义的名称相冲突，即使去使用 <code>_spam</code>的形式也是不合理的，子类仍能继承到，因此Python存在一个机制，叫做<strong>名称改写</strong>。</p>\n<h3 id=\"3-4-1名称改写\">3.4.1名称改写</h3>\n<p>形式为 <code>__spam</code> 的标识符，至少带有两个前缀下划线，至多一个后缀下划线）的文本将被替换为 <code>_classname__spam</code>，其中 <code>classname</code> 为去除了前缀下划线的当前类名称。</p>\n<p>这种改写不考虑标识符的句法位置，只要它出现在类定义内部就会进行。</p>\n<p>举个例子：如何使用私有变量进行解耦合</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.method()\n\n    def method(self):\n        print(&quot;This is a father method&quot;)\n</code></pre>\n<p>可以看到 父类这里的init和method进行了耦合，init依赖于 method。产生了耦合</p>\n<p>子类继承的时候无法重写method方法，如果重写了就会报错：</p>\n<p>子类定义如下：</p>\n<pre><code class=\"language-python\">class SonClass(FatherClass):\n\n    def __init__(self):\n        super(SonClass, self).__init__()\n        print('This is son init')\n\n    def method(self, son_value):\n        super(SonClass, self).method()\n        print('son_value is ' + son_value)\n        print(&quot;This is a son method&quot;)\n</code></pre>\n<p>报错信息如下：</p>\n<pre><code class=\"language-shell\">Traceback (most recent call last):\n  File &quot;D:\\SafeZone\\PythonProjects\\ICS_4\\main.py&quot;, line 33, in &lt;module&gt;\n    son = SonClass()\n  File &quot;D:\\SafeZone\\PythonProjects\\ICS_4\\main.py&quot;, line 16, in __init__\n    super(SonClass, self).__init__()\n  File &quot;D:\\SafeZone\\PythonProjects\\ICS_4\\main.py&quot;, line 7, in __init__\n    self.method()\nTypeError: SonClass.method() missing 1 required positional argument: 'son_value'\nThis is father init\n</code></pre>\n<p>如何进行解耦合呢？</p>\n<pre><code class=\"language-python\">class FatherClass(object):\n    __y = 'father class variable'\n\n    def __init__(self):\n        self.x = 'father variable'\n        print('This is father init')\n        self.__method()\n\n    def method(self):\n        print(&quot;This is a father method&quot;)\n\n    __method = method\n</code></pre>\n<p>修改父类如上，使用名称改写来实现其解耦，子类无法直接调用到方法__y，实际上被替换为<code>_FatherClass__method()</code> ,不要没事调用他。</p>\n<p>上面的示例即使在 <code>SonClass</code> 引入了一个 <code>__update</code> 标识符的情况下也不会出错，因为它会在 <code>FatherClass</code> 类中被替换为 <code>_FatherClass__update</code> 而在 <code>MappingSubclass</code> 类中被替换为 <code>_MappingSubclass__update</code>。</p>\n<h2 id=\"4-dataclass\">4.dataclass</h2>\n<p>有时候需要一些数据类型类似C的struct结构的，需要糅合一部分数据在一起，Python提供了预实现模块<strong>dataclasses</strong>，</p>\n<p>我们引用就可以了，举个例子：</p>\n<pre><code class=\"language-python\">from dataclasses import dataclass\n\n@dataclass\nclass Chinese:\n    name: str\n    money: str\n    appearance: str\n    theone:bool\n</code></pre>\n<p>如何使用呢？</p>\n<pre><code class=\"language-python\">neonexus = Chinese('neonexus',money=0,appearance='normal',theone=False)\nprint(neonexus.theone)\n</code></pre>\n<p>输出结果：</p>\n<pre><code class=\"language-python\">&lt;super: &lt;class 'SonClass'&gt;, &lt;TestClass object&gt;&gt;\nFalse\n</code></pre>\n<h1>参考文章：</h1>\n<p><a href=\"https://rhettinger.wordpress.com/2011/05/26/super-considered-super/\">Python’s super() considered super! | Deep Thoughts by Raymond Hettinger (wordpress.com)</a></p>\n<p><a href=\"https://sixty-north.com/blog/pythons-super-not-as-simple-as-you-thought.html\">Good With Computers (sixty-north.com)</a></p>\n<p><a href=\"https://www.runoob.com/w3cnote/python-super-detail-intro.html\">Python super 详解 | 菜鸟教程 (runoob.com)</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__init__\">3. 数据模型 — Python 3.12.0 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/2.7/reference/datamodel.html?highlight=__init__#object.__init__\">3. 数据模型 — Python 2.7.18 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/3/library/functions.html#super\">内置函数 — Python 3.12.0 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/3/tutorial/classes.html\">9. 类 — Python 3.12.0 文档</a></p>\n<p><a href=\"https://docs.python.org/zh-cn/2.7/tutorial/classes.html\">9. 类 — Python 2.7.18 文档</a></p>\n"},{"title":"BionetServer-No1. Q&A-Docker","date":"2024-09-21T12:46:25.000Z","_content":"\n# BionetServer-No1. Q&A-Docker\n\n<img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.0\n\n\nDate: 2025.10.10\n\nAuthors：NeoNexus\n\n<!-- toc -->\n\n[TOC]\n\n\n\n## Q&A：\n\n### 问题零 通过容器写入的文件无法运行？\n\n容器的用户都是root身份，而UI登陆的是以用户的身份来登陆的，普通用户当然没有权限来操作root的内容，解决办法：\n\n将文件修改成主机所有者，在容器的终端中使用命令\n\n```bash\nsudo chown UID 文件/目录路径\n```\n\n如果要修改某个文件夹的全部文件，可以使用：\n\n```bash\nsudo chown -R UID 文件/目录路径\n```\n\nUID信息在UI界面使用命令获取，比如：\n\n![image-20240607235021091](https://s2.loli.net/2024/06/07/dhEWOpuyINHF6SY.png)\n\n打个比方，修改我在主机上：/Datasets/bionet/Dataset/A/ 文件夹的可以使用：\n\n```bash\nsudo chown -R 1001 /Datasets/bionet/Dataset/A/\n```\n\n这样这个文件夹下所有文件都可以正常使用。\n\nR语言已经实现了UID的同步，所以没有这个问题。\n\n这里放一个在Jupyter中修改权限的的例子：\n\n```bash\n# ls -alh\ntotal 8.0K\ndrwxr-xr-x 2 root root 4.0K Apr 18  2022 .\ndrwxr-xr-x 1 root root 4.0K Jun  7 15:51 ..\n# cd /tf 首先要到对应的文件夹下来操作文件\n# ls -alh\ntotal 6.9M\ndrwxrwxrwx  1 root root 4.0K Jun  7 15:51 .\ndrwxr-xr-x  1 root root 4.0K Jun  7 15:51 ..\ndrwxrwxrwx 11 1001 1002   14 Jun  5 05:03 Datasets\ndrwxrwxrwx  6 root root 6.8M May 26 06:23 NCZone\ndrwxrwxr--  6 1001 1001 4.0K Jun  7 15:30 Share_Space\ndrwxrwxrwx  1 root root 4.0K Sep  2  2023 tensorflow-tutorials\n# cd Share_Space\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1000 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n# pwd\n/tf/Share_Space\n# sudo chown 1001 TEST\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1001 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n```\n\n### 问题一 容器重启之后无法连接？\n\n容器重启之后ssh服务被中断，需要手动重启，打开portainer输入以下命令：\n\n```bash\n service ssh restart\n```\n\n即可重新连接。\n\n![image-20240426194356414](https://s2.loli.net/2024/04/26/uPmNqxek4pWlFCa.png)\n\n\n\n### 问题二 创建一个Docker失败之后再次连接相同端口为什么不行？\n\n因为ssh有校验措施，只能连接到同一台物理设备，当你的设备失效以后就无法使用，删除过去的key即可重新连接：\n\n<img src=\"https://s2.loli.net/2024/04/01/yJDmalXE2xfwLR6.png\" alt=\"image-20240401160821511\" style=\"zoom:80%;\" />\n\n### 问题三 关闭了VSCode代码就停止运行了？\n\n实际上是这样的，SSH需要保持连接才能运行，不过不要紧我们使用命令来将代码任务注册到后台来持久运行，这样你的代码只需要在默认模式下调整好之后，在再使用如下命令即可保持运行：\n\n当我们运行的代码的时候实际上就是在命令行中调用了命令：\n\n![image-20240401192019401](https://s2.loli.net/2024/04/01/fdlr9SjuFY2qiZx.png)\n\n我们需要将这个命令和nohup来结合实现运行不掉线：\n\n同见问题五正确更新\n\n按方向键盘的上键可以找到上一次运行的命令，当然运行之前要确认当前目录在哪里，是不是你想要的目录？\n\n```bash\n(base) root@77d5769f235a:/# cd /home/Share_Space/                          \n(base) root@77d5769f235a:/home/Share_Space# ls\ndata  test.py\n(base) root@77d5769f235a:/home/Share_Space# /opt/conda/bin/python /home/Share_Space/test.py\n```\n\n下面我们来使用nohup将任务保持在后台，格式如下：\n\n```sh\nnohup 你的运行命令 > output.file 2>&1 &\n```\n\n结合上边的命令，效果如下：\n\n```bash\nnohup /opt/conda/bin/python /home/Share_Space/test.py > output.file 2>&1 &\n```\n\n我们来运行一下：\n\n![image-20240401195117010](https://s2.loli.net/2024/04/01/5ui9UFh6DjNaqpd.png)\n\n同时可以看到，这里有了对应的输出文件，输出文件保存了所有输出：\n\n![image-20240401195140188](https://s2.loli.net/2024/04/01/9tsvoN1ZgQEAajJ.png)\n\n<img src=\"https://s2.loli.net/2024/04/01/5ZuA7HsbzYXVJD3.png\" alt=\"image-20240401195202219\" style=\"zoom: 80%;\" />\n\n当然运行完成之后文件显示的更加准确~\n\n### 问题四 Bad owner or permissions on\n\n如果出现**Bad owner or permissions on C:\\\\Users\\\\Administrator/.ssh/config > 过程试图写入的管道不存在。 >**的问题，该问题是config文件权限高，vscode不能修改造成的，两种解决办法第一种是修改原来C:盘的config文件权限；第二种是在其他盘新建一个config文件，用于存储远程连接用户，地址等基本信息。\n\n**第一种解决办法**\n\na.找到.ssh文件夹。它通常位于C:\\Users\n\n<img src=\"https://pic2.zhimg.com/80/v2-00510cb6ff02667327ab74cf045e0475_720w.webp\" alt=\"img\" style=\"zoom:80%;\" />\n\nb.右键单击.ssh文件夹，然后单击“属性”，选择“安全”\n\n<img src=\"https://pic4.zhimg.com/80/v2-403dcc44b073590af68d8350a8d29733_720w.webp\" alt=\"img\" style=\"zoom:80%;\" />\n\nc.单击“高级”。 单击“禁用继承”，单击“确定”。 将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。\n\nd.此时所有用户都将被删除。添加所有者。在同一窗口中，单击“编辑”按钮，单击“添加”以显示“选择用户或组”窗口。\n\n<img src=\"https://pic1.zhimg.com/80/v2-830693015d51071061ff59f4f57d0220_720w.webp\" alt=\"img\" style=\"zoom: 80%;\" />\n\ne.单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。 选择用户帐户。\n\n<img src=\"https://pic2.zhimg.com/80/v2-c68f57ffd916d49e56d985c730ccd039_720w.webp\" alt=\"img\" style=\"zoom:80%;\" />\n\nf.后面一路点击确定便可。\n\n**记得重启电脑来刷新设置。**\n\n**第二种解决办法**\n\n在除了C盘以外的文件夹新建config文件（空的就可以），在romote-SSH插件的扩展设置中，修改config文件的路径。\n\n![image-20240326115205575](https://s2.loli.net/2024/03/27/xgGATnRrw852BNW.png)\n\n### 问题五 Python脚本使用nohup运行时，指定文件没有输出内容\n\n**此问题由戴珏泓发现**\n\n实际上为Python的缓存机制带来的问题，log存在缓存区中没有及时更新：\n\n可以看到运行之后没有对应的输出;\n\n<img src=\"https://s2.loli.net/2024/10/21/OfvYEPxVqanH67c.png\" alt=\"image-20241021235853305\" style=\"zoom: 80%;\" />\n\n解决方法：\n\ncd进入脚本所在目录执行nohup命令，在命令的python路径与脚本路径之间加-u，强制输出不通过缓存直接打印\n\n例如：\n\n```shell\nnohup /opt/conda/bin/python /home/Share_Space/metrics_ml/GA_xgboost.py 2>&1  &\n```\n\n改为：\n\n```shell\nnohup /opt/conda/bin/python -u /home/Share_Space/metrics_ml/GA_xgboost.py 2>&1  &\n```\n\n### 问题六 R_studio打开之后没有见对应这两个文件夹\n\n如打开之后没有见到这两个文件夹，可以先将默认目录设置到~\n\n使用命令：\n\n```R\nsetwd(\"~\")\n```\n\n效果如图：\n\n![image-20241127114234957](https://s2.loli.net/2024/11/27/ZcEwh3GUDMXkOKj.png)\n\n然后刷新一下页面，一定要刷新一下。然后结果：应该是这样：\n\n![image-20241127114538542](https://s2.loli.net/2024/11/27/MLvFi62cVBoDnwu.png)\n\n如果还不行，可以打开命令行使用如下命令：\n\n![image-20241023232258889](https://s2.loli.net/2024/10/23/gHJXbLxNn9UBS4d.png)\n\n使用命令：\n\n```bash\n# 创建从 /home/user1/host 到 /home/host/R_Share/user1 的软链接\nln -s /home/host/R_Share/user1 /home/user1/host\n\n# 创建从 /home/user1/Datasets 到 /home/host/Datasets 的软链接\nln -s /home/host/Datasets /home/user1/Datasets\n```\n\nuser1需要替换的你的用户名，比如我的是Neo：\n\n<img src=\"https://s2.loli.net/2024/10/23/JjGr1sMXhbpDVWQ.png\" alt=\"image-20241023232512786\" style=\"zoom:67%;\" />\n\n### 问题七 创建容器提示Code Failed 500 代码错误\n\n排查是否有以下几个问题：\n\n①这一步中，需要修改的名字是否和你的账号名相同（大小写也要一致）\n\n②端口是否和其他人的重复了？（其他人的端口号可以在Container界面右滑看到）\n\n![image-20250926001725780](https://s2.loli.net/2025/09/26/HAvLQrJxMESh42e.png)\n\n③检查内存设置是否合理，镜像是否有选择对\n\n不要偷懒，直接复制这个错误的镜像号码，正确的镜像一般以bionet或者neonexus开头，下边是一个错误示范：\n\n![image-20250925235955883](https://s2.loli.net/2025/09/25/3TsF1QlIkbLBK2D.png)\n\n","source":"_posts/Bionet-Server01 Q&A——Docker篇.md","raw":"---\ntitle: BionetServer-No1. Q&A-Docker\ncategories:\n  - Bionet\ntags:\n  - Bionet\n  - ops\n  - Q&A\ndate: \"2024/09/21 20:46:25\"\n---\n\n# BionetServer-No1. Q&A-Docker\n\n<img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\" />\n\n<img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" />\n\nVersion:1.0\n\n\nDate: 2025.10.10\n\nAuthors：NeoNexus\n\n<!-- toc -->\n\n[TOC]\n\n\n\n## Q&A：\n\n### 问题零 通过容器写入的文件无法运行？\n\n容器的用户都是root身份，而UI登陆的是以用户的身份来登陆的，普通用户当然没有权限来操作root的内容，解决办法：\n\n将文件修改成主机所有者，在容器的终端中使用命令\n\n```bash\nsudo chown UID 文件/目录路径\n```\n\n如果要修改某个文件夹的全部文件，可以使用：\n\n```bash\nsudo chown -R UID 文件/目录路径\n```\n\nUID信息在UI界面使用命令获取，比如：\n\n![image-20240607235021091](https://s2.loli.net/2024/06/07/dhEWOpuyINHF6SY.png)\n\n打个比方，修改我在主机上：/Datasets/bionet/Dataset/A/ 文件夹的可以使用：\n\n```bash\nsudo chown -R 1001 /Datasets/bionet/Dataset/A/\n```\n\n这样这个文件夹下所有文件都可以正常使用。\n\nR语言已经实现了UID的同步，所以没有这个问题。\n\n这里放一个在Jupyter中修改权限的的例子：\n\n```bash\n# ls -alh\ntotal 8.0K\ndrwxr-xr-x 2 root root 4.0K Apr 18  2022 .\ndrwxr-xr-x 1 root root 4.0K Jun  7 15:51 ..\n# cd /tf 首先要到对应的文件夹下来操作文件\n# ls -alh\ntotal 6.9M\ndrwxrwxrwx  1 root root 4.0K Jun  7 15:51 .\ndrwxr-xr-x  1 root root 4.0K Jun  7 15:51 ..\ndrwxrwxrwx 11 1001 1002   14 Jun  5 05:03 Datasets\ndrwxrwxrwx  6 root root 6.8M May 26 06:23 NCZone\ndrwxrwxr--  6 1001 1001 4.0K Jun  7 15:30 Share_Space\ndrwxrwxrwx  1 root root 4.0K Sep  2  2023 tensorflow-tutorials\n# cd Share_Space\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1000 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n# pwd\n/tf/Share_Space\n# sudo chown 1001 TEST\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1001 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n```\n\n### 问题一 容器重启之后无法连接？\n\n容器重启之后ssh服务被中断，需要手动重启，打开portainer输入以下命令：\n\n```bash\n service ssh restart\n```\n\n即可重新连接。\n\n![image-20240426194356414](https://s2.loli.net/2024/04/26/uPmNqxek4pWlFCa.png)\n\n\n\n### 问题二 创建一个Docker失败之后再次连接相同端口为什么不行？\n\n因为ssh有校验措施，只能连接到同一台物理设备，当你的设备失效以后就无法使用，删除过去的key即可重新连接：\n\n<img src=\"https://s2.loli.net/2024/04/01/yJDmalXE2xfwLR6.png\" alt=\"image-20240401160821511\" style=\"zoom:80%;\" />\n\n### 问题三 关闭了VSCode代码就停止运行了？\n\n实际上是这样的，SSH需要保持连接才能运行，不过不要紧我们使用命令来将代码任务注册到后台来持久运行，这样你的代码只需要在默认模式下调整好之后，在再使用如下命令即可保持运行：\n\n当我们运行的代码的时候实际上就是在命令行中调用了命令：\n\n![image-20240401192019401](https://s2.loli.net/2024/04/01/fdlr9SjuFY2qiZx.png)\n\n我们需要将这个命令和nohup来结合实现运行不掉线：\n\n同见问题五正确更新\n\n按方向键盘的上键可以找到上一次运行的命令，当然运行之前要确认当前目录在哪里，是不是你想要的目录？\n\n```bash\n(base) root@77d5769f235a:/# cd /home/Share_Space/                          \n(base) root@77d5769f235a:/home/Share_Space# ls\ndata  test.py\n(base) root@77d5769f235a:/home/Share_Space# /opt/conda/bin/python /home/Share_Space/test.py\n```\n\n下面我们来使用nohup将任务保持在后台，格式如下：\n\n```sh\nnohup 你的运行命令 > output.file 2>&1 &\n```\n\n结合上边的命令，效果如下：\n\n```bash\nnohup /opt/conda/bin/python /home/Share_Space/test.py > output.file 2>&1 &\n```\n\n我们来运行一下：\n\n![image-20240401195117010](https://s2.loli.net/2024/04/01/5ui9UFh6DjNaqpd.png)\n\n同时可以看到，这里有了对应的输出文件，输出文件保存了所有输出：\n\n![image-20240401195140188](https://s2.loli.net/2024/04/01/9tsvoN1ZgQEAajJ.png)\n\n<img src=\"https://s2.loli.net/2024/04/01/5ZuA7HsbzYXVJD3.png\" alt=\"image-20240401195202219\" style=\"zoom: 80%;\" />\n\n当然运行完成之后文件显示的更加准确~\n\n### 问题四 Bad owner or permissions on\n\n如果出现**Bad owner or permissions on C:\\\\Users\\\\Administrator/.ssh/config > 过程试图写入的管道不存在。 >**的问题，该问题是config文件权限高，vscode不能修改造成的，两种解决办法第一种是修改原来C:盘的config文件权限；第二种是在其他盘新建一个config文件，用于存储远程连接用户，地址等基本信息。\n\n**第一种解决办法**\n\na.找到.ssh文件夹。它通常位于C:\\Users\n\n<img src=\"https://pic2.zhimg.com/80/v2-00510cb6ff02667327ab74cf045e0475_720w.webp\" alt=\"img\" style=\"zoom:80%;\" />\n\nb.右键单击.ssh文件夹，然后单击“属性”，选择“安全”\n\n<img src=\"https://pic4.zhimg.com/80/v2-403dcc44b073590af68d8350a8d29733_720w.webp\" alt=\"img\" style=\"zoom:80%;\" />\n\nc.单击“高级”。 单击“禁用继承”，单击“确定”。 将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。\n\nd.此时所有用户都将被删除。添加所有者。在同一窗口中，单击“编辑”按钮，单击“添加”以显示“选择用户或组”窗口。\n\n<img src=\"https://pic1.zhimg.com/80/v2-830693015d51071061ff59f4f57d0220_720w.webp\" alt=\"img\" style=\"zoom: 80%;\" />\n\ne.单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。 选择用户帐户。\n\n<img src=\"https://pic2.zhimg.com/80/v2-c68f57ffd916d49e56d985c730ccd039_720w.webp\" alt=\"img\" style=\"zoom:80%;\" />\n\nf.后面一路点击确定便可。\n\n**记得重启电脑来刷新设置。**\n\n**第二种解决办法**\n\n在除了C盘以外的文件夹新建config文件（空的就可以），在romote-SSH插件的扩展设置中，修改config文件的路径。\n\n![image-20240326115205575](https://s2.loli.net/2024/03/27/xgGATnRrw852BNW.png)\n\n### 问题五 Python脚本使用nohup运行时，指定文件没有输出内容\n\n**此问题由戴珏泓发现**\n\n实际上为Python的缓存机制带来的问题，log存在缓存区中没有及时更新：\n\n可以看到运行之后没有对应的输出;\n\n<img src=\"https://s2.loli.net/2024/10/21/OfvYEPxVqanH67c.png\" alt=\"image-20241021235853305\" style=\"zoom: 80%;\" />\n\n解决方法：\n\ncd进入脚本所在目录执行nohup命令，在命令的python路径与脚本路径之间加-u，强制输出不通过缓存直接打印\n\n例如：\n\n```shell\nnohup /opt/conda/bin/python /home/Share_Space/metrics_ml/GA_xgboost.py 2>&1  &\n```\n\n改为：\n\n```shell\nnohup /opt/conda/bin/python -u /home/Share_Space/metrics_ml/GA_xgboost.py 2>&1  &\n```\n\n### 问题六 R_studio打开之后没有见对应这两个文件夹\n\n如打开之后没有见到这两个文件夹，可以先将默认目录设置到~\n\n使用命令：\n\n```R\nsetwd(\"~\")\n```\n\n效果如图：\n\n![image-20241127114234957](https://s2.loli.net/2024/11/27/ZcEwh3GUDMXkOKj.png)\n\n然后刷新一下页面，一定要刷新一下。然后结果：应该是这样：\n\n![image-20241127114538542](https://s2.loli.net/2024/11/27/MLvFi62cVBoDnwu.png)\n\n如果还不行，可以打开命令行使用如下命令：\n\n![image-20241023232258889](https://s2.loli.net/2024/10/23/gHJXbLxNn9UBS4d.png)\n\n使用命令：\n\n```bash\n# 创建从 /home/user1/host 到 /home/host/R_Share/user1 的软链接\nln -s /home/host/R_Share/user1 /home/user1/host\n\n# 创建从 /home/user1/Datasets 到 /home/host/Datasets 的软链接\nln -s /home/host/Datasets /home/user1/Datasets\n```\n\nuser1需要替换的你的用户名，比如我的是Neo：\n\n<img src=\"https://s2.loli.net/2024/10/23/JjGr1sMXhbpDVWQ.png\" alt=\"image-20241023232512786\" style=\"zoom:67%;\" />\n\n### 问题七 创建容器提示Code Failed 500 代码错误\n\n排查是否有以下几个问题：\n\n①这一步中，需要修改的名字是否和你的账号名相同（大小写也要一致）\n\n②端口是否和其他人的重复了？（其他人的端口号可以在Container界面右滑看到）\n\n![image-20250926001725780](https://s2.loli.net/2025/09/26/HAvLQrJxMESh42e.png)\n\n③检查内存设置是否合理，镜像是否有选择对\n\n不要偷懒，直接复制这个错误的镜像号码，正确的镜像一般以bionet或者neonexus开头，下边是一个错误示范：\n\n![image-20250925235955883](https://s2.loli.net/2025/09/25/3TsF1QlIkbLBK2D.png)\n\n","slug":"Bionet-Server01 Q&A——Docker篇","published":1,"updated":"2025-10-11T09:28:45.073Z","comments":1,"layout":"post","photos":[],"_id":"cmgng32gx00007lwe1maz03fl","content":"<h1><span id=\"bionetserver-no1-qampa-docker\">BionetServer-No1. Q&amp;A-Docker</span></h1><p><img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\"></p>\n<p><img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\"></p>\n<p>Version:1.0</p>\n<p>Date: 2025.10.10</p>\n<p>Authors：NeoNexus</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#qa\">Q&amp;A：</a><ul>\n<li><a href=\"#问题零-通过容器写入的文件无法运行\">问题零 通过容器写入的文件无法运行？</a></li>\n<li><a href=\"#问题一-容器重启之后无法连接\">问题一 容器重启之后无法连接？</a></li>\n<li><a href=\"#问题二-创建一个docker失败之后再次连接相同端口为什么不行\">问题二 创建一个Docker失败之后再次连接相同端口为什么不行？</a></li>\n<li><a href=\"#问题三-关闭了vscode代码就停止运行了\">问题三 关闭了VSCode代码就停止运行了？</a></li>\n<li><a href=\"#问题四-bad-owner-or-permissions-on\">问题四 Bad owner or permissions on</a></li>\n<li><a href=\"#问题五-python脚本使用nohup运行时指定文件没有输出内容\">问题五 Python脚本使用nohup运行时，指定文件没有输出内容</a></li>\n<li><a href=\"#问题六-r_studio打开之后没有见对应这两个文件夹\">问题六 R_studio打开之后没有见对应这两个文件夹</a></li>\n<li><a href=\"#问题七-创建容器提示code-failed-500-代码错误\">问题七 创建容器提示Code Failed 500 代码错误</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2><span id=\"qampa\">Q&amp;A：</span></h2><h3><span id=\"问题零-通过容器写入的文件无法运行\">问题零 通过容器写入的文件无法运行？</span></h3><p>容器的用户都是root身份，而UI登陆的是以用户的身份来登陆的，普通用户当然没有权限来操作root的内容，解决办法：</p>\n<p>将文件修改成主机所有者，在容器的终端中使用命令</p>\n<pre><code class=\"lang-bash\">sudo chown UID 文件/目录路径\n</code></pre>\n<p>如果要修改某个文件夹的全部文件，可以使用：</p>\n<pre><code class=\"lang-bash\">sudo chown -R UID 文件/目录路径\n</code></pre>\n<p>UID信息在UI界面使用命令获取，比如：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/dhEWOpuyINHF6SY.png\" alt=\"image-20240607235021091\"></p>\n<p>打个比方，修改我在主机上：/Datasets/bionet/Dataset/A/ 文件夹的可以使用：</p>\n<pre><code class=\"lang-bash\">sudo chown -R 1001 /Datasets/bionet/Dataset/A/\n</code></pre>\n<p>这样这个文件夹下所有文件都可以正常使用。</p>\n<p>R语言已经实现了UID的同步，所以没有这个问题。</p>\n<p>这里放一个在Jupyter中修改权限的的例子：</p>\n<pre><code class=\"lang-bash\"># ls -alh\ntotal 8.0K\ndrwxr-xr-x 2 root root 4.0K Apr 18  2022 .\ndrwxr-xr-x 1 root root 4.0K Jun  7 15:51 ..\n# cd /tf 首先要到对应的文件夹下来操作文件\n# ls -alh\ntotal 6.9M\ndrwxrwxrwx  1 root root 4.0K Jun  7 15:51 .\ndrwxr-xr-x  1 root root 4.0K Jun  7 15:51 ..\ndrwxrwxrwx 11 1001 1002   14 Jun  5 05:03 Datasets\ndrwxrwxrwx  6 root root 6.8M May 26 06:23 NCZone\ndrwxrwxr--  6 1001 1001 4.0K Jun  7 15:30 Share_Space\ndrwxrwxrwx  1 root root 4.0K Sep  2  2023 tensorflow-tutorials\n# cd Share_Space\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1000 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n# pwd\n/tf/Share_Space\n# sudo chown 1001 TEST\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1001 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n</code></pre>\n<h3><span id=\"问题一-容器重启之后无法连接\">问题一 容器重启之后无法连接？</span></h3><p>容器重启之后ssh服务被中断，需要手动重启，打开portainer输入以下命令：</p>\n<pre><code class=\"lang-bash\"> service ssh restart\n</code></pre>\n<p>即可重新连接。</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/uPmNqxek4pWlFCa.png\" alt=\"image-20240426194356414\"></p>\n<h3><span id=\"问题二-创建一个docker失败之后再次连接相同端口为什么不行\">问题二 创建一个Docker失败之后再次连接相同端口为什么不行？</span></h3><p>因为ssh有校验措施，只能连接到同一台物理设备，当你的设备失效以后就无法使用，删除过去的key即可重新连接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/yJDmalXE2xfwLR6.png\" alt=\"image-20240401160821511\" style=\"zoom:80%;\"></p>\n<h3><span id=\"问题三-关闭了vscode代码就停止运行了\">问题三 关闭了VSCode代码就停止运行了？</span></h3><p>实际上是这样的，SSH需要保持连接才能运行，不过不要紧我们使用命令来将代码任务注册到后台来持久运行，这样你的代码只需要在默认模式下调整好之后，在再使用如下命令即可保持运行：</p>\n<p>当我们运行的代码的时候实际上就是在命令行中调用了命令：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/fdlr9SjuFY2qiZx.png\" alt=\"image-20240401192019401\"></p>\n<p>我们需要将这个命令和nohup来结合实现运行不掉线：</p>\n<p>同见问题五正确更新</p>\n<p>按方向键盘的上键可以找到上一次运行的命令，当然运行之前要确认当前目录在哪里，是不是你想要的目录？</p>\n<pre><code class=\"lang-bash\">(base) root@77d5769f235a:/# cd /home/Share_Space/                          \n(base) root@77d5769f235a:/home/Share_Space# ls\ndata  test.py\n(base) root@77d5769f235a:/home/Share_Space# /opt/conda/bin/python /home/Share_Space/test.py\n</code></pre>\n<p>下面我们来使用nohup将任务保持在后台，格式如下：</p>\n<pre><code class=\"lang-sh\">nohup 你的运行命令 &gt; output.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p>结合上边的命令，效果如下：</p>\n<pre><code class=\"lang-bash\">nohup /opt/conda/bin/python /home/Share_Space/test.py &gt; output.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p>我们来运行一下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5ui9UFh6DjNaqpd.png\" alt=\"image-20240401195117010\"></p>\n<p>同时可以看到，这里有了对应的输出文件，输出文件保存了所有输出：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/9tsvoN1ZgQEAajJ.png\" alt=\"image-20240401195140188\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5ZuA7HsbzYXVJD3.png\" alt=\"image-20240401195202219\" style=\"zoom: 80%;\"></p>\n<p>当然运行完成之后文件显示的更加准确~</p>\n<h3><span id=\"问题四-bad-owner-or-permissions-on\">问题四 Bad owner or permissions on</span></h3><p>如果出现<strong>Bad owner or permissions on C:\\Users\\Administrator/.ssh/config &gt; 过程试图写入的管道不存在。 &gt;</strong>的问题，该问题是config文件权限高，vscode不能修改造成的，两种解决办法第一种是修改原来C:盘的config文件权限；第二种是在其他盘新建一个config文件，用于存储远程连接用户，地址等基本信息。</p>\n<p><strong>第一种解决办法</strong></p>\n<p>a.找到.ssh文件夹。它通常位于C:\\Users</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-00510cb6ff02667327ab74cf045e0475_720w.webp\" alt=\"img\" style=\"zoom:80%;\"></p>\n<p>b.右键单击.ssh文件夹，然后单击“属性”，选择“安全”</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-403dcc44b073590af68d8350a8d29733_720w.webp\" alt=\"img\" style=\"zoom:80%;\"></p>\n<p>c.单击“高级”。 单击“禁用继承”，单击“确定”。 将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。</p>\n<p>d.此时所有用户都将被删除。添加所有者。在同一窗口中，单击“编辑”按钮，单击“添加”以显示“选择用户或组”窗口。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-830693015d51071061ff59f4f57d0220_720w.webp\" alt=\"img\" style=\"zoom: 80%;\"></p>\n<p>e.单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。 选择用户帐户。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-c68f57ffd916d49e56d985c730ccd039_720w.webp\" alt=\"img\" style=\"zoom:80%;\"></p>\n<p>f.后面一路点击确定便可。</p>\n<p><strong>记得重启电脑来刷新设置。</strong></p>\n<p><strong>第二种解决办法</strong></p>\n<p>在除了C盘以外的文件夹新建config文件（空的就可以），在romote-SSH插件的扩展设置中，修改config文件的路径。</p>\n<p><img src=\"https://s2.loli.net/2024/03/27/xgGATnRrw852BNW.png\" alt=\"image-20240326115205575\"></p>\n<h3><span id=\"问题五-python脚本使用nohup运行时指定文件没有输出内容\">问题五 Python脚本使用nohup运行时，指定文件没有输出内容</span></h3><p><strong>此问题由戴珏泓发现</strong></p>\n<p>实际上为Python的缓存机制带来的问题，log存在缓存区中没有及时更新：</p>\n<p>可以看到运行之后没有对应的输出;</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/OfvYEPxVqanH67c.png\" alt=\"image-20241021235853305\" style=\"zoom: 80%;\"></p>\n<p>解决方法：</p>\n<p>cd进入脚本所在目录执行nohup命令，在命令的python路径与脚本路径之间加-u，强制输出不通过缓存直接打印</p>\n<p>例如：</p>\n<pre><code class=\"lang-shell\">nohup /opt/conda/bin/python /home/Share_Space/metrics_ml/GA_xgboost.py 2&gt;&amp;1  &amp;\n</code></pre>\n<p>改为：</p>\n<pre><code class=\"lang-shell\">nohup /opt/conda/bin/python -u /home/Share_Space/metrics_ml/GA_xgboost.py 2&gt;&amp;1  &amp;\n</code></pre>\n<h3><span id=\"问题六-r_studio打开之后没有见对应这两个文件夹\">问题六 R_studio打开之后没有见对应这两个文件夹</span></h3><p>如打开之后没有见到这两个文件夹，可以先将默认目录设置到~</p>\n<p>使用命令：</p>\n<pre><code class=\"lang-R\">setwd(\"~\")\n</code></pre>\n<p>效果如图：</p>\n<p><img src=\"https://s2.loli.net/2024/11/27/ZcEwh3GUDMXkOKj.png\" alt=\"image-20241127114234957\"></p>\n<p>然后刷新一下页面，一定要刷新一下。然后结果：应该是这样：</p>\n<p><img src=\"https://s2.loli.net/2024/11/27/MLvFi62cVBoDnwu.png\" alt=\"image-20241127114538542\"></p>\n<p>如果还不行，可以打开命令行使用如下命令：</p>\n<p><img src=\"https://s2.loli.net/2024/10/23/gHJXbLxNn9UBS4d.png\" alt=\"image-20241023232258889\"></p>\n<p>使用命令：</p>\n<pre><code class=\"lang-bash\"># 创建从 /home/user1/host 到 /home/host/R_Share/user1 的软链接\nln -s /home/host/R_Share/user1 /home/user1/host\n\n# 创建从 /home/user1/Datasets 到 /home/host/Datasets 的软链接\nln -s /home/host/Datasets /home/user1/Datasets\n</code></pre>\n<p>user1需要替换的你的用户名，比如我的是Neo：</p>\n<p><img src=\"https://s2.loli.net/2024/10/23/JjGr1sMXhbpDVWQ.png\" alt=\"image-20241023232512786\" style=\"zoom:67%;\"></p>\n<h3><span id=\"问题七-创建容器提示code-failed-500-代码错误\">问题七 创建容器提示Code Failed 500 代码错误</span></h3><p>排查是否有以下几个问题：</p>\n<p>①这一步中，需要修改的名字是否和你的账号名相同（大小写也要一致）</p>\n<p>②端口是否和其他人的重复了？（其他人的端口号可以在Container界面右滑看到）</p>\n<p><img src=\"https://s2.loli.net/2025/09/26/HAvLQrJxMESh42e.png\" alt=\"image-20250926001725780\"></p>\n<p>③检查内存设置是否合理，镜像是否有选择对</p>\n<p>不要偷懒，直接复制这个错误的镜像号码，正确的镜像一般以bionet或者neonexus开头，下边是一个错误示范：</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/3TsF1QlIkbLBK2D.png\" alt=\"image-20250925235955883\"></p>\n","excerpt":"","more":"<h1 id=\"BionetServer-No1-Q-amp-A-Docker\"><a href=\"#BionetServer-No1-Q-amp-A-Docker\" class=\"headerlink\" title=\"BionetServer-No1. Q&amp;A-Docker\"></a>BionetServer-No1. Q&amp;A-Docker</h1><p><img src=\"https://s2.loli.net/2024/09/29/qWjluktz8hxAV4E.jpg\" alt=\"[lab.magiconch.com][福音戰士標題生成器]-1727547630579\" style=\"zoom:50%;\" /></p>\n<p><img src=\"https://s2.loli.net/2023/09/18/zXu5EpoCmKH8FiJ.jpg\" alt=\"标准监督\" style=\"zoom: 50%;\" /></p>\n<p>Version:1.0</p>\n<p>Date: 2025.10.10</p>\n<p>Authors：NeoNexus</p>\n<!-- toc -->\n<ul>\n<li><a href=\"#qa\">Q&amp;A：</a><ul>\n<li><a href=\"#问题零-通过容器写入的文件无法运行\">问题零 通过容器写入的文件无法运行？</a></li>\n<li><a href=\"#问题一-容器重启之后无法连接\">问题一 容器重启之后无法连接？</a></li>\n<li><a href=\"#问题二-创建一个docker失败之后再次连接相同端口为什么不行\">问题二 创建一个Docker失败之后再次连接相同端口为什么不行？</a></li>\n<li><a href=\"#问题三-关闭了vscode代码就停止运行了\">问题三 关闭了VSCode代码就停止运行了？</a></li>\n<li><a href=\"#问题四-bad-owner-or-permissions-on\">问题四 Bad owner or permissions on</a></li>\n<li><a href=\"#问题五-python脚本使用nohup运行时指定文件没有输出内容\">问题五 Python脚本使用nohup运行时，指定文件没有输出内容</a></li>\n<li><a href=\"#问题六-r_studio打开之后没有见对应这两个文件夹\">问题六 R_studio打开之后没有见对应这两个文件夹</a></li>\n<li><a href=\"#问题七-创建容器提示code-failed-500-代码错误\">问题七 创建容器提示Code Failed 500 代码错误</a></li>\n</ul>\n</li>\n</ul>\n<!-- tocstop -->\n<p>[TOC]</p>\n<h2 id=\"Q-amp-A：\"><a href=\"#Q-amp-A：\" class=\"headerlink\" title=\"Q&amp;A：\"></a>Q&amp;A：</h2><h3 id=\"问题零-通过容器写入的文件无法运行？\"><a href=\"#问题零-通过容器写入的文件无法运行？\" class=\"headerlink\" title=\"问题零 通过容器写入的文件无法运行？\"></a>问题零 通过容器写入的文件无法运行？</h3><p>容器的用户都是root身份，而UI登陆的是以用户的身份来登陆的，普通用户当然没有权限来操作root的内容，解决办法：</p>\n<p>将文件修改成主机所有者，在容器的终端中使用命令</p>\n<pre><code class=\"lang-bash\">sudo chown UID 文件/目录路径\n</code></pre>\n<p>如果要修改某个文件夹的全部文件，可以使用：</p>\n<pre><code class=\"lang-bash\">sudo chown -R UID 文件/目录路径\n</code></pre>\n<p>UID信息在UI界面使用命令获取，比如：</p>\n<p><img src=\"https://s2.loli.net/2024/06/07/dhEWOpuyINHF6SY.png\" alt=\"image-20240607235021091\"></p>\n<p>打个比方，修改我在主机上：/Datasets/bionet/Dataset/A/ 文件夹的可以使用：</p>\n<pre><code class=\"lang-bash\">sudo chown -R 1001 /Datasets/bionet/Dataset/A/\n</code></pre>\n<p>这样这个文件夹下所有文件都可以正常使用。</p>\n<p>R语言已经实现了UID的同步，所以没有这个问题。</p>\n<p>这里放一个在Jupyter中修改权限的的例子：</p>\n<pre><code class=\"lang-bash\"># ls -alh\ntotal 8.0K\ndrwxr-xr-x 2 root root 4.0K Apr 18  2022 .\ndrwxr-xr-x 1 root root 4.0K Jun  7 15:51 ..\n# cd /tf 首先要到对应的文件夹下来操作文件\n# ls -alh\ntotal 6.9M\ndrwxrwxrwx  1 root root 4.0K Jun  7 15:51 .\ndrwxr-xr-x  1 root root 4.0K Jun  7 15:51 ..\ndrwxrwxrwx 11 1001 1002   14 Jun  5 05:03 Datasets\ndrwxrwxrwx  6 root root 6.8M May 26 06:23 NCZone\ndrwxrwxr--  6 1001 1001 4.0K Jun  7 15:30 Share_Space\ndrwxrwxrwx  1 root root 4.0K Sep  2  2023 tensorflow-tutorials\n# cd Share_Space\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1000 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n# pwd\n/tf/Share_Space\n# sudo chown 1001 TEST\n# ls -alh\ntotal 28K\ndrwxrwxr-- 6 1001 1001 4.0K Jun  7 15:30 .\ndrwxrwxrwx 1 root root 4.0K Jun  7 15:51 ..\ndrwx------ 4 root root 4.0K Jun  7 15:30 .Trash-0\ndrwxr-xr-x 2 root root 4.0K Jun  7 15:30 .ipynb_checkpoints\ndrwxrwxr-- 6 root root 4.0K May  4 11:07 PTM\ndrwxrwxr-- 2 1001 1000 4.0K Jun  7 09:13 TEST\n-rwxrwxr-- 1 root root 2.2K Apr 23 15:11 test.py\n</code></pre>\n<h3 id=\"问题一-容器重启之后无法连接？\"><a href=\"#问题一-容器重启之后无法连接？\" class=\"headerlink\" title=\"问题一 容器重启之后无法连接？\"></a>问题一 容器重启之后无法连接？</h3><p>容器重启之后ssh服务被中断，需要手动重启，打开portainer输入以下命令：</p>\n<pre><code class=\"lang-bash\"> service ssh restart\n</code></pre>\n<p>即可重新连接。</p>\n<p><img src=\"https://s2.loli.net/2024/04/26/uPmNqxek4pWlFCa.png\" alt=\"image-20240426194356414\"></p>\n<h3 id=\"问题二-创建一个Docker失败之后再次连接相同端口为什么不行？\"><a href=\"#问题二-创建一个Docker失败之后再次连接相同端口为什么不行？\" class=\"headerlink\" title=\"问题二 创建一个Docker失败之后再次连接相同端口为什么不行？\"></a>问题二 创建一个Docker失败之后再次连接相同端口为什么不行？</h3><p>因为ssh有校验措施，只能连接到同一台物理设备，当你的设备失效以后就无法使用，删除过去的key即可重新连接：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/yJDmalXE2xfwLR6.png\" alt=\"image-20240401160821511\" style=\"zoom:80%;\" /></p>\n<h3 id=\"问题三-关闭了VSCode代码就停止运行了？\"><a href=\"#问题三-关闭了VSCode代码就停止运行了？\" class=\"headerlink\" title=\"问题三 关闭了VSCode代码就停止运行了？\"></a>问题三 关闭了VSCode代码就停止运行了？</h3><p>实际上是这样的，SSH需要保持连接才能运行，不过不要紧我们使用命令来将代码任务注册到后台来持久运行，这样你的代码只需要在默认模式下调整好之后，在再使用如下命令即可保持运行：</p>\n<p>当我们运行的代码的时候实际上就是在命令行中调用了命令：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/fdlr9SjuFY2qiZx.png\" alt=\"image-20240401192019401\"></p>\n<p>我们需要将这个命令和nohup来结合实现运行不掉线：</p>\n<p>同见问题五正确更新</p>\n<p>按方向键盘的上键可以找到上一次运行的命令，当然运行之前要确认当前目录在哪里，是不是你想要的目录？</p>\n<pre><code class=\"lang-bash\">(base) root@77d5769f235a:/# cd /home/Share_Space/                          \n(base) root@77d5769f235a:/home/Share_Space# ls\ndata  test.py\n(base) root@77d5769f235a:/home/Share_Space# /opt/conda/bin/python /home/Share_Space/test.py\n</code></pre>\n<p>下面我们来使用nohup将任务保持在后台，格式如下：</p>\n<pre><code class=\"lang-sh\">nohup 你的运行命令 &gt; output.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p>结合上边的命令，效果如下：</p>\n<pre><code class=\"lang-bash\">nohup /opt/conda/bin/python /home/Share_Space/test.py &gt; output.file 2&gt;&amp;1 &amp;\n</code></pre>\n<p>我们来运行一下：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5ui9UFh6DjNaqpd.png\" alt=\"image-20240401195117010\"></p>\n<p>同时可以看到，这里有了对应的输出文件，输出文件保存了所有输出：</p>\n<p><img src=\"https://s2.loli.net/2024/04/01/9tsvoN1ZgQEAajJ.png\" alt=\"image-20240401195140188\"></p>\n<p><img src=\"https://s2.loli.net/2024/04/01/5ZuA7HsbzYXVJD3.png\" alt=\"image-20240401195202219\" style=\"zoom: 80%;\" /></p>\n<p>当然运行完成之后文件显示的更加准确~</p>\n<h3 id=\"问题四-Bad-owner-or-permissions-on\"><a href=\"#问题四-Bad-owner-or-permissions-on\" class=\"headerlink\" title=\"问题四 Bad owner or permissions on\"></a>问题四 Bad owner or permissions on</h3><p>如果出现<strong>Bad owner or permissions on C:\\Users\\Administrator/.ssh/config &gt; 过程试图写入的管道不存在。 &gt;</strong>的问题，该问题是config文件权限高，vscode不能修改造成的，两种解决办法第一种是修改原来C:盘的config文件权限；第二种是在其他盘新建一个config文件，用于存储远程连接用户，地址等基本信息。</p>\n<p><strong>第一种解决办法</strong></p>\n<p>a.找到.ssh文件夹。它通常位于C:\\Users</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-00510cb6ff02667327ab74cf045e0475_720w.webp\" alt=\"img\" style=\"zoom:80%;\" /></p>\n<p>b.右键单击.ssh文件夹，然后单击“属性”，选择“安全”</p>\n<p><img src=\"https://pic4.zhimg.com/80/v2-403dcc44b073590af68d8350a8d29733_720w.webp\" alt=\"img\" style=\"zoom:80%;\" /></p>\n<p>c.单击“高级”。 单击“禁用继承”，单击“确定”。 将出现警告弹出窗口。单击“从此对象中删除所有继承的权限”。</p>\n<p>d.此时所有用户都将被删除。添加所有者。在同一窗口中，单击“编辑”按钮，单击“添加”以显示“选择用户或组”窗口。</p>\n<p><img src=\"https://pic1.zhimg.com/80/v2-830693015d51071061ff59f4f57d0220_720w.webp\" alt=\"img\" style=\"zoom: 80%;\" /></p>\n<p>e.单击“高级”，然后单击“立即查找”按钮。应显示用户结果列表。 选择用户帐户。</p>\n<p><img src=\"https://pic2.zhimg.com/80/v2-c68f57ffd916d49e56d985c730ccd039_720w.webp\" alt=\"img\" style=\"zoom:80%;\" /></p>\n<p>f.后面一路点击确定便可。</p>\n<p><strong>记得重启电脑来刷新设置。</strong></p>\n<p><strong>第二种解决办法</strong></p>\n<p>在除了C盘以外的文件夹新建config文件（空的就可以），在romote-SSH插件的扩展设置中，修改config文件的路径。</p>\n<p><img src=\"https://s2.loli.net/2024/03/27/xgGATnRrw852BNW.png\" alt=\"image-20240326115205575\"></p>\n<h3 id=\"问题五-Python脚本使用nohup运行时，指定文件没有输出内容\"><a href=\"#问题五-Python脚本使用nohup运行时，指定文件没有输出内容\" class=\"headerlink\" title=\"问题五 Python脚本使用nohup运行时，指定文件没有输出内容\"></a>问题五 Python脚本使用nohup运行时，指定文件没有输出内容</h3><p><strong>此问题由戴珏泓发现</strong></p>\n<p>实际上为Python的缓存机制带来的问题，log存在缓存区中没有及时更新：</p>\n<p>可以看到运行之后没有对应的输出;</p>\n<p><img src=\"https://s2.loli.net/2024/10/21/OfvYEPxVqanH67c.png\" alt=\"image-20241021235853305\" style=\"zoom: 80%;\" /></p>\n<p>解决方法：</p>\n<p>cd进入脚本所在目录执行nohup命令，在命令的python路径与脚本路径之间加-u，强制输出不通过缓存直接打印</p>\n<p>例如：</p>\n<pre><code class=\"lang-shell\">nohup /opt/conda/bin/python /home/Share_Space/metrics_ml/GA_xgboost.py 2&gt;&amp;1  &amp;\n</code></pre>\n<p>改为：</p>\n<pre><code class=\"lang-shell\">nohup /opt/conda/bin/python -u /home/Share_Space/metrics_ml/GA_xgboost.py 2&gt;&amp;1  &amp;\n</code></pre>\n<h3 id=\"问题六-R-studio打开之后没有见对应这两个文件夹\"><a href=\"#问题六-R-studio打开之后没有见对应这两个文件夹\" class=\"headerlink\" title=\"问题六 R_studio打开之后没有见对应这两个文件夹\"></a>问题六 R_studio打开之后没有见对应这两个文件夹</h3><p>如打开之后没有见到这两个文件夹，可以先将默认目录设置到~</p>\n<p>使用命令：</p>\n<pre><code class=\"lang-R\">setwd(&quot;~&quot;)\n</code></pre>\n<p>效果如图：</p>\n<p><img src=\"https://s2.loli.net/2024/11/27/ZcEwh3GUDMXkOKj.png\" alt=\"image-20241127114234957\"></p>\n<p>然后刷新一下页面，一定要刷新一下。然后结果：应该是这样：</p>\n<p><img src=\"https://s2.loli.net/2024/11/27/MLvFi62cVBoDnwu.png\" alt=\"image-20241127114538542\"></p>\n<p>如果还不行，可以打开命令行使用如下命令：</p>\n<p><img src=\"https://s2.loli.net/2024/10/23/gHJXbLxNn9UBS4d.png\" alt=\"image-20241023232258889\"></p>\n<p>使用命令：</p>\n<pre><code class=\"lang-bash\"># 创建从 /home/user1/host 到 /home/host/R_Share/user1 的软链接\nln -s /home/host/R_Share/user1 /home/user1/host\n\n# 创建从 /home/user1/Datasets 到 /home/host/Datasets 的软链接\nln -s /home/host/Datasets /home/user1/Datasets\n</code></pre>\n<p>user1需要替换的你的用户名，比如我的是Neo：</p>\n<p><img src=\"https://s2.loli.net/2024/10/23/JjGr1sMXhbpDVWQ.png\" alt=\"image-20241023232512786\" style=\"zoom:67%;\" /></p>\n<h3 id=\"问题七-创建容器提示Code-Failed-500-代码错误\"><a href=\"#问题七-创建容器提示Code-Failed-500-代码错误\" class=\"headerlink\" title=\"问题七 创建容器提示Code Failed 500 代码错误\"></a>问题七 创建容器提示Code Failed 500 代码错误</h3><p>排查是否有以下几个问题：</p>\n<p>①这一步中，需要修改的名字是否和你的账号名相同（大小写也要一致）</p>\n<p>②端口是否和其他人的重复了？（其他人的端口号可以在Container界面右滑看到）</p>\n<p><img src=\"https://s2.loli.net/2025/09/26/HAvLQrJxMESh42e.png\" alt=\"image-20250926001725780\"></p>\n<p>③检查内存设置是否合理，镜像是否有选择对</p>\n<p>不要偷懒，直接复制这个错误的镜像号码，正确的镜像一般以bionet或者neonexus开头，下边是一个错误示范：</p>\n<p><img src=\"https://s2.loli.net/2025/09/25/3TsF1QlIkbLBK2D.png\" alt=\"image-20250925235955883\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cm3zcti05001iyjin3iobg5m7","category_id":"cm3zcti06001pyjinbfxmdwfl","_id":"cm3zcti0a002yyjine11ldas0"},{"post_id":"cm3zcti070022yjinbhzxf5lj","category_id":"cm3zcti06001pyjinbfxmdwfl","_id":"cm3zcti0b0032yjinfmht6myp"},{"post_id":"cm3zcti06001myjin16q6fgla","category_id":"cm3zcti06001pyjinbfxmdwfl","_id":"cm3zcti0b0035yjin5u8db06y"},{"post_id":"cm3zcti06001qyjinbw52gp3o","category_id":"cm3zcti06001pyjinbfxmdwfl","_id":"cm3zcti0b0038yjing7wmck21"},{"post_id":"cm3zcti06001uyjin788828b3","category_id":"cm3zcti08002eyjind9fhekli","_id":"cm3zcti0c003cyjinej3tc50z"},{"post_id":"cm3zcti09002lyjin807ph2uw","category_id":"cm3zcti06001pyjinbfxmdwfl","_id":"cm3zcti0c003gyjindz2w5bxx"},{"post_id":"cm3zcti07001xyjingc4na1pn","category_id":"cm3zcti08002eyjind9fhekli","_id":"cm3zcti0c003kyjin3f38fvnq"},{"post_id":"cm3zcti09002pyjinefos3ade","category_id":"cm3zcti0d003pyjincecf466e","_id":"cm3zcti0e0045yjin8tgsexzx"},{"post_id":"cm3zcti0a002tyjincgc14uy8","category_id":"cm3zcti0d003pyjincecf466e","_id":"cm3zcti0f004byjin0021gmfc"},{"post_id":"cm3zcti0a002xyjin9l2a3xmg","category_id":"cm3zcti0e0044yjin6fee4i3f","_id":"cm3zcti0g004myjin235i3wk0"},{"post_id":"cmgng32gx00007lwe1maz03fl","category_id":"cm3zcti06001pyjinbfxmdwfl","_id":"cmgng32h000027lwehos51nbs"}],"PostTag":[{"post_id":"cm3zcti05001iyjin3iobg5m7","tag_id":"cm3zcti0f004fyjin8p5u19oi","_id":"cm3zcti0h0051yjinbuxoeyk9"},{"post_id":"cm3zcti05001iyjin3iobg5m7","tag_id":"cm3zcti0g004nyjin8gn14wji","_id":"cm3zcti0h0053yjin3p22hez4"},{"post_id":"cm3zcti06001myjin16q6fgla","tag_id":"cm3zcti0f004fyjin8p5u19oi","_id":"cm3zcti0h005ayjin3s3oh04j"},{"post_id":"cm3zcti06001myjin16q6fgla","tag_id":"cm3zcti0h0052yjingtkl1zxq","_id":"cm3zcti0i005byjin67r68rny"},{"post_id":"cm3zcti06001myjin16q6fgla","tag_id":"cm3zcti0h0056yjin84unbnuv","_id":"cm3zcti0i005eyjin7mib2w2d"},{"post_id":"cm3zcti06001qyjinbw52gp3o","tag_id":"cm3zcti0f004fyjin8p5u19oi","_id":"cm3zcti0i005hyjinets32bg8"},{"post_id":"cm3zcti06001qyjinbw52gp3o","tag_id":"cm3zcti0g004nyjin8gn14wji","_id":"cm3zcti0i005iyjinfpns0lfi"},{"post_id":"cm3zcti06001uyjin788828b3","tag_id":"cm3zcti0i005fyjinf3woafjw","_id":"cm3zcti0i005nyjin4ddk2dsz"},{"post_id":"cm3zcti06001uyjin788828b3","tag_id":"cm3zcti0i005jyjinh7b48e1b","_id":"cm3zcti0i005oyjin0ikk38wx"},{"post_id":"cm3zcti07001xyjingc4na1pn","tag_id":"cm3zcti0i005fyjinf3woafjw","_id":"cm3zcti0j005vyjin8cwe31j7"},{"post_id":"cm3zcti07001xyjingc4na1pn","tag_id":"cm3zcti0i005jyjinh7b48e1b","_id":"cm3zcti0j005wyjine0g5a4mb"},{"post_id":"cm3zcti070022yjinbhzxf5lj","tag_id":"cm3zcti0f004fyjin8p5u19oi","_id":"cm3zcti0j0065yjinhint125k"},{"post_id":"cm3zcti070022yjinbhzxf5lj","tag_id":"cm3zcti0j005yyjin4rpm48qp","_id":"cm3zcti0j0066yjin6c6p5s6n"},{"post_id":"cm3zcti070022yjinbhzxf5lj","tag_id":"cm3zcti0j0060yjin22g2e99m","_id":"cm3zcti0k0069yjinhncmf3uk"},{"post_id":"cm3zcti09002lyjin807ph2uw","tag_id":"cm3zcti0f004fyjin8p5u19oi","_id":"cm3zcti0l006qyjinfgdz3bcx"},{"post_id":"cm3zcti09002lyjin807ph2uw","tag_id":"cm3zcti0k006nyjinh0v4amou","_id":"cm3zcti0l006syjin616l7z1f"},{"post_id":"cm3zcti09002pyjinefos3ade","tag_id":"cm3zcti0k006pyjinayx61sor","_id":"cm3zcti0l006uyjindwr9157x"},{"post_id":"cm3zcti0a002tyjincgc14uy8","tag_id":"cm3zcti0k006pyjinayx61sor","_id":"cm3zcti0l006xyjingqv33yw2"},{"post_id":"cm3zcti0a002xyjin9l2a3xmg","tag_id":"cm3zcti0l006wyjinc2bbeham","_id":"cm3zcti0l0070yjin1p5o63kk"},{"post_id":"cmgng32gx00007lwe1maz03fl","tag_id":"cm3zcti0f004fyjin8p5u19oi","_id":"cmgng32h000037lweb0hh5cja"},{"post_id":"cmgng32gx00007lwe1maz03fl","tag_id":"cm3zcti0g004nyjin8gn14wji","_id":"cmgng32h000047lwe3jp31l6x"},{"post_id":"cmgng32gx00007lwe1maz03fl","tag_id":"cmgng32h000017lwe20sabb0x","_id":"cmgng32h100057lwe76j9aveg"}],"Tag":[{"name":"Android","_id":"cm3zcthzx0003yjin5t7r3xa9"},{"name":"Kotlin","_id":"cm3zcti00000eyjin3xfvauqo"},{"name":"Viewbinding","_id":"cm3zcti05001eyjinbk7iep0q"},{"name":"Activity","_id":"cm3zcti06001tyjin025b5otf"},{"name":"Fragment","_id":"cm3zcti070021yjin9dyw0nbx"},{"name":"Android_Service","_id":"cm3zcti08002byjinfzzp6w74"},{"name":"SQLlite","_id":"cm3zcti0a002syjinetr17lv9"},{"name":"Room","_id":"cm3zcti0a0030yjin6gqq4yk9"},{"name":"RecycleView","_id":"cm3zcti0e0040yjin58drcuk5"},{"name":"BroadcastReceiver","_id":"cm3zcti0e0048yjin454n9iqe"},{"name":"Bionet","_id":"cm3zcti0f004fyjin8p5u19oi"},{"name":"ops","_id":"cm3zcti0g004nyjin8gn14wji"},{"name":"A406","_id":"cm3zcti0h0052yjingtkl1zxq"},{"name":"WIFI","_id":"cm3zcti0h0056yjin84unbnuv"},{"name":"branch","_id":"cm3zcti0i005fyjinf3woafjw"},{"name":"base","_id":"cm3zcti0i005jyjinh7b48e1b"},{"name":"blog","_id":"cm3zcti0j005yyjin4rpm48qp"},{"name":"hexo","_id":"cm3zcti0j0060yjin22g2e99m"},{"name":"JAP","_id":"cm3zcti0j0064yjin1j16bt3f"},{"name":"MOSFET","_id":"cm3zcti0k006dyjin1ktw5xgy"},{"name":"NAS","_id":"cm3zcti0k006nyjinh0v4amou"},{"name":"Pycharm","_id":"cm3zcti0k006pyjinayx61sor"},{"name":"Pytorch","_id":"cm3zcti0l006wyjinc2bbeham"},{"name":"Spark","_id":"cm3zcti0l006zyjincj6wazih"},{"name":"Hadoop","_id":"cm3zcti0l0074yjin4opya4jv"},{"name":"Scala","_id":"cm3zcti0m0078yjin4kaq1q9o"},{"name":"WSL","_id":"cm3zcti0n007ryjin47564jg6"},{"name":"Hive","_id":"cm3zcti0p0095yjine8ex3brc"},{"name":"GNU","_id":"cm3zcti0q009vyjin4ite46w4"},{"name":"C/C++","_id":"cm3zcti0q009xyjinfr9u6jk9"},{"name":"Linux","_id":"cm3zcti0q009yyjin38k8ax4w"},{"name":"Operational Amplifier","_id":"cm3zcti0q009zyjin1ym01pz9"},{"name":"Q&A","_id":"cmgng32h000017lwe20sabb0x"}]}}